<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="a study blog">
<meta property="og:type" content="website">
<meta property="og:title" content="Celery Fairy">
<meta property="og:url" content="https://woojoo520.github.io/index.html">
<meta property="og:site_name" content="Celery Fairy">
<meta property="og:description" content="a study blog">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Celery Fairy">
<meta name="twitter:description" content="a study blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://woojoo520.github.io/">





  <title>Celery Fairy</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <a href="https://github.com/woojoo520" class="github-corner" aria-label="View source on GitHub">
      <svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/>
      </svg>
    </a>
    <style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Celery Fairy</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Celery's Blog</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://woojoo520.github.io/2019/10/01/Lex-Learning/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mariana">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Celery Fairy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/01/Lex-Learning/" itemprop="url">Lex Learning</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-01T16:29:09+08:00">
                2019-10-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="LEX使用指南"><a href="#LEX使用指南" class="headerlink" title="LEX使用指南"></a>LEX使用指南</h2><p><strong>reference：</strong><a href="https://www.cnblogs.com/wp5719/p/5528896.html" target="_blank" rel="noopener">https://www.cnblogs.com/wp5719/p/5528896.html</a></p>
<p>Lex是由美国Bell实验室M.Lesk等人用C语言开发的一种词法分析器自动生成工具，它提供一种供开发者编写词法规则（正规式等）的语言（Lex语言）以及这种语言的翻译器（这种翻译器将Lex语言编写的规则翻译成为C语言程序）。</p>
<p>​     Lex是linux下的工具，本实验使用的编译工具是cygwin（cygwin在windows下模拟一个linux环境）下的flex，它与lex的使用方法基本相同，只有很少的差别。</p>
<h3 id="1-Lex的基本原理和使用方法Lex的基本工作原理为：由正规式生成NFA，将NFA变换成DFA，DFA经化简后，模拟生成词法分析器。"><a href="#1-Lex的基本原理和使用方法Lex的基本工作原理为：由正规式生成NFA，将NFA变换成DFA，DFA经化简后，模拟生成词法分析器。" class="headerlink" title="1.Lex的基本原理和使用方法Lex的基本工作原理为：由正规式生成NFA，将NFA变换成DFA，DFA经化简后，模拟生成词法分析器。"></a>1.Lex的基本原理和使用方法Lex的基本工作原理为：由正规式生成NFA，将NFA变换成DFA，DFA经化简后，模拟生成词法分析器。</h3><p>​    其中正规式由开发者使用Lex语言编写，其余部分由Lex翻译器完成.翻译器将Lex源程序翻译成一个名为lex.yy.c的C语言源文件，此文件含有两部分内容：一部分是根据正规式所构造的DFA状态转移表，另一部分是用来驱动该表的总控程序yylex()。当主程序需要从输入字符流中识别一个记号时，只需要调用一次yylex()就可以了。为了使用Lex所生成的词法分析器，我们需要将lex.yy.c程序用C编译器进行编译，并将相关支持库函数连入目标代码。Lex的使用步骤可如下图所示：</p>
<p><img src="http://img.blog.csdn.net/20151220202402465?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<h3 id="2-lex源程序的写法"><a href="#2-lex源程序的写法" class="headerlink" title="2.lex源程序的写法"></a>2.lex源程序的写法</h3><p>Lex源程序必须按照Lex语言的规范来写，其核心是一组词法规则（正规式）。一般而言，一个Lex程序分为三部分，三部分之间以符号%%分隔。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[第一部分：定义段]</span><br><span class="line">%%</span><br><span class="line">第二部分：词法规则段</span><br><span class="line">[%%</span><br><span class="line">第三部分：辅助函数段]</span><br></pre></td></tr></table></figure>

<p>其中第一部分以及第三部分和第三部分之上的%%都可以省略（即上述方括号括起的部分可以省略）。以%开头的符号和关键字，或者是词法规则段的各个规则一般顶着行首来写，前面没有空格</p>
<p>Lex中可以有注释，注释由/* 和 */括起，但是请注意，注释的行首需要有前导空白</p>
<h4 id="1）第一部分定义段的写法"><a href="#1）第一部分定义段的写法" class="headerlink" title="1）第一部分定义段的写法"></a>1）第一部分定义段的写法</h4><p>定义段可以分为两部分：</p>
<p>第一部分以符号<code>%{</code>和<code>%}</code>包裹，里面为以C语法写的一些定义和声明：例如，文件包含，宏定义，常数定义，全局变量及外部变量定义，函数声明等等。这一部分被Lex翻译器处理后会全部拷贝到文件lex.yy.c中。注意，特殊括号<code>%{</code>和<code>%}</code>都必须顶着行首写。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line">#define LT 1</span><br><span class="line">int yylval;</span><br><span class="line">%&#125;</span><br></pre></td></tr></table></figure>

<p>第二部分是一组正规定义和状态定义。正规定义是为了简化后面的词法规则而给部分正规式定义了名字。每条正规定义也都要顶着行首写。例如下面这组正规定义分别定义了letter，digit和id所表示的正规式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">letter		[A-Za-z]</span><br><span class="line">digit		[0-9]</span><br><span class="line">id			&#123;letter&#125;(&#123;letter&#125;|&#123;digit&#125;)*</span><br></pre></td></tr></table></figure>

<p>注意：上面正规定义中出现的小括号表示分组，而不是被匹配的字符。而大括号括起的部分表示正规定义名</p>
<p>状态定义也叫环境定义，它定义了匹配正规式时所处的状态的名字。状态定义以<code>%s</code>开始，后跟所定义的状态的名字，注意<code>%s</code>也要顶着行首写，例如下面一行就定义了一个名为COMMENT的状态和一个名为BAD的状态，状态名之间用空白符分隔：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%d COMMENT BAD</span><br></pre></td></tr></table></figure>

<h4 id="2-第二部分词法规则段的写法"><a href="#2-第二部分词法规则段的写法" class="headerlink" title="2) 第二部分词法规则段的写法"></a>2) 第二部分词法规则段的写法</h4><p>词法规则段列出的是词法分析器需要匹配的正规式，以及匹配正规式后需要进行的相关动作。其例子如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while		&#123;return (WHILE);&#125;</span><br><span class="line">do			&#123;return (DO);&#125;</span><br><span class="line">&#123;id&#125;		&#123;yylval = installID(); return (ID);&#125;</span><br></pre></td></tr></table></figure>

<p>每行都是一条规则，该规则的前一部分是正规式，需要顶着行首写，后一部分是匹配该正规式后需要进行的动作，这个动作使用C语法来写的，被包裹在<code>{}</code>之内，被Lex翻译器翻译后会被直接拷贝进lex.yy.c。正规式和语义动作之间要有空白隔开。其中用<code>{}</code>括住的正规式表示正规定义的名字</p>
<p>也可以若干个正规式匹配同一条语义动作，此时正规式之间要用<code>|</code>分隔</p>
<h4 id="3）第三部分辅助函数段的写法"><a href="#3）第三部分辅助函数段的写法" class="headerlink" title="3）第三部分辅助函数段的写法"></a>3）第三部分辅助函数段的写法</h4><p>辅助函数段用C语言语法来写，辅助函数一般是在词法规则段中用到的函数。这一部分一般会被直接拷贝进lex.yy.c中</p>
<h4 id="4）Lex源程序中词法规则（即正规式）的相关规定"><a href="#4）Lex源程序中词法规则（即正规式）的相关规定" class="headerlink" title="4）Lex源程序中词法规则（即正规式）的相关规定"></a>4）Lex源程序中词法规则（即正规式）的相关规定</h4><p> 详见Regulation Expression</p>
<h4 id="5）Lex源程序中常用到的变量及函数"><a href="#5）Lex源程序中常用到的变量及函数" class="headerlink" title="5）Lex源程序中常用到的变量及函数"></a>5）Lex源程序中常用到的变量及函数</h4><p><code>yyin</code>和<code>yyout</code>：这是Lex本身已定义的输入和输出文件指针。这两个变量指明了lex生成的词法分析器从哪里获得输入和输出到哪里。默认：键盘输入，屏幕输出</p>
<p><code>yytext</code>和<code>yyleng</code>：这也是lex中已定义的变量，直接用就可以了</p>
<p><code>yytext</code>：指向当前识别的词法单元（词文）的指针</p>
<p><code>yyleng</code>：当前词法单元的长度</p>
<p><code>ECHO</code>：Lex中预定义的宏，可以出现在动作中，相当于<code>fprintf(yyout, “%s”, yytext)</code>，即输出当前匹配的词法单元</p>
<p><code>yylex()</code>：词法分析驱动程序，用Lex翻译器生成的lex.yy.c内必然含有这个函数</p>
<p><code>yywrap()</code>：词法分析器遇到文件结尾时会调用<code>yywrap()</code>来决定下一步怎么做：</p>
<ul>
<li>若<code>yywrap()</code>返回0，则继续扫描</li>
<li>若返回1，则返回报告文件结尾的0标记</li>
</ul>
<p>由于词法分析器总会调用<code>yywrap</code>，因此辅助函数中最好提供<code>yywrap</code>，如果不提供，则在用C编译器编译lex.yy.c时，需要链接相应的库，库中会给出标准的<code>yywrap</code>函数（标准函数返回1）</p>
<h4 id="6）词法分析器的状态（环境）"><a href="#6）词法分析器的状态（环境）" class="headerlink" title="6）词法分析器的状态（环境）"></a>6）词法分析器的状态（环境）</h4><p>词法分析器在匹配正规式时，可以在不同状态（或环境下）运行。我们可以规定在不同状态下具有不同的匹配方式。每个词法分析器都至少有一个状态，这个状态叫做初始状态，可以用INITIAL或0来表示，如果还需要使用其他状态，可以在定义段用<code>%s</code>来定义。</p>
<p>在使用状态时，可以用如下方式写词法规则：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;state1, state2&gt; p0		&#123;action0;&#125;</span><br><span class="line">&lt;state1&gt; p1				&#123;action1;&#125;</span><br></pre></td></tr></table></figure>

<p>这两行词法规则表示：在状态<code>state1</code>和<code>state2</code>下，匹配正规式<code>p0</code>后执行动作<code>action0</code>，而在只有状态<code>state1</code>下，才可以匹配正规式<code>p1</code>后执行动作<code>action1</code>。如果不知名状态，默认情况下处于初始状态INITIAL。</p>
<p>要想进入某个特定状态，可以在动作中协商这样一句：<code>BEGIN state;</code>执行这个动作后，就进入状态<code>state</code></p>
<p>下面是一段处理C语言注释的例子，里面用到了状态的转换，在这个例子里，使用不同的状态，可以让词法分析器在处于注释中和处于注释外时使用不同的匹配规则</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">%s c_comment</span><br><span class="line">...</span><br><span class="line">%%</span><br><span class="line">&lt;INITIAL&gt;&quot;/*&quot; 		&#123;BEGIN c_comment;&#125;</span><br><span class="line">...</span><br><span class="line">&lt;c_comment&gt;&quot;*/&quot;		&#123;BEGIN 0;&#125;</span><br><span class="line">&lt;c_comment&gt;.		&#123;;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7）Lex的匹配原则"><a href="#7）Lex的匹配原则" class="headerlink" title="7）Lex的匹配原则"></a>7）Lex的匹配原则</h4><ul>
<li>按最长匹配原则确定被选中的单词</li>
<li>如果一个字符串能被若干正规式匹配，则先匹配排在前面的正规式</li>
</ul>
<h3 id="3-Lex生成的词法分析器如何使用"><a href="#3-Lex生成的词法分析器如何使用" class="headerlink" title="3.Lex生成的词法分析器如何使用"></a>3.<strong>Lex</strong>生成的词法分析器如何使用</h3><p>lex常常与语法分析器的生成工具yacc（第三章会讲到）同时使用。此时，一般来说，语法分析器每次都调用一次       yylex()获取一个记号。如果想自己写一个程序使用lex生成的词法分析器，则只需要在自己的程序中按需要调用yylex()函数即可。</p>
<p>​     请注意：yylex()调用结束后，输入缓冲区并不会被重置，而是仍然停留在刚才读到的地方。并且，词法分析器当前所处的状态（%s定义的那些状态）也不会改变。</p>
<p>​    完整的Lex源程序例子请见exam1.l和exam2.l。<br>​    <strong>exam1.l</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line">/* 这是注释的形式，与C中的/*...* /注释相同。 */</span><br><span class="line">/* 第一部分是定义、声明部分。这部分内容可以为空。*/</span><br><span class="line"></span><br><span class="line">%&#123;</span><br><span class="line"></span><br><span class="line">/* 写在 %&#123;...%&#125;这对特殊括号内的内容会被直接拷贝到C文件中。</span><br><span class="line"> *</span><br><span class="line"> * 这部分通常进行一些头文件声明，变量（全局，外部）、常量</span><br><span class="line"> * 的定义，用C语法。</span><br><span class="line"> *</span><br><span class="line"> * %&#123;和%&#125;两个符号都必须位于行首 </span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">/* 下面定义了需要识别的记号名，如果和yacc联合使用，这些记号名都应该在yacc中定义 */</span><br><span class="line">#include &lt;stdio.h&gt; </span><br><span class="line">#define LT					1</span><br><span class="line">#define	LE					2</span><br><span class="line">#define GT					3</span><br><span class="line">#define	GE					4</span><br><span class="line">#define	EQ					5</span><br><span class="line">#define NE					6</span><br><span class="line"></span><br><span class="line">#define WHILE				18</span><br><span class="line">#define	DO					19</span><br><span class="line">#define ID          20</span><br><span class="line">#define NUMBER      21</span><br><span class="line">#define RELOP       22</span><br><span class="line"></span><br><span class="line">#define NEWLINE     23</span><br><span class="line">#define ERRORCHAR   24</span><br><span class="line"></span><br><span class="line">int yylval;</span><br><span class="line">/* yylval 是yacc中定义的变量，用来保存记号的属性值，默认是int类型。 </span><br><span class="line"> * 在用lex实现的词法分析器中可以使用这个变量将记号的属性传递给用</span><br><span class="line"> * yacc实现的语法分析器。</span><br><span class="line"> *</span><br><span class="line"> * 注意：该变量只有在联合使用lex和yacc编写词法和语法分析器时才可在lex</span><br><span class="line"> *       中使用，此时该变量不需要定义即可使用。</span><br><span class="line"> *       单独使用lex时，编译器找不到这个变量。这里定义该变量为了“欺骗”编译器。</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">/* 这里进行正规定义和状态定义。</span><br><span class="line"> * 下面就是正规定义，注意，正规定义和状态定义都要顶着行首写。</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">delim		[ \t \n]</span><br><span class="line">/* \用来表示转义，例如\t表示制表符，\n表示换行符。*/</span><br><span class="line">ws			&#123;delim&#125;+</span><br><span class="line">letter	[A-Za-z_]</span><br><span class="line">digit		[0-9]</span><br><span class="line">id			&#123;letter&#125;(&#123;letter&#125;|&#123;digit&#125;)*</span><br><span class="line">/* 注意：上面正规定义中出现的小括号表示分组，而不是被匹配的字符。</span><br><span class="line"> *       而大括号括起的部分表示正规定义名。</span><br><span class="line"> */</span><br><span class="line">number	&#123;digit&#125;+(\.&#123;digit&#125;+)?(E[+-]?&#123;digit&#125;+)?</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* %%作为lex文件三个部分的分割符，必须位于行首 */</span><br><span class="line">/* 下面这个%%不能省略 */</span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">  /* 第二部分是翻译规则部分。 */</span><br><span class="line">  /* 写在这一部分的注释要有前导空格，否则lex编译出错。*/</span><br><span class="line">  /* 翻译规则的形式是：正规式  &#123;动作&#125;</span><br><span class="line">   * 其中，正规式要顶行首写，动作要以C语法写（动作会被拷贝到yylex()函数中，），\</span><br><span class="line">   * 正规式和动作之间要用空白分割。</span><br><span class="line">   */</span><br><span class="line">  </span><br><span class="line">&#123;ws&#125;	          &#123;;/* 此时词法分析器没有动作，也不返回，而是继续分析。 */&#125;</span><br><span class="line">  /* 正规式部分用大括号扩住的表示正规定义名，例如&#123;ws&#125;。</span><br><span class="line">   * 没有扩住的直接表示正规式本身。</span><br><span class="line">   * 一些元字符没办法表示它本身，此时可以用转义字符或</span><br><span class="line">   * 用双引号括起来，例如&quot;&lt;&quot;</span><br><span class="line">   */</span><br><span class="line">while	          &#123;return (WHILE);&#125;</span><br><span class="line">do		          &#123;return (DO);&#125;</span><br><span class="line">&#123;id&#125;	          &#123;yylval = installID (); return (ID);&#125;</span><br><span class="line">&#123;number&#125;	      &#123;yylval = installNum (); return (NUMBER);&#125;</span><br><span class="line">&quot;&lt;&quot;	            &#123;yylval = LT; return (RELOP);&#125;</span><br><span class="line">&quot;&lt;=&quot;	          &#123;yylval = LE; return (RELOP);&#125;</span><br><span class="line">&quot;=&quot;	            &#123;yylval = EQ; return (RELOP);&#125;</span><br><span class="line">&quot;&lt;&gt;&quot;	          &#123;yylval = NE; return (RELOP);&#125;</span><br><span class="line">&quot;&gt;&quot;	            &#123;yylval = GT; return (RELOP);&#125;</span><br><span class="line">&quot;&gt;=&quot;	          &#123;yylval = GE; return (RELOP);&#125;</span><br><span class="line"></span><br><span class="line">.								&#123;yylval = ERRORCHAR; return ERRORCHAR;&#125;</span><br><span class="line"> /*.匹配除换行之外的任何字符，一般可作为最后一条翻译规则。*/</span><br><span class="line"> </span><br><span class="line">%%</span><br><span class="line">/* 第三部分是辅助函数部分，这部分内容以及前面的%%都可以省略 */</span><br><span class="line">/* 辅助函数可以定义“动作”中使用的一些函数。这些函数</span><br><span class="line"> * 使用C语言编写，并会直接被拷贝到lex.yy.c中。</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">int installID () &#123;</span><br><span class="line">  /* 把词法单元装入符号表并返回指针。*/</span><br><span class="line">	return ID;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int installNum () &#123;</span><br><span class="line">	/* 类似上面的过程，但词法单元不是标识符而是数 */</span><br><span class="line">  return NUMBER;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* yywrap这个辅助函数是词法分析器遇到输入文件结尾时会调用的，用来决定下一步怎么做：</span><br><span class="line"> * 若yywrap返回0，则继续扫描；返回1，则词法分析器返回报告文件已结束的0。</span><br><span class="line"> * lex库中的标准yywrap程序就是返回1，你也可以定义自己的yywrap。</span><br><span class="line"> */</span><br><span class="line">int yywrap ()&#123;</span><br><span class="line">  return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void writeout(int c)&#123;</span><br><span class="line">  switch(c)&#123;</span><br><span class="line">  	case ERRORCHAR: fprintf(yyout, &quot;(ERRORCHAR, \&quot;%s\&quot;) &quot;, yytext);break;</span><br><span class="line">  	case RELOP: fprintf(yyout, &quot;(RELOP, \&quot;%s\&quot;) &quot;, yytext);break;  	  </span><br><span class="line">    case WHILE: fprintf(yyout, &quot;(WHILE, \&quot;%s\&quot;) &quot;, yytext);break;</span><br><span class="line">    case DO: fprintf(yyout, &quot;(DO, \&quot;%s\&quot;) &quot;, yytext);break;</span><br><span class="line">    case NUMBER: fprintf(yyout, &quot;(NUM, \&quot;%s\&quot;) &quot;, yytext);break;</span><br><span class="line">    case ID: fprintf(yyout, &quot;(ID, \&quot;%s\&quot;) &quot;, yytext);break;</span><br><span class="line">    case NEWLINE: fprintf(yyout, &quot;\n&quot;);break;</span><br><span class="line">    default:break;</span><br><span class="line">  &#125;</span><br><span class="line">  return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 辅助函数里可以使用yytext和yyleng这些外部定义的变量。</span><br><span class="line"> * yytext指向输入缓冲区当前词法单元(lexeme)的第一个字符，</span><br><span class="line"> * yyleng给出该词法单元的长度		*/</span><br><span class="line"></span><br><span class="line">/* 如果你的词法分析器并不是作为语法分析器的子程序，</span><br><span class="line"> * 而是有自己的输入输出，你可以在这里定义你的词法</span><br><span class="line"> * 分析器的main函数，main函数里可以调用yylex()</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">int main (int argc, char ** argv)&#123;</span><br><span class="line">	int c,j=0;</span><br><span class="line">	if (argc&gt;=2)&#123;</span><br><span class="line">	  if ((yyin = fopen(argv[1], &quot;r&quot;)) == NULL)&#123;</span><br><span class="line">	    printf(&quot;Can&apos;t open file %s\n&quot;, argv[1]);</span><br><span class="line">	    return 1;</span><br><span class="line">	  &#125;</span><br><span class="line">	  if (argc&gt;=3)&#123;</span><br><span class="line">	    yyout=fopen(argv[2], &quot;w&quot;);</span><br><span class="line">	  &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	/* yyin和yyout是lex中定义的输入输出文件指针，它们指明了</span><br><span class="line">	 * lex生成的词法分析器从哪里获得输入和输出到哪里。</span><br><span class="line">	 * 默认：键盘输入，屏幕输出。 </span><br><span class="line">	 */</span><br><span class="line">	while (c = yylex())&#123;</span><br><span class="line">		writeout(c);</span><br><span class="line">		j++;</span><br><span class="line">		if (j%5 == 0) writeout(NEWLINE);</span><br><span class="line">	&#125;</span><br><span class="line">	if(argc&gt;=2)&#123;</span><br><span class="line">	  fclose(yyin);</span><br><span class="line">	  if (argc&gt;=3) fclose(yyout);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>exam2.l</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line">/* 把注释去掉 */</span><br><span class="line"></span><br><span class="line">%&#123;</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt; </span><br><span class="line">#define LT					1</span><br><span class="line">#define	LE					2</span><br><span class="line">#define GT					3</span><br><span class="line">#define	GE					4</span><br><span class="line">#define	EQ					5</span><br><span class="line">#define NE					6</span><br><span class="line">#define LLK                                     7</span><br><span class="line">#define RLK                                     8</span><br><span class="line">#define LBK                                     9</span><br><span class="line">#define RBK                                     10</span><br><span class="line">#define IF                               11</span><br><span class="line">#define ELSE                             12</span><br><span class="line">#define EQU                              13</span><br><span class="line">#define SEM                              14</span><br><span class="line"></span><br><span class="line">#define WHILE				18</span><br><span class="line">#define	DO					19</span><br><span class="line">#define ID          20</span><br><span class="line">#define NUMBER      21</span><br><span class="line">#define RELOP       22</span><br><span class="line"></span><br><span class="line">#define NEWLINE     23</span><br><span class="line">#define ERRORCHAR   24</span><br><span class="line">#define ADD                       25</span><br><span class="line">#define  DEC                         26</span><br><span class="line">#define  MUL                         27</span><br><span class="line">#define  DIV                        28</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">delim		[ \t \n]</span><br><span class="line">ws			&#123;delim&#125;+</span><br><span class="line">letter	[A-Za-z_]</span><br><span class="line">digit		[0-9]</span><br><span class="line">id			&#123;letter&#125;(&#123;letter&#125;|&#123;digit&#125;)*</span><br><span class="line">number	&#123;digit&#125;+(\.&#123;digit&#125;+)?(E[+-]?&#123;digit&#125;+)?</span><br><span class="line"></span><br><span class="line">/* 状态（或条件）定义可以定义在这里 </span><br><span class="line"> * INITIAL是一个默认的状态，不需要定义</span><br><span class="line"> */</span><br><span class="line">%s COMMENT</span><br><span class="line">%s COMMENT2</span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">&lt;INITIAL&gt;&quot;/*&quot;						&#123;BEGIN COMMENT;&#125;</span><br><span class="line">&lt;COMMENT&gt;&quot;*/&quot;						&#123;BEGIN INITIAL;&#125;</span><br><span class="line">&lt;COMMENT&gt;.|\n						&#123;;&#125;</span><br><span class="line">&lt;INITIAL&gt;&quot;//&quot;						&#123;BEGIN COMMENT2;&#125;</span><br><span class="line">&lt;COMMENT2&gt;\n					&#123;BEGIN INITIAL;&#125;</span><br><span class="line">&lt;COMMENT2&gt;.					&#123;;&#125;</span><br><span class="line"></span><br><span class="line"> /* ECHO是一个宏，相当于 fprintf(yyout, &quot;%s&quot;, yytext)*/</span><br><span class="line"></span><br><span class="line">&lt;INITIAL&gt;&#123;ws&#125;	          &#123;;&#125;</span><br><span class="line">&lt;INITIAL&gt;while					&#123;return (WHILE);&#125;</span><br><span class="line">&lt;INITIAL&gt;do		          &#123;return (DO);&#125;</span><br><span class="line">&lt;INITIAL&gt;if		          &#123;return (IF);&#125;</span><br><span class="line">&lt;INITIAL&gt;else		          &#123;return (ELSE);&#125;</span><br><span class="line">&lt;INITIAL&gt;&#123;id&#125;	          &#123;return (ID);&#125;</span><br><span class="line">&lt;INITIAL&gt;&#123;number&#125;	      &#123;return (NUMBER);&#125;</span><br><span class="line">&lt;INITIAL&gt;&quot;&lt;&quot;	          &#123;return (RELOP);&#125;</span><br><span class="line">&lt;INITIAL&gt;&quot;&lt;=&quot;	          &#123;return (RELOP);&#125;</span><br><span class="line">&lt;INITIAL&gt;&quot;=&quot;	          &#123;return (RELOP);&#125;</span><br><span class="line">&lt;INITIAL&gt;&quot;!=&quot;	          &#123;return (RELOP);&#125;</span><br><span class="line">&lt;INITIAL&gt;&quot;&gt;&quot;	          &#123;return (RELOP);&#125;</span><br><span class="line">&lt;INITIAL&gt;&quot;&gt;=&quot;	          &#123;return (RELOP);&#125;</span><br><span class="line">&lt;INITIAL&gt;&quot;(&quot;	          &#123;return (RELOP);&#125;</span><br><span class="line">&lt;INITIAL&gt;&quot;)&quot;	          &#123;return (RELOP);&#125;</span><br><span class="line">&lt;INITIAL&gt;&quot;&#123;&quot;	          &#123;return (RELOP);&#125;</span><br><span class="line">&lt;INITIAL&gt;&quot;&#125;&quot;	          &#123;return (RELOP);&#125;</span><br><span class="line">&lt;INITIAL&gt;&quot;+&quot;	          &#123;return (RELOP);&#125;</span><br><span class="line">&lt;INITIAL&gt;&quot;-&quot;	          &#123;return (RELOP);&#125;</span><br><span class="line">&lt;INITIAL&gt;&quot;*&quot;	          &#123;return (RELOP);&#125;</span><br><span class="line">&lt;INITIAL&gt;&quot;/&quot;	          &#123;return (RELOP);&#125;</span><br><span class="line">&lt;INITIAL&gt;&quot;;&quot;	          &#123;return (RELOP);&#125;</span><br><span class="line"></span><br><span class="line">&lt;INITIAL&gt;.							&#123;return ERRORCHAR;&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">int yywrap ()&#123;</span><br><span class="line">  return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void writeout(int c)&#123;</span><br><span class="line">  switch(c)&#123;</span><br><span class="line">  	case ERRORCHAR: fprintf(yyout, &quot;(ERRORCHAR, \&quot;%s\&quot;) &quot;, yytext);break;</span><br><span class="line">  	case RELOP: fprintf(yyout, &quot;(RELOP, \&quot;%s\&quot;) &quot;, yytext);break;  	  </span><br><span class="line">    case WHILE: fprintf(yyout, &quot;(WHILE, \&quot;%s\&quot;) &quot;, yytext);break;</span><br><span class="line">    case DO: fprintf(yyout, &quot;(DO, \&quot;%s\&quot;) &quot;, yytext);break;</span><br><span class="line">    case IF: fprintf(yyout, &quot;(IF, \&quot;%s\&quot;) &quot;, yytext);break;</span><br><span class="line">   case ELSE: fprintf(yyout, &quot;(ELSE, \&quot;%s\&quot;) &quot;, yytext);break;</span><br><span class="line">    case NUMBER: fprintf(yyout, &quot;(NUM, \&quot;%s\&quot;) &quot;, yytext);break;</span><br><span class="line">    case ID: fprintf(yyout, &quot;(ID, \&quot;%s\&quot;) &quot;, yytext);break;</span><br><span class="line">    case NEWLINE: fprintf(yyout, &quot;\n&quot;);break;</span><br><span class="line">    default:break;</span><br><span class="line">  &#125;</span><br><span class="line">  return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main (int argc, char ** argv)&#123;</span><br><span class="line">	int c,j=0;</span><br><span class="line">	if (argc&gt;=2)&#123;</span><br><span class="line">	  if ((yyin = fopen(argv[1], &quot;r&quot;)) == NULL)&#123;</span><br><span class="line">	    printf(&quot;Can&apos;t open file %s\n&quot;, argv[1]);</span><br><span class="line">	    return 1;</span><br><span class="line">	  &#125;</span><br><span class="line">	  if (argc&gt;=3)&#123;</span><br><span class="line">	    yyout=fopen(argv[2], &quot;w&quot;);</span><br><span class="line">	  &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	while (c = yylex())&#123;</span><br><span class="line">		writeout(c);</span><br><span class="line">		j++;</span><br><span class="line">		if (j%5 == 0) writeout(NEWLINE);</span><br><span class="line">	&#125;</span><br><span class="line">	if(argc&gt;=2)&#123;</span><br><span class="line">	  fclose(yyin);</span><br><span class="line">	  if (argc&gt;=3) fclose(yyout);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-编译Lex文件"><a href="#4-编译Lex文件" class="headerlink" title="4. 编译Lex文件"></a>4. 编译Lex文件</h3><p>先将<code>win_flex.exe</code>加入到环境变量，然后运行：</p>
<p><code>win_flex.exe --wincompat a.l　　　　　　// wincompat参数不能省</code></p>
<p>然后运行</p>
<p><code>g++ .\lex.yy.c</code></p>
<p>然后生成了一个a.exe，并运行</p>
<p><code>.\a.exe hello.cpp out.txt</code></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://woojoo520.github.io/2019/10/01/LeetCode-Day43/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mariana">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Celery Fairy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/01/LeetCode-Day43/" itemprop="url">LeetCode-Day43</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-01T09:31:44+08:00">
                2019-10-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="LeetCode-Day43——背包问题实战"><a href="#LeetCode-Day43——背包问题实战" class="headerlink" title="LeetCode-Day43——背包问题实战"></a>LeetCode-Day43——背包问题实战</h2><h3 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416. 分割等和子集"></a>416. 分割等和子集</h3><p>给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
<p>注意:</p>
<p>每个数组中的元素不会超过 100<br>数组的大小不会超过 200<br>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1, 5, 11, 5]</span><br><span class="line">输出: true</span><br><span class="line">解释: 数组可以分割成 [1, 5, 5] 和 [11].</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1, 2, 3, 5]</span><br><span class="line">输出: false</span><br><span class="line">解释: 数组不能分割成两个元素和相等的子集.</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>这就是一个01背包准确值的问题</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.size();i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">if</span>(sum % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> target = sum / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(target + <span class="number">1</span>, INT_MIN);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = target;i &gt;= num;i--) &#123;</span><br><span class="line">                dp[i] = max(dp[i], dp[i - num] + num);</span><br><span class="line">                dp[i] = dp[i] &lt; <span class="number">0</span> ? INT_MIN : dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[target] == target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="494-目标和"><a href="#494-目标和" class="headerlink" title="494. 目标和"></a>494. 目标和</h3><p>给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。</p>
<p>返回可以使最终数组和为目标数 S 的所有添加符号的方法数。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入: nums: [1, 1, 1, 1, 1], S: 3</span><br><span class="line">输出: 5</span><br><span class="line">解释: </span><br><span class="line"></span><br><span class="line">-1+1+1+1+1 = 3</span><br><span class="line">+1-1+1+1+1 = 3</span><br><span class="line">+1+1-1+1+1 = 3</span><br><span class="line">+1+1+1-1+1 = 3</span><br><span class="line">+1+1+1+1-1 = 3</span><br><span class="line"></span><br><span class="line">一共有5种方法让最终目标和为3。</span><br></pre></td></tr></table></figure>

<p>注意:</p>
<p>数组非空，且长度不会超过20。<br>初始的数组的和不会超过1000。<br>保证返回的最终结果能被32位整数存下。</p>
<p>思路：</p>
<p>这道题实际上就是01背包问题，假设取加号部分的和为<code>x</code>，取减号部分的和为<code>y</code>，则有</p>
<p><code>x + y = sum(nums)</code></p>
<p><code>x - y = S</code></p>
<p>则直接可以求解    <code>x = (sum + S) / 2</code></p>
<p>所以这道题本质上就是在问你，从这些数当中取出哪些数，可以让和为<code>x</code>，这样我们就将问题转换为01背包问题了</p>
<p>上Code：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;           </span><br><span class="line">        <span class="keyword">if</span>(sum &lt; S || (sum + S) % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> target = (sum + S) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; dp(target + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = target;i &gt;= num;i--) &#123;</span><br><span class="line">                dp[i] += dp[i - num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里需要注意一件事情，就是这里的<code>dp</code>数组表示的是方法的种数。</p>
<h3 id="474-一和零"><a href="#474-一和零" class="headerlink" title="474. 一和零"></a>474. 一和零</h3><p>在计算机界中，我们总是追求用有限的资源获取最大的收益。</p>
<p>现在，假设你分别支配着 m 个 0 和 n 个 1。另外，还有一个仅包含 0 和 1 字符串的数组。</p>
<p>你的任务是使用给定的 m 个 0 和 n 个 1 ，找到能拼出存在于数组中的字符串的最大数量。每个 0 和 1 至多被使用一次。</p>
<p>注意:</p>
<p>给定 0 和 1 的数量都不会超过 100。<br>给定字符串数组的长度不会超过 600。<br>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: Array = &#123;&quot;10&quot;, &quot;0001&quot;, &quot;111001&quot;, &quot;1&quot;, &quot;0&quot;&#125;, m = 5, n = 3</span><br><span class="line">输出: 4</span><br><span class="line">解释: 总共 4 个字符串可以通过 5 个 0 和 3 个 1 拼出，即 &quot;10&quot;,&quot;0001&quot;,&quot;1&quot;,&quot;0&quot; 。</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: Array = &#123;&quot;10&quot;, &quot;0&quot;, &quot;1&quot;&#125;, m = 1, n = 1</span><br><span class="line">输出: 2</span><br><span class="line">解释: 你可以拼出 &quot;10&quot;，但之后就没有剩余数字了。更好的选择是拼出 &quot;0&quot; 和 &quot;1&quot; 。</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>就把这个问题想象成有两个约束条件的多维背包问题，状态转换方程为：</p>
<p><code>f[i, u, v] = max(f[i - 1, u, v], f[u - 1][u - Di][v - Ci] + Wi)</code></p>
<p>然后优化空间和时间的方法，就是变成二维数组，加上倒着遍历！</p>
<p>上Code：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; countZO(<span class="built_in">string</span> str) &#123;</span><br><span class="line">        pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; ans(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : str) &#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">'0'</span>) &#123;</span><br><span class="line">                ans.first++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans.second++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaxForm</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">string</span> str : strs) &#123;</span><br><span class="line">            pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; zo = countZO(str);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = m;i &gt;= zo.first;i--) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = n;j &gt;= zo.second;j--) &#123;</span><br><span class="line">                    dp[i][j] = max(dp[i][j], dp[i - zo.first][j - zo.second] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://woojoo520.github.io/2019/10/01/Regular-expression/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mariana">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Celery Fairy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/01/Regular-expression/" itemprop="url">Regular expression</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-01T09:31:19+08:00">
                2019-10-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Regular-Expression——正则表达式"><a href="#Regular-Expression——正则表达式" class="headerlink" title="Regular Expression——正则表达式"></a>Regular Expression——正则表达式</h2><p>正则表达式描述了一种字符串匹配的模式，可以用来检查一个串是否含有某种子串，将匹配的子串替换或者从某个子串中取出某个符合条件的子串等</p>
<h3 id="普通字符"><a href="#普通字符" class="headerlink" title="普通字符"></a>普通字符</h3><p>普通字符包括没有显示指定为元字符的所有可打印和不可打印字符。这包括所有大写字母和小写字母，所有数字，所有标点符号和一些其他符号</p>
<h3 id="非打印字符"><a href="#非打印字符" class="headerlink" title="非打印字符"></a>非打印字符</h3><p>非打印字符也可以是正则表达式的组成部分。下标列出了表示非打印字符的转义序列</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>\cx</td>
<td>匹配由x指明的而控制字符。例如\cM控制一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的‘c’字符</td>
</tr>
<tr>
<td>\f</td>
<td>匹配一个换页符</td>
</tr>
<tr>
<td>\n</td>
<td>匹配一个换行符</td>
</tr>
<tr>
<td>\r</td>
<td>匹配一个回车符</td>
</tr>
<tr>
<td>\s</td>
<td>匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]。注意Unicode正则表达式会匹配全角空格符</td>
</tr>
<tr>
<td>\S</td>
<td>匹配任何非空白字符。等价于[^ \f\n\r\t\v ]</td>
</tr>
<tr>
<td>\t</td>
<td>匹配一个制表符</td>
</tr>
<tr>
<td>\v</td>
<td>匹配一个垂直制表符</td>
</tr>
</tbody></table>
<h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h3><p>许多元字符要求在试图匹配他们时特别对待。托要匹配他们，必须首先使字符“转义”，即，将反斜杠\放在他们前面。下标列出了正则表达式中的特殊字符</p>
<table>
<thead>
<tr>
<th>特殊字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>$</td>
<td>匹配输入字符串的结尾位置。如果设置了RegExp对象的Multiline属性，则 $ 也匹配‘\n’或‘\r’。要匹配\$本身需要使用 \ $</td>
</tr>
<tr>
<td>()</td>
<td>标记一个子表达式的开始和结束位置。字表达式可以获取供以后使用</td>
</tr>
<tr>
<td>*</td>
<td>匹配前面的子表达式零次或多次。</td>
</tr>
<tr>
<td>+</td>
<td>匹配前面的子表达式一次或多次。</td>
</tr>
<tr>
<td>.</td>
<td>匹配除换行符\n以外的任何单字符</td>
</tr>
<tr>
<td>[</td>
<td>标记一个中括号表达式的开始</td>
</tr>
<tr>
<td>?</td>
<td>匹配前面的子表达式零次或一次，或指明一个非贪婪限定符</td>
</tr>
<tr>
<td>\</td>
<td>将下一个字符标记为或特殊字符，或原义字符，或向后引用，或八进制转义符</td>
</tr>
<tr>
<td>^</td>
<td>匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。</td>
</tr>
<tr>
<td>{</td>
<td>标记限定符表达式的开始</td>
</tr>
<tr>
<td>|</td>
<td>指明两项之间的一个选择</td>
</tr>
</tbody></table>
<h3 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h3><p>限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有<code>*</code>或<code>+</code>或<code>?</code>或<code>{n}</code>或<code>{n,}</code>或<code>{n,m}</code>6种。</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>匹配前面的子表达式零次或多次</td>
</tr>
<tr>
<td>+</td>
<td>匹配前面的子表达式一次或多次</td>
</tr>
<tr>
<td>？</td>
<td>匹配前面的子表达式零次或一次</td>
</tr>
<tr>
<td>{n}</td>
<td>n是一个非负整数。匹配确定的n次。例如, ‘o{2}‘’不能匹配“Bob”中的‘o’,但是能匹配“food”中的两个o</td>
</tr>
<tr>
<td>{n,}</td>
<td>n是一个非负整数。至少匹配n次</td>
</tr>
<tr>
<td>{n,m}</td>
<td>m和n均为非负整数，其中n &lt;= m。最少匹配n次且最多匹配m次。<strong>注意在逗号和两个数之间不能有空格</strong></td>
</tr>
</tbody></table>
<p>注意：</p>
<p><strong>*、+限定符都是贪婪的，因为他们会尽可能多的匹配文字，只有在他们后面加上一个？就可以实现非贪婪或最小匹配。</strong></p>
<p>例如，当我们在搜索HTML文档，以查找括在H1标记内的章节标题。该文本在文档中如下：</p>
<p><code>&lt;H1&gt;Chapter 1 - 介绍正则表达式&lt;/H1&gt;</code></p>
<p><strong>贪婪</strong>：下面的表达式匹配从开始小于符号(&lt;)到关闭H1标记的大于符号(&gt;)之间的所有内容</p>
<p><code>/&lt;.*&gt;/</code></p>
<p><strong>非贪婪</strong>：如果您只需要匹配开始和结束H1标签，下面的非贪婪表达式只匹配 &lt;H1&gt;</p>
<p><code>/&lt;.*?&gt;/</code></p>
<p>如果指向匹配开始的H1标签，表达式则是：</p>
<p><code>/&lt;\w+?&gt;/</code></p>
<p>通过在* 、+ 或 ？限定符之后放置？，该表达式从“贪心”表达式转换为“非贪心”表达式或者最小匹配。</p>
<h3 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a>定位符</h3><p>定位符能够将正则表达式固定到行首或行尾。还能够创建这样的表达式：这些正则表达式出现在一个单词内、在一个单词的开头或者一个单词的结尾</p>
<p>定位符用来描述字符串或单词的边界，<code>^</code>和<code>$</code>分贝指字符串的开始与结束，<code>\b</code>描述单词的前或后边界，<code>\B</code>表示非单词边界</p>
<p>正则表达式的定位符有：</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>^</td>
<td>匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \n 或 \r 之后的位置匹配。</td>
</tr>
<tr>
<td>$</td>
<td>匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \n 或 \r 之后的位置匹配。</td>
</tr>
<tr>
<td>\b</td>
<td>匹配一个单词边界，即字与空格间的位置</td>
</tr>
<tr>
<td>\B</td>
<td>非单词边界匹配</td>
</tr>
</tbody></table>
<p><strong>注意：</strong></p>
<p>不能将限定符与定位符一起使用。而且在紧靠换行或者单词边界的前面或后面不能有一个以上位置，因此不允许注入<code>^*</code>之类的表达式</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://woojoo520.github.io/2019/09/30/LeetCode-Day42/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mariana">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Celery Fairy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/30/LeetCode-Day42/" itemprop="url">LeetCode-Day42</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-30T14:34:57+08:00">
                2019-09-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="背包问题的详解"><a href="#背包问题的详解" class="headerlink" title="背包问题的详解"></a>背包问题的详解</h2><h3 id="1-01背包问题"><a href="#1-01背包问题" class="headerlink" title="1. 01背包问题"></a>1. 01背包问题</h3><h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p>有N 件物品和一个容量为V 的背包。放入第<code>i</code>件物品耗费的费用是$C_i$，得到的价值是$W_i$。求解将哪些物品装入背包可使价值总和最大。</p>
<h4 id="基本思路："><a href="#基本思路：" class="headerlink" title="基本思路："></a>基本思路：</h4><p>这是最基础的背包问题，特点是：每种物品仅有一件，可以选择放或者不放</p>
<p>用子问题定义状态，即<code>f[i,v]</code>表示前<code>i</code>间物品恰放入一个容量为<code>v</code>的背包可以获得的最大值。则其状态转移方程便是$f[i,v] = max(F[i - 1,v], F[i - 1, v - C_i] + W_i)$</p>
<h4 id="伪代码如下："><a href="#伪代码如下：" class="headerlink" title="伪代码如下："></a>伪代码如下：</h4><p><img src="C:%5CUsers%5C12751%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1569847212976.png" alt="1569847212976"></p>
<h4 id="优化空间复杂度："><a href="#优化空间复杂度：" class="headerlink" title="优化空间复杂度："></a>优化空间复杂度：</h4><p>以上方法的时间和空间复杂度均为$O(VN)$，其中时间复杂度已经不能再优化了，但是空间复杂度却可以优化到$O(V)$</p>
<p>我们可以将代码写成下面这种形式：</p>
<p><img src="C:%5CUsers%5C12751%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1569847314337.png" alt="1569847314337"></p>
<p>首先，这里本来是个二维数组，但是由于我们每次更新当前行的时候，只用到了前一行的数据，因此可以变成一个一维数组。</p>
<p>这里注意到：$v \leftarrow V \text { to } C_{i}$</p>
<p>为什么要这样写呢？</p>
<p>因为当我们变成一维数组的时候，在进行状态更新的时候，当前的状态依赖于前面的状态，如图：</p>
<p>![img](file:///C:\Users\12751\Documents\Tencent Files\1275121799\Image\C2C{5ABE66EB-46E4-094C-B286-7156B3D63719}.png)</p>
<p>更新完之后，还得写回当前的位置，为了不影响后面的操作，所以这里需要倒过来写</p>
<h4 id="初始化的细节问题："><a href="#初始化的细节问题：" class="headerlink" title="初始化的细节问题："></a>初始化的细节问题：</h4><p>我们看到的求最优解的背包问题题目中，事实上有两种不太相同的问法。有的题目要求“恰好装满背包”时的最优解，有的题目则并没有要求必须把背包装满。一种区别这两种问法的实现方法是在初始化的时候有所不同。</p>
<p>如果是第一种问法，要求恰好装满背包，那么在初始化时除了<code>f[0] = 0</code>，其他<code>F[1...V]</code>均设为$-\infty$。这样就能保证最终得到的<code>f[V]</code>是一种恰好装满背包的最优解。</p>
<p>如果并没有要求必须把背包装满，而是只希望价格尽量大，初始化时应将<code>F[0...V]</code>全部设为0</p>
<p>为什么呢？可以这样理解：初始化的<code>F</code>数组事实上就是在没有任何物品可以放入背包时的合法状态。如果要求背包恰好装满，那么此时只有容量为0的背包可以在什么也不装且价值为0的情况下被“恰好装满”，其他容量的背包均没有合法的解，属于未定义的状态，应该就被赋值为$-\infty$。如果背包并非必须被装满，那么任何容量的背包都有一个合法解“什么都不装”，这个解的价值为0，所以初始时状态的值也就是全部为0了</p>
<h3 id="2-完全背包问题"><a href="#2-完全背包问题" class="headerlink" title="2. 完全背包问题"></a>2. 完全背包问题</h3><h4 id="题目：-1"><a href="#题目：-1" class="headerlink" title="题目："></a>题目：</h4><p>有$N$ 种物品和一个容量为$V $的背包，每种物品都有无限件可用。放入第i 种物品的费用是$C_i$，价值是$W_i$。求解：将哪些物品装入背包，可使这些物品的耗费的费用总和不超过背包容量，且价值总和最大。</p>
<h4 id="常规思路："><a href="#常规思路：" class="headerlink" title="常规思路："></a>常规思路：</h4><p>常规思路应该写出这样的表达式：</p>
<p>$F[i, v] = max(F[i - 1,v - k * (C_i)] + kW_i), 0 \le kC_i \le v$</p>
<h4 id="一个简单有效的优化："><a href="#一个简单有效的优化：" class="headerlink" title="一个简单有效的优化："></a>一个简单有效的优化：</h4><p>完全背包问题有一个很简单有效的优化，是这样的：若两件物品$i$、$j$ 满足 $C_i \le C_j$，且$W_i \ge W_j$，则可以直接将物品<code>j</code>去掉，不用考虑。这个优化的正确性是显然的：任何情况下都可以将价值小费用高的<code>j</code>换成物美价廉的<code>i</code>，得到的方案至少不会更差。</p>
<h4 id="O-VN-的算法："><a href="#O-VN-的算法：" class="headerlink" title="$O(VN)$的算法："></a>$O(VN)$的算法：</h4><p>伪代码：</p>
<p><img src="C:%5CUsers%5C12751%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1569849873174.png" alt="1569849873174"></p>
<p>你会发现，这个伪代码与01背包的伪代码只有v的循环次序不同而已。 </p>
<p>为什么这个方法可行呢？我们先来看看原来为什么需要逆序？</p>
<p>![img](file:///C:\Users\12751\Documents\Tencent Files\1275121799\Image\C2C{5ABE66EB-46E4-094C-B286-7156B3D63719}.png)</p>
<p>因为我们怕改变当前的值会影响到后面，但是现在我们恰恰需要这种影响，因为这个时候，我们的物品不止一件了，可以无限的放进背包，而且这种影响可以表示为：我在已经放入<code>k</code>个<code>i</code>物品之后，在放入一件<code>i</code>物品不会不会使得我的价值更大呢？</p>
<h3 id="3-多重背包问题"><a href="#3-多重背包问题" class="headerlink" title="3. 多重背包问题"></a>3. 多重背包问题</h3><h4 id="题目：-2"><a href="#题目：-2" class="headerlink" title="题目："></a>题目：</h4><p>有N 种物品和一个容量为$V$ 的背包。第$i$ 种物品最多有$M_i$ 件可用，每件耗费的空间是$C_i$，价值是$W_i$。求解将哪些物品装入背包可使这些物品的耗费的空间总和不超过背包容量，且价值总和最大。</p>
<h4 id="基本算法："><a href="#基本算法：" class="headerlink" title="基本算法："></a>基本算法：</h4><p>$F[i, v] = max(F[i - 1,v - k * (C_i)] + kW_i), 0 \le k \le M_i$</p>
<h4 id="转换为01背包问题："><a href="#转换为01背包问题：" class="headerlink" title="转换为01背包问题："></a>转换为01背包问题：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">k &lt;- <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span>(k &lt; M) </span><br><span class="line">	ZeroOnePack(kC, kW)</span><br><span class="line">	M &lt;- M - k</span><br><span class="line">	k &lt;- <span class="number">2</span>k</span><br><span class="line">ZeroOnePack(CM, WM)</span><br></pre></td></tr></table></figure>

<h3 id="377-组合总和IV"><a href="#377-组合总和IV" class="headerlink" title="377. 组合总和IV"></a>377. 组合总和IV</h3><p>给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">nums = [1, 2, 3]</span><br><span class="line">target = 4</span><br><span class="line">所有可能的组合为：</span><br><span class="line">(1, 1, 1, 1)</span><br><span class="line">(1, 1, 2)</span><br><span class="line">(1, 2, 1)</span><br><span class="line">(1, 3)</span><br><span class="line">(2, 1, 1)</span><br><span class="line">(2, 2)</span><br><span class="line">(3, 1)</span><br><span class="line">请注意，顺序不同的序列被视作不同的组合。</span><br><span class="line">因此输出为 7。</span><br></pre></td></tr></table></figure>

<p>思路：实际上就是一个完全背包的问题</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> dp[target + <span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= target;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i &gt;= num) &#123;</span><br><span class="line">                    dp[i] = dp[i] &gt;= INT_MAX - dp[i - num] ? <span class="number">0</span> : dp[i] + dp[i - num];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里需要注意有可能会出现<code>int</code>范围爆炸的问题。所以需要提前判断一下！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://woojoo520.github.io/2019/09/27/LeetCode-Day41/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mariana">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Celery Fairy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/27/LeetCode-Day41/" itemprop="url">LeetCode-Day41</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-27T10:01:32+08:00">
                2019-09-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="172-阶乘后的零"><a href="#172-阶乘后的零" class="headerlink" title="172. 阶乘后的零"></a>172. 阶乘后的零</h3><p>给定一个整数 n，返回 n! 结果尾数中零的数量。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: 0</span><br><span class="line">解释: 3! = 6, 尾数中没有零。</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 5</span><br><span class="line">输出: 1</span><br><span class="line">解释: 5! = 120, 尾数中有 1 个零.</span><br></pre></td></tr></table></figure>

<p>思路：能产生0的情况只有<code>5 * 2 = 10</code>，其他情况分解后也是这个，2的数目要远多于5，所以问题就转变为求5的个数</p>
<p>比如<code>25! = 1 * 2 * 3 * ... * 24 * 25</code></p>
<ul>
<li>去掉无法产生0的，<code>5 * 10 * 15 * 20 * 25</code></li>
<li>再分解，<code>1*5 * 2*5 * 3*5 * 4*5 * 5*5</code></li>
<li>那些5的倍数的都能构造出<code>2*5</code>，而25有两层5</li>
<li>所以只要<code>n /= 5</code>就能得到第一层的5的个数，剩下<code>1 * 2 * 3 * 4 * 5</code></li>
<li>上面的结果再除以5就是下一层的5的个数</li>
<li>最终<code>5 + 1 = 6</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt;= <span class="number">5</span>) &#123;</span><br><span class="line">            n /= <span class="number">5</span>;</span><br><span class="line">            ans += n;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> ans;     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="179-最大数"><a href="#179-最大数" class="headerlink" title="179. 最大数"></a>179. 最大数</h3><p>给定一组非负整数，重新排列它们的顺序使之组成一个最大的整数。</p>
<p>示例 1:</p>
<p>输入: [10,2]<br>输出: 210<br>示例 2:</p>
<p>输入: [3,30,34,5,9]<br>输出: 9534330<br>说明: 输出结果可能非常大，所以你需要返回一个字符串而不是整数。</p>
<p>思路：</p>
<p>其实想了好久才突然明白一件事情…</p>
<p>就是在作为排序条件的时候，如何判断<code>a &gt; b</code></p>
<p>一开始一直在想长度不相等的话怎么办，后来才发现自己的判断依据其实一直是<code>a + b 是否大于 b + a</code>(这里的相加指的是字符串的相加)</p>
<p>所以判断依据就是上面这个，然后排个序穿起来就行了，但是要注意全零的情况，此时只需要返回0</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">largestNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(index &lt; nums.size()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[index] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(index == nums.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(nums.begin(), nums.end(), [](<span class="keyword">int</span>&amp; a, <span class="keyword">int</span>&amp; b) &#123;</span><br><span class="line">            <span class="built_in">string</span> stra = to_string(a), strb = to_string(b);</span><br><span class="line">            <span class="built_in">string</span> str1 = stra + strb, str2 = strb + stra;</span><br><span class="line">            <span class="keyword">return</span> str1 &gt; str2;  </span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            res += to_string(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="130-被围绕的区域"><a href="#130-被围绕的区域" class="headerlink" title="130. 被围绕的区域"></a>130. 被围绕的区域</h3><p>给定一个二维的矩阵，包含 ‘X’ 和 ‘O’（字母 O）。</p>
<p>找到所有被 ‘X’ 围绕的区域，并将这些区域里所有的 ‘O’ 用 ‘X’ 填充。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">X X X X</span><br><span class="line">X O O X</span><br><span class="line">X X O X</span><br><span class="line">X O X X</span><br><span class="line">运行你的函数后，矩阵变为：</span><br><span class="line"></span><br><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X O X X</span><br><span class="line">解释:</span><br><span class="line"></span><br><span class="line">被围绕的区间不会存在于边界上，换句话说，任何边界上的 &apos;O&apos; 都不会被填充为 &apos;X&apos;。 任何不在边界上，或不与边界上的 &apos;O&apos; 相连的 &apos;O&apos; 最终都会被填充为 &apos;X&apos;。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。</span><br></pre></td></tr></table></figure>

<p>思路：这个问题很容易就能想到DFS，所以照着思路写代码就可以了</p>
<p><strong>简单总结dfs和bfs：</strong></p>
<ul>
<li><code>bfs:递归。可以想象二叉树中如何递归进行层序遍历</code></li>
<li><code>bfs:非递归，一般用队列存储</code></li>
<li><code>dfs:递归，最常用，如二叉树的先序遍历</code></li>
<li><code>dfs:非递归，一般用stack</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = board.size(), n = board[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j++) &#123;</span><br><span class="line">                <span class="comment">// 从边缘第一个是O开始搜索</span></span><br><span class="line">                <span class="keyword">bool</span> isEdge = (i == <span class="number">0</span> || i == m - <span class="number">1</span> || j == <span class="number">0</span> || j == n - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(isEdge &amp;&amp; board[i][j] == <span class="string">'O'</span>) &#123;</span><br><span class="line">                    dfs(board, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">'O'</span>) &#123;</span><br><span class="line">                    board[i][j] = <span class="string">'X'</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(board[i][j] == <span class="string">'#'</span>) &#123;</span><br><span class="line">                    board[i][j] = <span class="string">'O'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = board.size(), n = board[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">stack</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; st;</span><br><span class="line">        st.push(&#123;i, j&#125;);</span><br><span class="line">        board[i][j] = <span class="string">'#'</span>;</span><br><span class="line">        <span class="keyword">while</span>(!st.empty()) &#123;</span><br><span class="line">            pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; current = st.top();</span><br><span class="line">            <span class="keyword">if</span>(current.first &gt;= <span class="number">1</span> &amp;&amp; board[current.first - <span class="number">1</span>][current.second] == <span class="string">'O'</span>) &#123;</span><br><span class="line">                st.push(&#123;current.first - <span class="number">1</span>, current.second&#125;);</span><br><span class="line">                board[current.first - <span class="number">1</span>][current.second] = <span class="string">'#'</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span>(current.first + <span class="number">1</span> &lt; m &amp;&amp; board[current.first + <span class="number">1</span>][current.second] == <span class="string">'O'</span>) &#123;</span><br><span class="line">                st.push(&#123;current.first + <span class="number">1</span>, current.second&#125;);</span><br><span class="line">                board[current.first + <span class="number">1</span>][current.second] = <span class="string">'#'</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span>(current.second &gt;= <span class="number">1</span> &amp;&amp; board[current.first][current.second - <span class="number">1</span>] == <span class="string">'O'</span>) &#123;</span><br><span class="line">                st.push(&#123;current.first, current.second - <span class="number">1</span>&#125;);</span><br><span class="line">                board[current.first][current.second - <span class="number">1</span>] = <span class="string">'#'</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span>(current.second + <span class="number">1</span> &lt; n &amp;&amp; board[current.first][current.second + <span class="number">1</span>] == <span class="string">'O'</span>) &#123;</span><br><span class="line">                st.push(&#123;current.first, current.second + <span class="number">1</span>&#125;);</span><br><span class="line">                board[current.first][current.second + <span class="number">1</span>] = <span class="string">'#'</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            st.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a>200. 岛屿数量</h3><p>给定一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">11110</span><br><span class="line">11010</span><br><span class="line">11000</span><br><span class="line">00000</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">11000</span><br><span class="line">11000</span><br><span class="line">00100</span><br><span class="line">00011</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure>

<p>思路：与上一题很类似</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(grid.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = grid.size(), n = grid[<span class="number">0</span>].size();</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                DFS(grid, i, j);</span><br><span class="line">                sum += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = grid.size(), n = grid[<span class="number">0</span>].size();</span><br><span class="line">    <span class="built_in">stack</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; st;</span><br><span class="line">    st.push(&#123;i, j&#125;);</span><br><span class="line">    grid[i][j] = <span class="string">'#'</span>;</span><br><span class="line">    <span class="keyword">while</span>(!st.empty()) &#123;</span><br><span class="line">        pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; current = st.top();</span><br><span class="line">        <span class="keyword">if</span>(current.first &gt;= <span class="number">1</span> &amp;&amp; grid[current.first - <span class="number">1</span>][current.second] == <span class="string">'1'</span>) &#123;</span><br><span class="line">            st.push(&#123;current.first - <span class="number">1</span>, current.second&#125;);</span><br><span class="line">            grid[current.first - <span class="number">1</span>][current.second] = <span class="string">'#'</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(current.first + <span class="number">1</span> &lt; m &amp;&amp; grid[current.first + <span class="number">1</span>][current.second] == <span class="string">'1'</span>) &#123;</span><br><span class="line">            st.push(&#123;current.first + <span class="number">1</span>, current.second&#125;);</span><br><span class="line">            grid[current.first + <span class="number">1</span>][current.second] = <span class="string">'#'</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(current.second &gt;= <span class="number">1</span> &amp;&amp; grid[current.first][current.second - <span class="number">1</span>] == <span class="string">'1'</span>) &#123;</span><br><span class="line">            st.push(&#123;current.first, current.second - <span class="number">1</span>&#125;);</span><br><span class="line">            grid[current.first][current.second - <span class="number">1</span>] = <span class="string">'#'</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(current.second + <span class="number">1</span> &lt; n &amp;&amp; grid[current.first][current.second + <span class="number">1</span>] == <span class="string">'1'</span>) &#123;</span><br><span class="line">            st.push(&#123;current.first, current.second + <span class="number">1</span>&#125;);</span><br><span class="line">            grid[current.first][current.second + <span class="number">1</span>] = <span class="string">'#'</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        st.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://woojoo520.github.io/2019/09/25/cGAN/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mariana">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Celery Fairy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/25/cGAN/" itemprop="url">cGAN</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-25T21:17:11+08:00">
                2019-09-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="cGAN"><a href="#cGAN" class="headerlink" title="cGAN"></a>cGAN</h2><h3 id="为什么要有cGAN？"><a href="#为什么要有cGAN？" class="headerlink" title="为什么要有cGAN？"></a>为什么要有cGAN？</h3><p>首先，GAN虽然厉害，但有个问题，其生成模型生成的样本完全是随机的，也就是完全取决于输入的噪声z，根本无法预测会生成数字1还是数字2.因此偶人提出了条件GAN，其思想也很简单，就是想要生成哪个数字，你输入的时候告诉我你想要的标签即可。为了达到这个目标，在训练的时候，就要加上标签。也就是G想要伪造数字1，就要在原本的z向量后面加十维的one-hot向量，在D那里也是，要判别什么，也要在尾部加上十维的one-hot向量</p>
<p><img src="https://pic4.zhimg.com/v2-b112245a817b2e813a65cdb3fe4620eb_b.jpg" alt="img"></p>
<p>以上图为例，如果迷行的输入是文字，输出是图片，使用传统的做法会产生模糊的问题。比如输入火车，希望得到一张火车的图片，可是火车有侧面，有不同的形态，如果不加约束，则可能产生一张包含各种样式的火车的平均（模糊）图。</p>
<p>​    GAN的机制是只要识别器能分辨得出一张图是人工生成的还是原图就行，所以不能确保输入火车就回生成火车图片，比如输入火车生成一张很逼真的猫图，生成器也会被认为是一个成功的生成器（GAN容易钻空子，即如果某种特定形式可以骗过生成器，生成器会倾向于生成这种模式）</p>
<p>生成器输出一张图片，然后将同样的语句（条件）和生成的图片一起输入识别器，关键是，识别器不仅需要分辨真假，还需要分辨出语句（条件）和图片是否匹配。总的来说有三种情况：</p>
<p>原图 + 图和条件匹配   —-&gt;     高分</p>
<p>原图 + 图和条件不匹配   —-&gt;     低分</p>
<p>人工图      —-&gt;     低分</p>
<p><img src="https://pic1.zhimg.com/v2-ec6da03ab4ea2b7eb4cb7b32bb81b428_b.jpg" alt="img"></p>
<p>通过这样的操作，可以确保输出样本和条件是匹配的</p>
<p>CGAN有两种比较常用的结构：</p>
<p><img src="https://pic4.zhimg.com/v2-2e71198971ecf978048df60d6862dfef_b.jpg" alt="img"></p>
<p>这两种结构的主要区别在生成器的输出部分，下面的可能更加合理：</p>
<p>下半部分的结构中生成器的输出分为两部分：</p>
<ul>
<li>是否是真实图片</li>
<li>输出与条件是否匹配</li>
</ul>
<p>这样做的好处是，直观上说，模型能分别知道两个任务的性能，更有针对性地提高模型能力，如果输出的图像不够真实，但是能比较好地是辈出是否匹配，则主要调节生成样本的分支，而第一种结构由于是混合在一起的，就没有这种针对性调节的能力。</p>
<p>值得一提的是，论文里的识别器使用了Patch的方法，即先将输出样本划分为若干个Patch，然后对每个Patch进行评分，最后将所有patch的得分平均作为最后得分。这样做的好处是，识别器能更加关注到生成图像的细节部分，即对高频的部分更加敏感，当然，最极端是每一个像素就是一个patch，这样的话识别器会失去大局观，即失去不同部分空间部分之间的相关信息</p>
<p><img src="https://pic3.zhimg.com/v2-e99cc2059b659feab28652048fda92ba_b.jpg" alt="img"></p>
<p>一些用到的函数的详解：</p>
<p><code>torch.nn.Embedding(num_embeddings, emcedding_dim, padding_idx = None, max_norm = None, norm_type = 2, scale_grad_by_freq = False, sparse = False)</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Pytorch官网的解释是：一个保存了固定字典的带下和简单查找表。这个模块常用来保存字典嵌入和用下标检索它们。模块的输入是一个下标的列表，输出是对应的词嵌入</span></span><br><span class="line"><span class="comment"># 个人理解：这是一个矩阵类，里面初始化了一个随机矩阵，矩阵的长是字典的大小，宽是用来表示字典中每个元素的属性向量，向量的维度根据你想要的元素的复杂度而定。类实例化之后可以根据字典中元素的下标来查找元素对应的向量。例如输入下标0， 输出就是embeds矩阵中的第0行</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> torch</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>label = nn.Embedding(<span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>label(Variable(torch.LongTensor([<span class="number">4</span>])))</span><br><span class="line">tensor([[<span class="number">-0.6134</span>,  <span class="number">0.0528</span>,  <span class="number">2.4490</span>, <span class="number">-0.0294</span>,  <span class="number">1.2371</span>,  <span class="number">0.5792</span>, <span class="number">-1.2843</span>,  <span class="number">0.6881</span>,</span><br><span class="line">         <span class="number">-0.9275</span>,  <span class="number">1.2503</span>]], grad_fn=&lt;EmbeddingBackward&gt;)</span><br></pre></td></tr></table></figure>

<p><code>nn.prod()</code>        连乘函数</p>
<p><code>torch.cat()</code>    连接函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = torch.randn(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = torch.randn(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">tensor([[ <span class="number">2.2045</span>,  <span class="number">1.0283</span>,  <span class="number">0.7637</span>],</span><br><span class="line">        [ <span class="number">0.8578</span>, <span class="number">-0.8376</span>, <span class="number">-0.3780</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y</span><br><span class="line">tensor([[<span class="number">-0.5941</span>, <span class="number">-0.8588</span>,  <span class="number">0.9540</span>],</span><br><span class="line">        [<span class="number">-1.1115</span>,  <span class="number">0.3655</span>,  <span class="number">0.2471</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.cat((x, y), <span class="number">0</span>)</span><br><span class="line">tensor([[ <span class="number">2.2045</span>,  <span class="number">1.0283</span>,  <span class="number">0.7637</span>],</span><br><span class="line">        [ <span class="number">0.8578</span>, <span class="number">-0.8376</span>, <span class="number">-0.3780</span>],</span><br><span class="line">        [<span class="number">-0.5941</span>, <span class="number">-0.8588</span>,  <span class="number">0.9540</span>],</span><br><span class="line">        [<span class="number">-1.1115</span>,  <span class="number">0.3655</span>,  <span class="number">0.2471</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.cat((x, y), <span class="number">1</span>)</span><br><span class="line">tensor([[ <span class="number">2.2045</span>,  <span class="number">1.0283</span>,  <span class="number">0.7637</span>, <span class="number">-0.5941</span>, <span class="number">-0.8588</span>,  <span class="number">0.9540</span>],</span><br><span class="line">        [ <span class="number">0.8578</span>, <span class="number">-0.8376</span>, <span class="number">-0.3780</span>, <span class="number">-1.1115</span>,  <span class="number">0.3655</span>,  <span class="number">0.2471</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.cat((x, y), <span class="number">-1</span>)</span><br><span class="line">tensor([[ <span class="number">2.2045</span>,  <span class="number">1.0283</span>,  <span class="number">0.7637</span>, <span class="number">-0.5941</span>, <span class="number">-0.8588</span>,  <span class="number">0.9540</span>],</span><br><span class="line">        [ <span class="number">0.8578</span>, <span class="number">-0.8376</span>, <span class="number">-0.3780</span>, <span class="number">-1.1115</span>,  <span class="number">0.3655</span>,  <span class="number">0.2471</span>]])</span><br><span class="line"><span class="comment"># torch.cat((), 0)	竖着连接</span></span><br><span class="line"><span class="comment"># torch.cat((), 1 or -1)	横着连接</span></span><br></pre></td></tr></table></figure>

<p><code>numpy.random.randint(low, high, size)</code></p>
<p>low、high、size三个参数。默认high是None，如果只有low，那范围就是<code>[0, low)</code>。如果有high，范围就是<code>[low, high)</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.random.randint(<span class="number">5</span>, <span class="number">16</span>, <span class="number">64</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([<span class="number">13</span>, <span class="number">14</span>, <span class="number">12</span>, <span class="number">15</span>,  <span class="number">8</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">11</span>, <span class="number">11</span>, <span class="number">10</span>, <span class="number">14</span>, <span class="number">15</span>,  <span class="number">8</span>, <span class="number">15</span>,  <span class="number">5</span>, <span class="number">12</span>,  <span class="number">6</span>,</span><br><span class="line">       <span class="number">15</span>,  <span class="number">9</span>,  <span class="number">5</span>,  <span class="number">5</span>, <span class="number">13</span>, <span class="number">13</span>,  <span class="number">8</span>, <span class="number">15</span>, <span class="number">10</span>, <span class="number">11</span>,  <span class="number">6</span>,  <span class="number">8</span>, <span class="number">15</span>,  <span class="number">9</span>,  <span class="number">9</span>,  <span class="number">9</span>,  <span class="number">5</span>,</span><br><span class="line">       <span class="number">13</span>, <span class="number">12</span>, <span class="number">12</span>,  <span class="number">8</span>,  <span class="number">5</span>, <span class="number">14</span>,  <span class="number">7</span>, <span class="number">15</span>, <span class="number">11</span>,  <span class="number">6</span>,  <span class="number">7</span>, <span class="number">12</span>, <span class="number">10</span>,  <span class="number">8</span>, <span class="number">10</span>,  <span class="number">5</span>, <span class="number">13</span>,</span><br><span class="line">        <span class="number">9</span>, <span class="number">14</span>,  <span class="number">8</span>,  <span class="number">7</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">6</span>,  <span class="number">6</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">15</span>, <span class="number">14</span>, <span class="number">10</span>])</span><br></pre></td></tr></table></figure>

<p><code>np.random.normal(loc=0.0, scale=1.0, siez=None)</code></p>
<p>loc：float，此概率分布的均值（对应整个分布的重心center）</p>
<p>scale：float，此概率分布的标准差（对应于分布的宽度，scale越大越矮胖。scale越小，越瘦高）</p>
<p>size：int or tuple of ints</p>
<p>输出的shape，默认为None， 值输出一个值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.random.normal(<span class="number">5</span>, <span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line"><span class="number">4.687275350809846</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.random.normal(<span class="number">5</span>, <span class="number">1</span>, [<span class="number">2</span>, <span class="number">2</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([[<span class="number">5.18009118</span>, <span class="number">4.91448971</span>],</span><br><span class="line">       [<span class="number">6.2771917</span> , <span class="number">5.15529855</span>]])</span><br></pre></td></tr></table></figure>

<p>$IS(G) = exp(E_{x \sim p_g}D_{KL}(p(y|x)||p(y)))$</p>
<p>$D(p||q) = \sum p(x) log \frac{p(x)} {q(x)} $</p>
<p>$FID = ||u_r - u_g||^2 + T_r(\sum_r + \sum_g - 2(\sum_r - \sum_g)^{\frac{1} {2}})$</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://woojoo520.github.io/2019/09/25/交叉熵/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mariana">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Celery Fairy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/25/交叉熵/" itemprop="url">交叉熵</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-25T15:20:30+08:00">
                2019-09-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="关于交叉熵在loss函数中使用的理解"><a href="#关于交叉熵在loss函数中使用的理解" class="headerlink" title="关于交叉熵在loss函数中使用的理解"></a>关于交叉熵在loss函数中使用的理解</h2><h3 id="信息论"><a href="#信息论" class="headerlink" title="信息论"></a>信息论</h3><p>交叉熵是信息论中的一个概念，想要了解交叉熵的本质，需要从最基本的概念讲起。</p>
<h3 id="1-信息量"><a href="#1-信息量" class="headerlink" title="1. 信息量"></a>1. 信息量</h3><p>首先是信息量。假设我们听到了两件事，分别如下：<br>事件A：巴西队进入了2018世界杯决赛圈。<br>事件B：中国队进入了2018世界杯决赛圈。<br>仅凭直觉来说，显而易见事件B的信息量比事件A的信息量要大。究其原因，是因为事件A发生的概率很大，事件B发生的概率很小。所以当越不可能的事件发生了，我们获取到的信息量就越大。越可能发生的事件发生了，我们获取到的信息量就越小。那么信息量应该和事件发生的概率有关。</p>
<p>假设$X$是一个离散型随机变量，其取值集合为$χ$,概率分布函数$p(x)=Pr(X=x),x∈χ$,则定义事件$X=x_0$的信息量为：</p>
<p>$I(x_0) = -log(p(x_0))$</p>
<p>由于是概率所以$p(x_0)$的取值范围是[0, 1],绘制为图形如下：</p>
<p><img src="https://img-blog.csdn.net/20180125164333234?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdHN5Y2NuaA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="è¿éåå¾çæè¿°"></p>
<h3 id="2-熵"><a href="#2-熵" class="headerlink" title="2. 熵"></a>2. 熵</h3><p>考虑另一个问题，对于某个事件，有nn种可能性，每一种可能性都有一个概率$p(xi)$这样就可以计算出某一种可能性的信息量。举一个例子，假设你拿出了你的电脑，按下开关，会有三种可能性，下表列出了每一种可能的概率及其对应的信息量</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>事件</th>
<th>概率p</th>
<th>信息量I</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>电脑正常开机</td>
<td>0.7</td>
<td>-log(p(A))=0.36</td>
</tr>
<tr>
<td>B</td>
<td>电脑无法开机</td>
<td>0.2</td>
<td>-log(p(B))=1.61</td>
</tr>
<tr>
<td>C</td>
<td>电脑爆炸了</td>
<td>0.1</td>
<td>-log(p(C))=2.30</td>
</tr>
</tbody></table>
<p><code>注：文中的对数均为自然对数</code></p>
<p>我们现在有了信息量的定义，而熵用来表示所有信息量的期望，即：</p>
<p>$H(X) = -\sum_{i = 1}^{n}{p(x_i)log(p(x_i))}$</p>
<p>其中n代表所有的n种可能性，所以上面的问题的结果就是</p>
<p>$H(X) = -[p(A)log(p(A)) + p(B)log(p(B)) + p(C)log(p(C))] = 0.7\times0.36 + 0.2 \times 1.61 + 0.1 \times * 2.30 = 0.804$</p>
<p>然而，有一类比较太特殊的问题，比如，投掷硬币只有两种可能，字朝上或花朝上。买彩票只有两种可能，中奖或不中奖。我们称之为0-1分布（二项分布的特例），对于这类问题，熵的计算方法可以简化为如下算式：</p>
<p>$H(X) = -\sum_{i = 1}^{n} p(x_i)log(p(x_i)) = -p(x)log(p(x)) - (1 - p(x))log(1-p(x))$</p>
<h3 id="3-相对熵"><a href="#3-相对熵" class="headerlink" title="3. 相对熵"></a>3. 相对熵</h3><p>相对熵又称<strong>KL散度</strong>，如果我们对于同一个随机变量x有两个单独的概率分布P(x)或Q(x)，我们可以使用KL散度来衡量这两个分布的差异。</p>
<p>即如果用P来描述目标问题，而不是用Q来描述目标问题，得到的信息增量。</p>
<p>在机器学习中，P往往用来表示样本的真实分布，比如[1,0,0]表示当前样本属于第一类。Q用来表示模型所预测的分布，比如[0.7,0.2,0.1]<br>直观的理解就是如果用P来描述样本，那么就非常完美。而用Q来描述样本，虽然可以大致描述，但是不是那么的完美，信息量不足，需要额外的一些“信息增量”才能达到和P一样完美的描述。如果我们的Q通过反复训练，也能完美的描述样本，那么就不再需要额外的“信息增量”，Q等价于P。</p>
<p>KL散度的计算公式：</p>
<p><img src="C:%5CUsers%5C12751%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1569397275231.png" alt="1569397275231"></p>
<p>n为事件的所有可能性。</p>
<p>$D_{KL}$的值越小，表示q分布和p分布越接近</p>
<h3 id="4-交叉熵"><a href="#4-交叉熵" class="headerlink" title="4. 交叉熵"></a>4. 交叉熵</h3><p>对于KL散度的公式进行变形可以得到：</p>
<p><img src="C:%5CUsers%5C12751%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1569397402578.png" alt="1569397402578"></p>
<p>等式的前一部分恰巧就是p的熵，等式的后一部分，就是交叉熵</p>
<p>$H(p, q) = -\sum_{i = 1}^n p(x_i)log(q(x_i))$</p>
<p>在机器学习中，我们需要评估<code>label</code>和<code>predicts</code>之间的差距，使用KL散度刚刚好，即$D_{KL}(y||\hat y)$，由于KL散度中的前一部分$-H(y)$不变，故在优化过程中，只需要关注交叉熵就可以了。所以，一般在机器学习中直接使用交叉熵做loss，评估模型。</p>
<p>参考：<a href="https://blog.csdn.net/tsyccnh/article/details/79163834?tdsourcetag=s_pctim_aiomsg" target="_blank" rel="noopener">https://blog.csdn.net/tsyccnh/article/details/79163834?tdsourcetag=s_pctim_aiomsg</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://woojoo520.github.io/2019/09/25/LeetCode-Day40/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mariana">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Celery Fairy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/25/LeetCode-Day40/" itemprop="url">LeetCode-Day40</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-25T08:10:05+08:00">
                2019-09-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="464-我能赢吗"><a href="#464-我能赢吗" class="headerlink" title="464. 我能赢吗"></a>464. 我能赢吗</h3><p>在 “100 game” 这个游戏中，两名玩家轮流选择从 1 到 10 的任意整数，累计整数和，先使得累计整数和达到 100 的玩家，即为胜者。</p>
<p>如果我们将游戏规则改为 “玩家不能重复使用整数” 呢？</p>
<p>例如，两个玩家可以轮流从公共整数池中抽取从 1 到 15 的整数（不放回），直到累计整数和 &gt;= 100。</p>
<p>给定一个整数 maxChoosableInteger （整数池中可选择的最大数）和另一个整数 desiredTotal（累计和），判断先出手的玩家是否能稳赢（假设两位玩家游戏时都表现最佳）？</p>
<p>你可以假设 maxChoosableInteger 不会大于 20， desiredTotal 不会大于 300。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">maxChoosableInteger = 10</span><br><span class="line">desiredTotal = 11</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">false</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">无论第一个玩家选择哪个整数，他都会失败。</span><br><span class="line">第一个玩家可以选择从 1 到 10 的整数。</span><br><span class="line">如果第一个玩家选择 1，那么第二个玩家只能选择从 2 到 10 的整数。</span><br><span class="line">第二个玩家可以通过选择整数 10（那么累积和为 11 &gt;= desiredTotal），从而取得胜利.</span><br><span class="line">同样地，第一个玩家选择任意其他整数，第二个玩家都会赢。</span><br></pre></td></tr></table></figure>

<p>暂时还不知道什么想法…</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> bits, <span class="keyword">int</span> distance, <span class="keyword">int</span> maxChoosableInteger, <span class="keyword">int</span> dp[])</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 已经计算过。0：未计算，1：true， 2：false</span></span><br><span class="line">        <span class="keyword">if</span>(dp[bits] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> dp[bits] == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> result = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> cur = maxChoosableInteger;cur &gt; <span class="number">0</span>;cur--) &#123;</span><br><span class="line">            <span class="keyword">int</span> curBit = <span class="number">1</span> &lt;&lt; (cur - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 如果当前值没有被使用</span></span><br><span class="line">            <span class="keyword">if</span>((bits &amp; curBit) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 可以一步成功</span></span><br><span class="line">                <span class="keyword">if</span>(cur &gt;= distance || !helper(bits | curBit, distance - cur, maxChoosableInteger, dp)) &#123;</span><br><span class="line">                    result = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[bits] = result ? <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canIWin</span><span class="params">(<span class="keyword">int</span> maxChoosableInteger, <span class="keyword">int</span> desiredTotal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> canReachTotal = (<span class="number">1</span> + maxChoosableInteger) * maxChoosableInteger / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(canReachTotal &lt; desiredTotal) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(canReachTotal == desiredTotal) &#123;</span><br><span class="line">            <span class="comment">// 刚好达到的时候，maxChoosableInteger是奇数的时候赢</span></span><br><span class="line">            <span class="keyword">return</span> (maxChoosableInteger &amp; <span class="number">1</span>) == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> dp[<span class="number">1</span> &lt;&lt; maxChoosableInteger] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">0</span>, desiredTotal, maxChoosableInteger, dp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="410-分割数组的最大值"><a href="#410-分割数组的最大值" class="headerlink" title="410. 分割数组的最大值"></a>410. 分割数组的最大值</h3><p>给定一个非负整数数组和一个整数 m，你需要将这个数组分成 m 个非空的连续子数组。设计一个算法使得这 m 个子数组各自和的最大值最小。</p>
<p>注意:<br>数组长度 n 满足以下条件:</p>
<p>1 ≤ n ≤ 1000<br>1 ≤ m ≤ min(50, n)<br>示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">nums = [7,2,5,10,8]</span><br><span class="line">m = 2</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">18</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">一共有四种方法将nums分割为2个子数组。</span><br><span class="line">其中最好的方式是将其分为[7,2,5] 和 [10,8]，</span><br><span class="line">因为此时这两个子数组各自的和的最大值为18，在所有情况中最小。</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>我们能够找到这个答案的一个性质：</p>
<p><code>如果我们找到了一种分割方案，使得最大的分割子数组和不超过x，那么我们也能找到一种分割方案使得最大的分割子数组和不超过y，其中y &gt; x</code></p>
<p>对于值<code>x</code>，我们把这个性质定义为<code>F(x)</code>。如果<code>F(x)</code>为真，那就意味着我们一定可以找到一种分割方案使得最大分割的子数组和不超过<code>x</code></p>
<p>我们让<code>x</code>的区间为<code>负无穷大</code>到<code>无穷大</code>，一旦我们找到一个值<code>x0</code>，使得所有的<code>x &lt; x0</code>,<code>F(x)</code>都为假，所有的<code>x &gt; x0</code>，<code>F(x)</code>都为真。那么显然，这个<code>x0</code>就是我们要的答案了。</p>
<p>算法描述：</p>
<ul>
<li>找到一个数，把它作为分割后各个子数组的和的最大值</li>
<li>根据这个最大值，分割数组，使每个子数组的和都不超过这个最大值</li>
<li>如果不能将数组中所有数字都分割进子数组，即还没分割完，子数组数量就已经用完了。则表示这个最大值还不够大。寻找下一个数，循环步骤1-3</li>
<li>如果全部都分割进子数组，则返回这个最大值。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">splitArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> l = nums[<span class="number">0</span>], h = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : nums) &#123;</span><br><span class="line">            h += i;</span><br><span class="line">            l = max(l, <span class="keyword">long</span>(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; h) &#123;</span><br><span class="line">            <span class="keyword">long</span> mid = (l + h) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">long</span> temp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">1</span>;    <span class="comment">// 初始值必须为1</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> i : nums) &#123;</span><br><span class="line">                temp += i;</span><br><span class="line">                <span class="keyword">if</span>(temp &gt; mid) &#123;</span><br><span class="line">                    temp = i;</span><br><span class="line">                    ++cnt;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cnt &gt; m) &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 能够找到这个分组的时候，开始缩小范围</span></span><br><span class="line">                h = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="467-环绕字符串中唯一的字符串"><a href="#467-环绕字符串中唯一的字符串" class="headerlink" title="467. 环绕字符串中唯一的字符串"></a>467. 环绕字符串中唯一的字符串</h3><p>把字符串 s 看作是“abcdefghijklmnopqrstuvwxyz”的无限环绕字符串，所以 s 看起来是这样的：”…zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd….”. </p>
<p>现在我们有了另一个字符串 p 。你需要的是找出 s 中有多少个唯一的 p 的非空子串，尤其是当你的输入是字符串 p ，你需要输出字符串 s 中 p 的不同的非空子串的数目。 </p>
<p>注意: p 仅由小写的英文字母组成，p 的大小可能超过 10000。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;a&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 字符串 S 中只有一个&quot;a&quot;子字符。</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;cac&quot;</span><br><span class="line">输出: 2</span><br><span class="line">解释: 字符串 S 中的字符串“cac”只有两个子串“a”、“c”。</span><br></pre></td></tr></table></figure>

<p>示例 3:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;zab&quot;</span><br><span class="line">输出: 6</span><br><span class="line">解释: 在字符串 S 中有六个子串“z”、“a”、“b”、“za”、“ab”、“zab”。</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findSubstringInWraproundString</span><span class="params">(<span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = p.length();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录到这个字符为止的最长子序列长度</span></span><br><span class="line">        <span class="keyword">int</span> len_string[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        len_string[p[<span class="number">0</span>] - <span class="string">'a'</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// dp用于记录到目前为止的最长的子序列长度</span></span><br><span class="line">        <span class="keyword">int</span> dp = <span class="number">1</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++) &#123;</span><br><span class="line">            <span class="comment">// 更新dp</span></span><br><span class="line">            <span class="keyword">if</span>(p[i] == p[i - <span class="number">1</span>] + <span class="number">1</span> || (p[i - <span class="number">1</span>] == <span class="string">'z'</span> &amp;&amp; p[i] == <span class="string">'a'</span>)) &#123;</span><br><span class="line">                dp += <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新len_string(可以这么做的原因是某个字符前面的连续串是确定的，所以以某个字符结尾的串的长度一旦大于原先以这个字符结尾的串的长度，则说明，现在的串一定是覆盖了原来的串，不会出现重复的问题的)</span></span><br><span class="line">            len_string[p[i] - <span class="string">'a'</span>] = max(len_string[p[i] - <span class="string">'a'</span>], dp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>;i++) &#123;</span><br><span class="line">            sum += len_string[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="516-最长回文子序列"><a href="#516-最长回文子序列" class="headerlink" title="516. 最长回文子序列"></a>516. 最长回文子序列</h3><p>给定一个字符串s，找到其中最长的回文子序列。可以假设s的最大长度为1000。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">&quot;bbbab&quot;</span><br><span class="line">输出:</span><br><span class="line">4</span><br><span class="line">一个可能的最长回文子序列为 &quot;bbbb&quot;。</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">&quot;cbbd&quot;</span><br><span class="line">输出:</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>典型的动态规划。记<code>dp[i][j]</code>表示从<code>i-j</code>的最长回文子序列</p>
<p>如果<code>s[i] == s[j]</code>，则<code>dp[i][j] = dp[i + 1][j - 1] + 2</code></p>
<p>否则<code>dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])</code></p>
<p>上Code：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxLength =  <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n ,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--) &#123;</span><br><span class="line">            dp[i][i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>;j &lt; n;j++) &#123;</span><br><span class="line">                dp[i][j] = s[i] == s[j] ? dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span> : max(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                maxLength = max(maxLength, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://woojoo520.github.io/2019/09/23/LeetCode-Day39/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mariana">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Celery Fairy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/23/LeetCode-Day39/" itemprop="url">LeetCode-Day39</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-23T13:10:13+08:00">
                2019-09-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209. 长度最小的子数组"></a>209. 长度最小的子数组</h3><p>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组。如果不存在符合条件的连续子数组，返回 0。</p>
<p>示例: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = 7, nums = [2,3,1,2,4,3]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 子数组 [4,3] 是该条件下的长度最小的连续子数组。</span><br></pre></td></tr></table></figure>

<p>思路：这个问题其实很容易就能想到在$O(n^2)$的时间复杂度下解决问题，但是这里采用了一种$O(nlogn)$的做法去解决这个问题。</p>
<p>首先，我们先求解<code>sums</code>数组，表示从头加到当前位置的和。</p>
<p>然后从<code>i = 1</code>到<code>n</code>枚举</p>
<ul>
<li><p>首先<code>to_find</code>定义为当前位置的<code>sum</code>值加上<code>s</code></p>
</li>
<li><p>在<code>sums</code>中找到值<code>to_find</code>最早能插入的地方，即满足从<code>i</code>开始，往后搜索差值为<code>s</code>的需要的最短距离。</p>
<p>在这里搜索的过程中可以采用二分搜索的方法，但是还有一个小技巧，就是利用<code>STL</code>中的<code>lower_bound</code>函数，来表示某一个数字最早能够插入在数组中的位置，这样显然就很高效了鸭~</p>
</li>
</ul>
<p>上Code：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen2</span><span class="params">(<span class="keyword">int</span> s, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sums(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        sums[i] = sums[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>]; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> to_find = s + sums[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">auto</span> bound = lower_bound(sums.begin(), sums.end(), to_find);</span><br><span class="line">        <span class="keyword">if</span>(bound != sums.end()) &#123;</span><br><span class="line">            ans = min(ans, <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt; (bound - (sums.begin() + i - <span class="number">1</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (ans != INT_MAX) ? ans : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于<code>lower_bound &amp;&amp; upper_bound</code>的测试</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; num(a, a + <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; num.size();i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; num[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt; (lower_bound(num.begin(), num.end(), <span class="number">2</span>) - num.begin()) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt; (upper_bound(num.begin(), num.end(), <span class="number">2</span>) - num.begin()) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<h3 id="128-最长连续序列"><a href="#128-最长连续序列" class="headerlink" title="128. 最长连续序列"></a>128. 最长连续序列</h3><p>给定一个未排序的整数数组，找出最长连续序列的长度。</p>
<p>要求算法的时间复杂度为 O(n)。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [100, 4, 200, 1, 3, 2]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 最长连续序列是 [1, 2, 3, 4]。它的长度为 4。</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p><strong>哈希表 + 线性空间的构造</strong></p>
<p>我们先将所有元素放进一个<code>Hash set</code>中，然后遍历<code>num_set</code>中的每一个元素，如果它前面一个数字没有在<code>num_set</code>中，那么它一定不是一个连续数组的开始，则跳过。如果是连续数组的开始，那么就需要一种往后找连续的元素是否存在，然后记录下最长的数列长度。</p>
<p>上Code：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; num_set;</span><br><span class="line">        <span class="keyword">int</span> maxLength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            num_set.insert(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : num_set) &#123;</span><br><span class="line">            <span class="keyword">if</span>(num_set.find(num - <span class="number">1</span>) == num_set.end()) &#123;</span><br><span class="line">                <span class="keyword">int</span> currentNum = num;</span><br><span class="line">                <span class="keyword">int</span> currentLen = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(num_set.find(currentNum + <span class="number">1</span>) != num_set.end()) &#123;</span><br><span class="line">                    currentNum += <span class="number">1</span>;</span><br><span class="line">                    currentLen += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                maxLength = max(maxLength, currentLen);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里虽然看上去复杂度挺高，但实际上是$O(n)$复杂度的，因为每个数字只会遍历到一次，因为如果不是连续数字开头的，就直接跳过了，而是连续数字开头的，就一直遍历到连续数字的末尾，所以总的时间复杂度是$O(n)$的。</p>
<h3 id="126-单词接龙II"><a href="#126-单词接龙II" class="headerlink" title="126. 单词接龙II"></a>126. 单词接龙II</h3><p>给定两个单词（beginWord 和 endWord）和一个字典 wordList，找出所有从 beginWord 到 endWord 的最短转换序列。转换需遵循如下规则：</p>
<p>每次转换只能改变一个字母。<br>转换过程中的中间单词必须是字典中的单词。<br>说明:</p>
<p>如果不存在这样的转换序列，返回一个空列表。<br>所有单词具有相同的长度。<br>所有单词只由小写字母组成。<br>字典中不存在重复的单词。<br>你可以假设 beginWord 和 endWord 是非空的，且二者不相同。<br>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">beginWord = &quot;hit&quot;,</span><br><span class="line">endWord = &quot;cog&quot;,</span><br><span class="line">wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [&quot;hit&quot;,&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;cog&quot;],</span><br><span class="line">  [&quot;hit&quot;,&quot;hot&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">beginWord = &quot;hit&quot;</span><br><span class="line">endWord = &quot;cog&quot;</span><br><span class="line">wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]</span><br><span class="line"></span><br><span class="line">输出: []</span><br><span class="line">解释: endWord &quot;cog&quot; 不在字典中，所以不存在符合要求的转换序列。</span><br></pre></td></tr></table></figure>

<p>思路：<strong>双向BFS</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(<span class="built_in">string</span> beginWord, <span class="built_in">string</span> endWord, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordList)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; freqs;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;word:wordList)</span><br><span class="line">			freqs[word]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(freqs.count(endWord)==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; q1(&#123;beginWord&#125;), q2(&#123;endWord&#125;);</span><br><span class="line">		<span class="keyword">int</span> step=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(freqs[beginWord]|=<span class="number">1</span>,freqs[endWord]|=<span class="number">2</span>; q1.size() &amp;&amp; q2.size(); ++step)&#123;</span><br><span class="line">			<span class="keyword">bool</span> first=q1.size()&lt;q2.size();</span><br><span class="line">			<span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; &amp;q=first?q1:q2;</span><br><span class="line">			<span class="keyword">int</span> flag=first?<span class="number">1</span>:<span class="number">2</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> size=q.size(); size--; q.pop())&#123;</span><br><span class="line">				<span class="built_in">string</span> &amp;word=q.front();</span><br><span class="line">				<span class="keyword">if</span>(freqs[word]==<span class="number">3</span>) <span class="keyword">return</span> step;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;word.length(); ++i)&#123;</span><br><span class="line">					<span class="keyword">for</span>(<span class="keyword">char</span> ch=<span class="string">'a'</span>; ch&lt;=<span class="string">'z'</span>; ++ch)&#123;</span><br><span class="line">						<span class="built_in">string</span> s=word;</span><br><span class="line">						<span class="keyword">if</span>(s[i]==ch) <span class="keyword">continue</span>;</span><br><span class="line">						s[i]=ch;</span><br><span class="line">						<span class="keyword">if</span>(freqs.count(s)==<span class="number">0</span> || freqs[s]&amp;flag) <span class="keyword">continue</span>;</span><br><span class="line">						freqs[s]|=flag;</span><br><span class="line">						q.push(s);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://woojoo520.github.io/2019/09/23/FFT/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mariana">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Celery Fairy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/23/FFT/" itemprop="url">FFT</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-23T13:09:48+08:00">
                2019-09-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="快速傅里叶变换FFT-Fast-Fourier-Transform"><a href="#快速傅里叶变换FFT-Fast-Fourier-Transform" class="headerlink" title="快速傅里叶变换FFT(Fast Fourier Transform)"></a>快速傅里叶变换FFT(Fast Fourier Transform)</h2><h3 id="傅里叶变换"><a href="#傅里叶变换" class="headerlink" title="傅里叶变换"></a>傅里叶变换</h3><p>快速傅里叶变换是一种可以在$O(nlogn)$时间内完成的离散傅里叶变换（DFT）算法。</p>
<p>在算法竞赛中的应用主要是用来加速多项式的乘法。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Mariana</p>
              <p class="site-description motion-element" itemprop="description">a study blog</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">93</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mariana</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
