<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="a study blog">
<meta property="og:type" content="website">
<meta property="og:title" content="Celery Fairy">
<meta property="og:url" content="https://woojoo520.github.io/page/4/index.html">
<meta property="og:site_name" content="Celery Fairy">
<meta property="og:description" content="a study blog">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Celery Fairy">
<meta name="twitter:description" content="a study blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://woojoo520.github.io/page/4/">





  <title>Celery Fairy</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <a href="https://github.com/woojoo520" class="github-corner" aria-label="View source on GitHub">
      <svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/>
      </svg>
    </a>
    <style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Celery Fairy</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Celery's Blog</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://woojoo520.github.io/2019/09/13/LeetCode-Day29/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mariana">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Celery Fairy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/13/LeetCode-Day29/" itemprop="url">LeetCode-Day29</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-13T07:55:58+08:00">
                2019-09-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="LeetCode-Day29-贪心算法专题"><a href="#LeetCode-Day29-贪心算法专题" class="headerlink" title="LeetCode-Day29 贪心算法专题"></a>LeetCode-Day29 贪心算法专题</h2><p>贪心算法可以认为是动态规划算法的一个特例，相比动态规划，使用贪心算法需要满足更多的条件（贪心选择性质），但是效率比动态规划要高。</p>
<p>比如说一个算法问题使用暴力解法需要指数级时间，如果能使用动态规划消除重叠子问题，就可以降到多将是级别，如果满足贪心选择性质，那么可以进一步降低时间复杂度，达到线性级别的。</p>
<p>那么，什么是贪心选择性质呢？简单的说就是：每一步做出一个局部最优的选择，最终的结果就是全局最优。注意，这是一种特殊性质，其实只有一部分问题拥有这个性质。</p>
<h3 id="402-移掉k位数字"><a href="#402-移掉k位数字" class="headerlink" title="402. 移掉k位数字"></a>402. 移掉k位数字</h3><p>给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。</p>
<p>注意:</p>
<p>num 的长度小于 10002 且 ≥ k。<br>num 不会包含任何前导零。<br>示例 1 :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: num = &quot;1432219&quot;, k = 3</span><br><span class="line">输出: &quot;1219&quot;</span><br><span class="line">解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。</span><br></pre></td></tr></table></figure>

<p>示例 2 :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: num = &quot;10200&quot;, k = 1</span><br><span class="line">输出: &quot;200&quot;</span><br><span class="line">解释: 移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。</span><br></pre></td></tr></table></figure>

<p>示例 3 :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: num = &quot;10&quot;, k = 2</span><br><span class="line">输出: &quot;0&quot;</span><br><span class="line">解释: 从原数字移除所有的数字，剩余为空就是0。</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>利用<strong>栈</strong>，从首位开始，如果当前的数字比栈顶的数字要小，则把栈顶的数字弹出，直至栈顶数字小于当前的数字或者栈为空的时候，将该数字放入栈中。</p>
<p>当k位数字放完之后，考虑去除在栈中的首位数字为0的情况，最后返回栈中的字符串和余下未被删除的字符串的拼接。</p>
<p>Code：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeKdigits</span><span class="params">(<span class="built_in">string</span> num, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; word;</span><br><span class="line">        word.push(num[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; num.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (!word.empty() &amp;&amp; word.top() &gt; num[i] &amp;&amp; k &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                word.pop();</span><br><span class="line">                k--;</span><br><span class="line">            &#125;</span><br><span class="line">            word.push(num[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            word.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> new_word = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">while</span> (!word.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            new_word += word.top();</span><br><span class="line">            word.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = new_word.size() - <span class="number">1</span>; i &lt; j; i++, j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> temp = new_word[i];</span><br><span class="line">            new_word[i] = new_word[j];</span><br><span class="line">            new_word[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//去掉首位的０</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (new_word[index] == <span class="string">'0'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index == new_word.size())</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        <span class="keyword">return</span> new_word.substr(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="406-根据身高重建队列"><a href="#406-根据身高重建队列" class="headerlink" title="406. 根据身高重建队列"></a>406. 根据身高重建队列</h3><p>假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对(h, k)表示，其中h是这个人的身高，k是排在这个人前面且身高大于或等于h的人数。 编写一个算法来重建这个队列。</p>
<p>注意：<br>总人数少于1100人。</p>
<p>示例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]</span><br></pre></td></tr></table></figure>

<p>思路：先排序后插入</p>
<p>假设候选队列为A，已经站好队的队列为B</p>
<p>从A里挑身高最高的人x出来，插入到B，因为B中每个人的身高都比x要高，因此x插入的位置，就是看x前面应该有多少人就行了。比如x前面有5个人，那x就插入到队列B的第5个位置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; reconstructQueue(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; people) &#123;</span><br><span class="line">    sort(people.begin(), people.end(), [](<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[<span class="number">0</span>] &gt; b[<span class="number">0</span>]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[<span class="number">0</span>] == b[<span class="number">0</span>] &amp;&amp; a[<span class="number">1</span>] &lt; b[<span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; e: people) &#123;</span><br><span class="line">        res.insert(res.begin() + e[<span class="number">1</span>], e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="452-用最少数量的箭引爆气球"><a href="#452-用最少数量的箭引爆气球" class="headerlink" title="452. 用最少数量的箭引爆气球"></a>452. 用最少数量的箭引爆气球</h3><p>在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以y坐标并不重要，因此只要知道开始和结束的x坐标就足够了。开始坐标总是小于结束坐标。平面内最多存在104个气球。</p>
<p>一支弓箭可以沿着x轴从不同点完全垂直地射出。在坐标x处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[[10,16], [2,8], [1,6], [7,12]]</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">对于该样例，我们可以在x = 6（射爆[2,8],[1,6]两个气球）和 x = 11（射爆另外两个气球）。</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>首先，想到的就是先排序，按照<code>points</code>的<code>first</code>从小到大，<code>second</code>从大到小，然后，不断缩小范围直至范围不存在，则需要箭的数量<code>+1</code></p>
<p>Code如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMinArrowShots</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(points.size() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> points.size();</span><br><span class="line">        &#125;</span><br><span class="line">        sort(points.begin(), points.end(), [](<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[<span class="number">0</span>] &lt; b[<span class="number">0</span>]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(a[<span class="number">0</span>] == b[<span class="number">0</span>] &amp;&amp; a[<span class="number">1</span>] &gt; b[<span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> left = points[<span class="number">0</span>][<span class="number">0</span>], right = points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; points.size();i++) &#123;</span><br><span class="line">            left = max(left, points[i][<span class="number">0</span>]);</span><br><span class="line">            right = min(right, points[i][<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(left &gt; right) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                left = points[i][<span class="number">0</span>];</span><br><span class="line">                right = points[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="435-无重叠区间"><a href="#435-无重叠区间" class="headerlink" title="435. 无重叠区间"></a>435. 无重叠区间</h3><p>问题概述：这是一个很经典的贪心算法问题<code>Interval Scheduling</code>（区间调度问题）。给你很多形如<code>[start, end]</code>的闭区间，请你设计一个算法，算出这些区间中最多有几个互不相交的区间。</p>
<p>这个问题，在生活中应用广泛，比如你今天有好几个活动，每个活动都可以用区间<code>[start, end]</code>表示开始和结束的时间，请问你今天最多能参加几个活动呢？显然你一个人不能同时参加两个活动，所以说这个问题就是求这些时间区间的最大不相交子集。</p>
<p><strong>贪心解法：</strong></p>
<p>这个问题可以分为以下三个步骤：</p>
<ul>
<li>从区间集合intvs中选择一个区间x，这个x是在当前所有区间中结束最早的（end最小）</li>
<li>把所有与x区间相交的区间从区间集合intvs中删除</li>
<li>重复步骤1和2，直到intvs为空为止。之前选出的那些x就是最大不相交自己。</li>
</ul>
<p>把这个思路实现成算法的话，可以按每个区间<code>end</code>数值升序排序，因为这样处理之后实现步骤1和步骤2都方便很多。</p>
<p><img src="https://pic.leetcode-cn.com/678752f150168fc2e53a36d30e589b76ef81a95943c018b01bef6a548bfafeeb-file_1566313617208" alt="1"></p>
<p>Code：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals.size() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(intervals.begin(), intervals.end(), [](<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[<span class="number">1</span>] &lt; b[<span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(a[<span class="number">1</span>] == b[<span class="number">1</span>] &amp;&amp; a[<span class="number">0</span>] &lt; b[<span class="number">0</span>]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">int</span> right = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; intervals.size();i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>] &lt; right) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://woojoo520.github.io/2019/09/12/Dataloader的使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mariana">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Celery Fairy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/12/Dataloader的使用/" itemprop="url">Dataloader的使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-12T10:09:58+08:00">
                2019-09-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="DataLoader的使用"><a href="#DataLoader的使用" class="headerlink" title="DataLoader的使用"></a>DataLoader的使用</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch </span><br><span class="line"><span class="keyword">import</span> torch.utils.data.dataset <span class="keyword">as</span> Dataset </span><br><span class="line"><span class="keyword">import</span> torch.utils.data.dataloader <span class="keyword">as</span> Dataloader</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"># CPU version</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 注意，这里如果只写了Dataset而不是Dataset.Dataset，则会报错，因为Dataset是module模块，而不是class类，所以需要调用module里的class才行，因此是Dataset.Dataset</span></span><br><span class="line"><span class="string">class subDataset(Dataset.Dataset):</span></span><br><span class="line"><span class="string">    def __init__(self, Data, Label):</span></span><br><span class="line"><span class="string">        self.Data = Data</span></span><br><span class="line"><span class="string">        self.Label = Label</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    def __len__(self):</span></span><br><span class="line"><span class="string">        return len(self.Data)</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    def __getitem__(self, index):</span></span><br><span class="line"><span class="string">        data = torch.Tensor(self.Data[index])</span></span><br><span class="line"><span class="string">        label = torch.Tensor(self.Label[index])</span></span><br><span class="line"><span class="string">        return data, label</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Data = np.asarray([[1, 2], [3, 4], [5, 6], [7, 8]])</span></span><br><span class="line"><span class="string">Label = np.asarray([[0], [1], [0], [2]])</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">if __name__ == '__main__':</span></span><br><span class="line"><span class="string">    dataset = subDataset(Data, Label)</span></span><br><span class="line"><span class="string">    print(dataset)</span></span><br><span class="line"><span class="string">    print('dataset.size = ', dataset.__len__())</span></span><br><span class="line"><span class="string">    print(dataset.__getitem__(0))</span></span><br><span class="line"><span class="string">    print(dataset[0])</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    dataloader = Dataloader.DataLoader(dataset, batch_size=2, shuffle=True, num_workers=4)</span></span><br><span class="line"><span class="string">    for index, item in enumerate(dataloader):</span></span><br><span class="line"><span class="string">        print('i', index)</span></span><br><span class="line"><span class="string">        data, label = item</span></span><br><span class="line"><span class="string">        print('data: &#123;&#125;, label: &#123;&#125;'.format(data, label))</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># GPU version  </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">subDataset</span><span class="params">(Dataset.Dataset)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, Data, Label)</span>:</span></span><br><span class="line">        self.Data = Data</span><br><span class="line">        self.Label = Label</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.Data)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        data = torch.Tensor(self.Data[index])</span><br><span class="line">        label = torch.Tensor(self.Label[index])</span><br><span class="line">        <span class="keyword">return</span> data, label</span><br><span class="line"></span><br><span class="line">Data = np.asarray([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>]])</span><br><span class="line">Label = np.asarray([[<span class="number">0</span>], [<span class="number">1</span>], [<span class="number">0</span>], [<span class="number">2</span>]])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    dataset = subDataset(Data, Label)</span><br><span class="line">    print(dataset)</span><br><span class="line">    print(<span class="string">'dataset.size = '</span>, dataset.__len__())</span><br><span class="line">    print(dataset.__getitem__(<span class="number">0</span>))</span><br><span class="line">    print(dataset[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    dataloader = Dataloader.DataLoader(dataset, batch_size=<span class="number">2</span>, shuffle=<span class="literal">True</span>, num_workers=<span class="number">0</span>)</span><br><span class="line">    <span class="comment"># 这里需要质疑把num_workers改为0</span></span><br><span class="line">    <span class="keyword">for</span> index, item <span class="keyword">in</span> enumerate(dataloader):</span><br><span class="line">        print(<span class="string">'i'</span>, index)</span><br><span class="line">        data, label = item</span><br><span class="line">        <span class="keyword">if</span> torch.cuda.is_available():</span><br><span class="line">            data = data.cuda()</span><br><span class="line">            label = label.cuda()</span><br><span class="line">        print(<span class="string">'data: &#123;&#125;, label: &#123;&#125;'</span>.format(data, label))</span><br></pre></td></tr></table></figure>

<h3 id="Dataset和DataLoader总结："><a href="#Dataset和DataLoader总结：" class="headerlink" title="Dataset和DataLoader总结："></a>Dataset和DataLoader总结：</h3><ul>
<li>Dataset是一个抽象类，需要<strong>派生一个子类构造数据集</strong>，需要改写的方法有<code>__init__, __getitem__, __len__</code>等等。</li>
<li>DataLoader是一个迭代器，方便我们访问Dataset里的对象，值得注意的<code>num_workers</code>的参数设置：如果放在<strong>CPU</strong>上跑，<strong>可以不管</strong>，但是<strong>放在GPU上则需要设置为0</strong>；或者在DataLoader操作之后将Tensor放在GPU上</li>
<li><strong>数据和标签是tuple元组的形式</strong>，使用DataLoader然后使用enumerate函数访问他们</li>
</ul>
<p><strong>顺便带一下CIFAR-10数据集的说明</strong></p>
<p>该数据集共有60000张彩色图像，这些图像时32 * 32，分为10个类，每类6000张图片。这里面有50000张用于训练，构成了5个训练批，每一批10000张图；另外10000张用于测试，单独构成一批。测试批的数据里，取自10类中的每一类，每一类随机取1000张。抽剩下的随机排列就组成了训练批。注意一个训练批中的各类图像并不一定数量相同，总的来看，每一类都有5000张图</p>
<p>下面这幅图就是列举了10各类，每一类展示了随机的10张图片：</p>
<p><img src="https://images2018.cnblogs.com/blog/1196151/201712/1196151-20171225161744462-2083152737.png" alt="img"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://woojoo520.github.io/2019/09/12/LeetCode-Day28/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mariana">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Celery Fairy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/12/LeetCode-Day28/" itemprop="url">LeetCode-Day28</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-12T08:13:31+08:00">
                2019-09-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="221-最大正方形"><a href="#221-最大正方形" class="headerlink" title="221. 最大正方形"></a>221. 最大正方形</h3><p>在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line"></span><br><span class="line">1 0 1 0 0</span><br><span class="line">1 0 1 1 1</span><br><span class="line">1 1 1 1 1</span><br><span class="line">1 0 0 1 0</span><br><span class="line"></span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>

<p>思路：这里仍然采用了动态规划的思路，<code>dp[i][j]</code>表示以<code>(i, j)</code>为右下角的最大的正方形的边长，当<code>matrix[i][j] = ‘1’</code>时， 就沿着<code>x = j</code>和<code>y = i</code>看看能扩展多长。</p>
<p>如图：</p>
<p>![img](file:///C:\Users\12751\Documents\Tencent Files\1275121799\Image\C2C{A3A8F3A4-FB78-F227-FF39-EB244569E139}.png)</p>
<p>所以Code如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.empty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> row = matrix.size(), col = matrix[<span class="number">0</span>].size();    </span><br><span class="line">        <span class="keyword">int</span> dp[row][col] = &#123;&#123;<span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> maxN = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; col;i++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = matrix[<span class="number">0</span>][i] == <span class="string">'1'</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            maxN = max(maxN, dp[<span class="number">0</span>][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; row;i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = matrix[i][<span class="number">0</span>] == <span class="string">'1'</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            maxN = max(maxN, dp[i][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; row;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; col;j++) &#123;</span><br><span class="line">                dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> count = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">while</span>(count &gt;= <span class="number">0</span> &amp;&amp; matrix[i - dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + count][j] == <span class="string">'1'</span> &amp;&amp; matrix[i][j - dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + count] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                        count--;</span><br><span class="line">                        dp[i][j]++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    maxN = max(maxN, dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxN * maxN;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="316-去除重复字母"><a href="#316-去除重复字母" class="headerlink" title="316. 去除重复字母"></a>316. 去除重复字母</h3><p>给定一个仅包含小写字母的字符串，去除字符串中重复的字母，使得每个字母只出现一次。需保证返回结果的字典序最小（要求不能打乱其他字符的相对位置）。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;bcabc&quot;</span><br><span class="line">输出: &quot;abc&quot;</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;cbacdcbc&quot;</span><br><span class="line">输出: &quot;acdb&quot;</span><br></pre></td></tr></table></figure>

<p>思路：<strong>贪心算法</strong></p>
<p>这道题的思路首先在于如何处理这个消除字母的标准，也就是如何贪心？</p>
<p>设想一下，如果是我们自己来处理这个问题，我们会如何思考。首先看一下当前字母前面有没有字典序比它大的字母，如果有的话，就看看这个字母后面的串中是不是还会出现，如果不出现，就不要动他了，如果出现了，就把它删掉。</p>
<p>所以，思路就出来了，最终我们采用栈的方法去解决这个问题</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeDuplicateLetters</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// 统计每个字母的个数</span></span><br><span class="line">        <span class="keyword">int</span> word[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="comment">// 统计每个字符现在是否在栈中</span></span><br><span class="line">        <span class="keyword">bool</span> isIn[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="comment">// 统计每个字母出现的次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s.length();i++) &#123;</span><br><span class="line">            word[s[i] - <span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s.length();i++) &#123;</span><br><span class="line">            word[s[i] - <span class="string">'a'</span>]--;</span><br><span class="line">            <span class="comment">// 如果该字母还没有进栈</span></span><br><span class="line">            <span class="keyword">if</span>(!isIn[s[i] - <span class="string">'a'</span>]) &#123;</span><br><span class="line">                <span class="keyword">while</span>(!st.empty()) &#123;</span><br><span class="line">                    <span class="comment">//如果栈顶字母的比当前的s[i]要大并且后面还会出现该字母，则可以考虑删掉，即出栈</span></span><br><span class="line">                    <span class="keyword">if</span>(!st.empty() &amp;&amp; st.top() &gt; s[i] &amp;&amp; word[st.top() - <span class="string">'a'</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        isIn[st.top() - <span class="string">'a'</span>] = <span class="literal">false</span>;</span><br><span class="line">                        st.pop();		</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">break</span>;	<span class="comment">// 处理完就直接出栈</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 该字母进栈</span></span><br><span class="line">                st.push(s[i]);</span><br><span class="line">                isIn[s[i] - <span class="string">'a'</span>] = <span class="literal">true</span>;    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 按照出栈的顺序反向建立该string</span></span><br><span class="line">        <span class="built_in">string</span> str = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">while</span>(!st.empty()) &#123;</span><br><span class="line">            str = st.top() + str;</span><br><span class="line">            st.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="376-摆动序列"><a href="#376-摆动序列" class="headerlink" title="376. 摆动序列"></a>376. 摆动序列</h3><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。</p>
<p>例如， [1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。相反, [1,4,7,2,5] 和 [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</p>
<p>给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,7,4,9,2,5]</span><br><span class="line">输出: 6 </span><br><span class="line">解释: 整个序列均为摆动序列。</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,17,5,10,13,15,10,5,16,8]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。</span><br></pre></td></tr></table></figure>

<p>示例 3:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,5,6,7,8,9]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<p>思路：贪心算法（虽然我也不知道这个竟然算贪心的..）</p>
<p>就是维护一个变量up，表示当前应该寻找的是更大的还是更小的数字来维护这一个摆动序列</p>
<p>例如，示例里面的<code>[1,17,5,10,13,15,10,5,16,8]</code></p>
<p>当读到<code>1, 17</code>的时候，up应该变成<code>-1</code>，即表示，下一个要寻找的数字应该是比17要小的，如果比17大，则继续往下找比该数字小的数字，知道满足<code>nums[i] &gt;&lt; nums[i - 1]</code>未知，满足之后up就应该变成1，即下一个需要找的数是需要满足<code>nums[i] &gt; nums[i - 1]</code>的。</p>
<p>所以Code如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">wiggleMaxLength</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums.size();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">bool</span> allsame = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> up;</span><br><span class="line">        <span class="keyword">if</span>(nums[<span class="number">1</span>] &gt; nums[<span class="number">0</span>]) &#123;</span><br><span class="line">            up = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[<span class="number">1</span>] &lt; nums[<span class="number">0</span>]) &#123;</span><br><span class="line">            up = <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            up = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; nums.size();i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != nums[i - <span class="number">1</span>] &amp;&amp; allsame) &#123;</span><br><span class="line">                allsame = <span class="literal">false</span>;</span><br><span class="line">                up = nums[i] &gt; nums[i - <span class="number">1</span>] ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">                sum++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(up == <span class="number">1</span> &amp;&amp; nums[i] &gt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                up = -up;</span><br><span class="line">                sum++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(up == <span class="number">-1</span> &amp;&amp; nums[i] &lt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                up = -up;</span><br><span class="line">                sum++;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">// cout &lt;&lt; "sum = " &lt;&lt; sum &lt;&lt; endl;</span></span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">if</span>(allsame) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum &lt; <span class="number">2</span> ? <span class="number">2</span> : sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注释：这里比较复杂的是判断初始的情况以及，全部都是同一个数的情况。</p>
<p>初始情况如果是两个数字相同，则当前<code>up</code>的值置为0， 即暂时还不能判断，知道<code>nums[i] != nums[i - 1]</code>，此时需要更新<code>up</code>的值。</p>
<p>如果所有的数字都是同一个的话，就应该返回1.</p>
<h3 id="330-按要求补齐数组"><a href="#330-按要求补齐数组" class="headerlink" title="330. 按要求补齐数组"></a>330. 按要求补齐数组</h3><p>给定一个已排序的正整数数组 nums，和一个正整数 n 。从 [1, n] 区间内选取任意个数字补充到 nums 中，使得 [1, n] 区间内的任何数字都可以用 nums 中某几个数字的和来表示。请输出满足上述要求的最少需要补充的数字个数。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,3], n = 6</span><br><span class="line">输出: 1 </span><br><span class="line">解释:</span><br><span class="line">根据 nums 里现有的组合 [1], [3], [1,3]，可以得出 1, 3, 4。</span><br><span class="line">现在如果我们将 2 添加到 nums 中， 组合变为: [1], [2], [3], [1,3], [2,3], [1,2,3]。</span><br><span class="line">其和可以表示数字 1, 2, 3, 4, 5, 6，能够覆盖 [1, 6] 区间里所有的数。</span><br><span class="line">所以我们最少需要添加一个数字。</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,5,10], n = 20</span><br><span class="line">输出: 2</span><br><span class="line">解释: 我们需要添加 [2, 4]。</span><br></pre></td></tr></table></figure>

<p>示例 3:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,2,2], n = 5</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure>

<p>思路：<strong>贪心算法</strong></p>
<p>直觉：</p>
<p>对于任何缺少的数字，如果我们想让和能覆盖到它，我们必须添加至少一个小于或等于该数字的数字。否则，将无法覆盖到。想象你要给一个人x分钱的零钱，但你没有足够的硬币。你肯定会需要面额小于或等于x的硬币。</p>
<p>算法：</p>
<p>假设 <code>miss</code> 是缺少的数字中最小的，则区间 <code>[1, miss)</code> (左闭右开) 已经被完全覆盖。为了覆盖 <code>miss</code>，我们需要添加某些小于等于 <code>miss</code> 的数字。否则将不可能覆盖到。</p>
<p>例如，数组 <code>nums = [1,2,3,8]， n = 16</code>。已经覆盖到的数字有区间 <code>[1, 6]</code> 和 <code>[8, 14]</code>。换而言之，<code>7, 15, 16</code> 没有覆盖到。如果你加的数字大于 <code>7</code>，则 <code>7</code> 依然覆盖不到。</p>
<p>假设我们添加的数字是 <code>x</code>，则区间 <code>[1, miss)</code> 和 <code>[x, x + miss)</code> 均被覆盖到。由于我们知道 <code>x &lt;= miss</code>，这两个区间必然覆盖了区间 <code>[1, x + miss)</code>。我们希望能够尽可能选择大的 <code>x</code>，这样覆盖的范围就可以尽可能大。因此，最好的选择是 <code>x = miss</code>。</p>
<p>在覆盖到 miss 后，我们可以重新计算覆盖范围，查看新的最小的缺少数字。然后加上该数字。重复操作直到全部数字都被堵盖到。</p>
<p>所以，整个贪心算法的流程如下：</p>
<ul>
<li><p>初始化区间<code>[1, miss) = [1, 1) = 空</code></p>
</li>
<li><p>每当n没有被覆盖</p>
<ul>
<li>若当前元素<code>nums[i]</code>小于等于<code>miss</code><ul>
<li>将范围扩展到<code>[1, miss + nums[i])</code></li>
<li>将<code>i</code>增加1</li>
</ul>
</li>
<li>否则，将<code>miss</code>添加到数组，将范围扩展到<code>[1, miss + miss)</code></li>
<li>增加数字的计数</li>
</ul>
</li>
<li><p>返回增加的数字</p>
</li>
</ul>
<p>Code如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minPatches</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> patches = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> miss = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(miss &lt;= n) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; nums.size() &amp;&amp; nums[i] &lt;= miss) &#123;</span><br><span class="line">                miss += nums[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                miss += miss;</span><br><span class="line">                patches++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> patches;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://woojoo520.github.io/2019/09/11/LeetCode-Day27/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mariana">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Celery Fairy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/11/LeetCode-Day27/" itemprop="url">LeetCode-Day27</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-11T07:59:37+08:00">
                2019-09-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="LeetCode-Day27——动态规划专题"><a href="#LeetCode-Day27——动态规划专题" class="headerlink" title="LeetCode-Day27——动态规划专题"></a>LeetCode-Day27——动态规划专题</h2><h3 id="97-交错字符串"><a href="#97-交错字符串" class="headerlink" title="97. 交错字符串"></a>97. 交错字符串</h3><p>给定三个字符串 s1, s2, s3, 验证 s3 是否是由 s1 和 s2 交错组成的。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbcbcac&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbbaccc&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<p>思路：<strong>动态规划</strong></p>
<p><strong>划重点：</strong></p>
<p><code>dp[i][j]</code>表示<code>s1</code>的前<code>i</code>个字符和<code>s2</code>的前<code>j</code>个字符是否能够交错生成<code>s3</code>的前<code>i+j</code>个字符。 </p>
<p><code>dp[0][0] = 1</code>：因为当所有都为空的时候，就已经符合条件了</p>
<p>初始化的时候第一行为<code>dp[0][i] = dp[0][i - 1] &amp;&amp; s2[i - 1] == s3[i - 1]</code></p>
<p>同理，第一列为<code>dp[i][0] = dp[i - 1][0] &amp;&amp; s1[i - 1] == s3[i - 1]</code></p>
<p>（初始化非常非常重要，一定要从空开始考虑，而不要从第一个字符开始考虑，否则会遇到很多bug然后通不过）</p>
<p>然后动态规划的方程为</p>
<p><code>dp[i][j] = (dp[i - 1][j] &amp;&amp; s1[i - 1] == s3[i + j - 1]) || (dp[i][j - 1] &amp;&amp; s2[j - 1] == s3[i + j - 1])</code></p>
<p>这样就可以写出Code了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isInterleave</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2, <span class="built_in">string</span> s3)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = s1.length(), len2 = s2.length();</span><br><span class="line">        <span class="keyword">if</span>(s3.length() != s1.length() + s2.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len1 == <span class="number">0</span> &amp;&amp; len2 == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s3.length() == <span class="number">0</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len1 == <span class="number">0</span> || len2 == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (s3 == s1 || s3 == s2) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> dp[len1 + <span class="number">1</span>][len2 + <span class="number">1</span>] = &#123;&#123;<span class="number">0</span>&#125;&#125;;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= len1;i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] &amp;&amp; s1[i - <span class="number">1</span>] == s3[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= len2;i++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i - <span class="number">1</span>] &amp;&amp; s2[i - <span class="number">1</span>] == s3[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= len1;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= len2;j++) &#123;</span><br><span class="line">                dp[i][j] = (dp[i - <span class="number">1</span>][j] &amp;&amp; s1[i - <span class="number">1</span>] == s3[i + j - <span class="number">1</span>]) || (dp[i][j - <span class="number">1</span>] &amp;&amp; s2[j - <span class="number">1</span>] == s3[i + j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len1][len2];  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="115-不同的子序列"><a href="#115-不同的子序列" class="headerlink" title="115. 不同的子序列"></a>115. 不同的子序列</h3><p>给定一个字符串 S 和一个字符串 T，计算在 S 的子序列中 T 出现的个数。</p>
<p>一个字符串的一个子序列是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，”ACE” 是 “ABCDE” 的一个子序列，而 “AEC” 不是）</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入: S = &quot;rabbbit&quot;, T = &quot;rabbit&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释:</span><br><span class="line"></span><br><span class="line">如下图所示, 有 3 种可以从 S 中得到 &quot;rabbit&quot; 的方案。</span><br><span class="line">(上箭头符号 ^ 表示选取的字母)</span><br><span class="line"></span><br><span class="line">rabbbit</span><br><span class="line">^^^^ ^^</span><br><span class="line">rabbbit</span><br><span class="line">^^ ^^^^</span><br><span class="line">rabbbit</span><br><span class="line">^^^ ^^</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">输入: S = &quot;babgbag&quot;, T = &quot;bag&quot;</span><br><span class="line">输出: 5</span><br><span class="line">解释:</span><br><span class="line"></span><br><span class="line">如下图所示, 有 5 种可以从 S 中得到 &quot;bag&quot; 的方案。 </span><br><span class="line">(上箭头符号 ^ 表示选取的字母)</span><br><span class="line"></span><br><span class="line">babgbag</span><br><span class="line">^^ ^</span><br><span class="line">babgbag</span><br><span class="line">^^    ^</span><br><span class="line">babgbag</span><br><span class="line">^    ^^</span><br><span class="line">babgbag</span><br><span class="line">  ^  ^^</span><br><span class="line">babgbag</span><br><span class="line">    ^^</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p><code>dp[i][j]</code>表示<code>t</code>的前<code>i</code>个字符与<code>s</code>的前<code>j</code>个字符匹配的个数。</p>
<p>如果<code>t</code>的第<code>i</code>个字符和<code>s</code>的第<code>j</code>的字符一样的话，那么<code>dp[i][j] = dp[i - 1][j - 1] + dp[i][j - 1]</code></p>
<p>如果不一样的话， <code>dp[i][j] = dp[i][j - 1]</code>。</p>
<p>Code：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDistinct</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = s.length(), len2 = t.length();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> dp[len2 + <span class="number">1</span>][len1 + <span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= len1;i++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= len2;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= len1;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(t[i - <span class="number">1</span>] == s[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len2][len1];  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意：不过不用long long的话，只用int会爆掉。</p>
<h3 id="132-分割回文串II"><a href="#132-分割回文串II" class="headerlink" title="132. 分割回文串II"></a>132. 分割回文串II</h3><p>给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。</p>
<p>返回符合要求的最少分割次数。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;aab&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 进行一次分割就可将 s 分割成 [&quot;aa&quot;,&quot;b&quot;] 这样两个回文子串。</span><br></pre></td></tr></table></figure>

<p>解释：这里一维动态规划，但是这里的想法很难想到（我很难…想到…</p>
<p>首先初始化整个数组的内容为自己的下标，即一个字母就是一个分割。然后遍历每一个点，以该点为回文中心，向两边更新（注意考虑奇数偶数两种情况）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCut</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">int</span> dp[len + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= len;i++) &#123;</span><br><span class="line">            dp[i] = i - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) &#123;</span><br><span class="line">            dp[i + <span class="number">1</span>] = min(dp[i + <span class="number">1</span>], dp[i] + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(i == len - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> start = i, end = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(start &gt;= <span class="number">0</span> &amp;&amp; end &lt; len &amp;&amp; s[start] == s[end]) &#123;</span><br><span class="line">                dp[end + <span class="number">1</span>] = min(dp[end + <span class="number">1</span>], dp[start] + <span class="number">1</span>);</span><br><span class="line">                start--, end++;</span><br><span class="line">            &#125;</span><br><span class="line">            start = i - <span class="number">1</span>, end = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(start &gt;= <span class="number">0</span> &amp;&amp; end &lt; len &amp;&amp; s[start] == s[end]) &#123;</span><br><span class="line">                dp[end + <span class="number">1</span>] = min(dp[end + <span class="number">1</span>], dp[start] + <span class="number">1</span>);</span><br><span class="line">                start--, end++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="174-地下城游戏"><a href="#174-地下城游戏" class="headerlink" title="174. 地下城游戏"></a>174. 地下城游戏</h3><p>一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。</p>
<p>骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。</p>
<p>有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。</p>
<p>为了尽快到达公主，骑士决定每次只向右或向下移动一步。</p>
<p>编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">例如，考虑到如下布局的地下城，如果骑士遵循最佳路径 右 -&gt; 右 -&gt; 下 -&gt; 下，则骑士的初始健康点数至少为 7。</span><br><span class="line"></span><br><span class="line">-2 (K)	-3	3</span><br><span class="line">-5	-10	1</span><br><span class="line">10	30	-5 (P)</span><br><span class="line"></span><br><span class="line">说明:</span><br><span class="line"></span><br><span class="line">骑士的健康点数没有上限。</span><br><span class="line"></span><br><span class="line">任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。</span><br></pre></td></tr></table></figure>

<p>思路：依然是<strong>动态规划。</strong></p>
<p>但是不一样的是，这道题需要倒着考虑，你需要从右下角位置P处生命值至少为1开始倒着计算。</p>
<p>每一个点的生命值由它右边或下面的生命值求解，但需要注意的是，求解出来的生命值需要和1进行比较，比如，求解出来的生命值为负值（即后面有可能遇到加了很多生命值的情况），但是在该点<code>[i][j]</code>仍然需要满足生命值大于等于1的请款，因此会有<code>max(1, min(nums[i + 1][j], nums[i][j + 1]) - dungeon[i][j])</code>的表达式产生！</p>
<p>Code：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculateMinimumHP</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; dungeon)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> row = dungeon.size(), col = dungeon[<span class="number">0</span>].size();</span><br><span class="line">    <span class="keyword">int</span> nums[row][col];</span><br><span class="line">    nums[row - <span class="number">1</span>][col - <span class="number">1</span>] = max(<span class="number">1</span>,<span class="number">1</span> - dungeon[row - <span class="number">1</span>][col - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = row - <span class="number">2</span>;i &gt;= <span class="number">0</span>;i--) &#123;</span><br><span class="line">        nums[i][col - <span class="number">1</span>] = max(<span class="number">1</span>, nums[i + <span class="number">1</span>][col - <span class="number">1</span>] - dungeon[i][col - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = col - <span class="number">2</span>;i &gt;= <span class="number">0</span>;i--) &#123;</span><br><span class="line">        nums[row - <span class="number">1</span>][i] = max(<span class="number">1</span>, nums[row - <span class="number">1</span>][i + <span class="number">1</span>] - dungeon[row - <span class="number">1</span>][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = row - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = col - <span class="number">2</span>;j &gt;= <span class="number">0</span>;j--) &#123;</span><br><span class="line">            nums[i][j] = max(<span class="number">1</span>, min(nums[i + <span class="number">1</span>][j], nums[i][j + <span class="number">1</span>]) - dungeon[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;       </span><br><span class="line">    <span class="keyword">return</span> nums[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="213-打家劫舍II"><a href="#213-打家劫舍II" class="headerlink" title="213. 打家劫舍II"></a>213. 打家劫舍II</h3><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p>
<p>示例 1:</p>
<p>输入: [2,3,2]<br>输出: 3<br>解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。<br>示例 2:</p>
<p>输入: [1,2,3,1]<br>输出: 4<br>解释: 你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。<br>     偷窃到的最高金额 = 1 + 3 = 4 。</p>
<p>思路：这里需要注意的是<strong>环形</strong>，因此不能简单的考虑<code>dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])</code>，因为你需要注意第一个是否拿过，因此，我们就设置两种情况，一种是强制拿第一个，另一种就是强制不拿第一个。</p>
<p>所以我们使用二维的<code>dp[n][2]</code>数组。</p>
<p><code>dp[0][0]</code>表示不拿第一个,<code>dp[0][1]</code>表示拿第一个，则推导初始情况：</p>
<p><code>dp[0][0] = 0, dp[1][0] = nums[1], dp[0][1] = nums[0], dp[1][1] = nums[0]</code></p>
<p>然后写动态转移方程的时候需要注意<code>dp[i][0]</code>只能从<code>dp[j][0]</code>转移过来，<code>dp[i][1]</code>只能从<code>dp[j][1]</code>转移过来。</p>
<p>最后返回最值的时候，只要<code>dp[n - 1][0]</code>和<code>dp[n - 2][1]</code>之间考虑即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.size();</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums.size() == <span class="number">1</span> ? nums[<span class="number">0</span>] : max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> dp[len][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>, dp[<span class="number">1</span>][<span class="number">0</span>] = nums[<span class="number">1</span>], dp[<span class="number">0</span>][<span class="number">1</span>] = nums[<span class="number">0</span>], dp[<span class="number">1</span>][<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; len;i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">2</span>][<span class="number">0</span>] + nums[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">2</span>][<span class="number">1</span>] + nums[i]);</span><br><span class="line">        &#125;     </span><br><span class="line">        <span class="keyword">return</span> max(dp[len - <span class="number">1</span>][<span class="number">0</span>], dp[len - <span class="number">2</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://woojoo520.github.io/2019/09/10/DCGAN/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mariana">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Celery Fairy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/10/DCGAN/" itemprop="url">DCGAN</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-10T19:25:36+08:00">
                2019-09-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="UNSUPERVISED-REPRESENTATION-LEARNING-WITH-DEEP-CONVOLUTIONAL-GENERATIVE-ADVERSARIAL-NETWORKS（DCGAN的非监督表征学习）"><a href="#UNSUPERVISED-REPRESENTATION-LEARNING-WITH-DEEP-CONVOLUTIONAL-GENERATIVE-ADVERSARIAL-NETWORKS（DCGAN的非监督表征学习）" class="headerlink" title="UNSUPERVISED REPRESENTATION LEARNING WITH DEEP CONVOLUTIONAL GENERATIVE ADVERSARIAL NETWORKS（DCGAN的非监督表征学习）"></a>UNSUPERVISED REPRESENTATION LEARNING WITH DEEP CONVOLUTIONAL GENERATIVE ADVERSARIAL NETWORKS（DCGAN的非监督表征学习）</h2><p>GAN：对抗生成网络，是生成模型的一种，而它的训练则是处于一种对抗博弈状态中的。</p>
<h3 id="GAN的基本结构"><a href="#GAN的基本结构" class="headerlink" title="GAN的基本结构"></a>GAN的基本结构</h3><p>GAN的主要结构包括一个生成器G（Generator）和一个判别器（Discriminator）</p>
<h4 id="关于生成器"><a href="#关于生成器" class="headerlink" title="关于生成器"></a>关于生成器</h4><p>对于生成器，输入需要一个n维度向量，输出为图片像素大小的图片。因此需要得到输入的向量。</p>
<h4 id="关于判别器"><a href="#关于判别器" class="headerlink" title="关于判别器"></a>关于判别器</h4><p>输入为图片，输出为图片的真伪标签</p>
<h3 id="如何训练"><a href="#如何训练" class="headerlink" title="如何训练"></a>如何训练</h3><p>基本流程如下：</p>
<ul>
<li><p>初始化判别器D的参数$\theta_{d}$和生成器G的参数$\theta_{g}$</p>
</li>
<li><p>从真实样本中采样$m$个样本${x^1, x^2, …,x^m}$，从先验分布噪声中采样$m$个噪声样本${z^1, z^2,…,z^m}$并通过生成器获取$m$个生成样本$\left{\tilde{x}^{1}, \tilde{x}^{2}, \ldots, \tilde{x}^{m}\right}$。固定生成器G，训练判别器D尽可能好地准确判别真实样本和生成样本，尽可能大地区分正确样本和生成的样本。</p>
</li>
<li><p><strong>循环$k$次更新判别器之后，使用较小的学习率来更新一次生成器的参数</strong>，训练生成器使其尽可能能够减小生成样本与真实样本之间的差距，也相当于尽量使得判别器判别错误</p>
</li>
<li><p>多次更新迭代之后，最终理想情况是使得判别器判别不出样本来自生成器的输出还是真实的输出，亦即最终样本判别概率均为0.5</p>
</li>
</ul>
<p><code>Tips:之所以要训练k次判别器，再训练生成器，是因为要现拥有一个好的判别器，使得能够较好地区分出真实样本和生成样本之后，才能更为准确地对生成器进行更新</code></p>
<h3 id="训练相关理论基础"><a href="#训练相关理论基础" class="headerlink" title="训练相关理论基础"></a>训练相关理论基础</h3><p><img src="https://pic2.zhimg.com/80/v2-9aaed21e79bebcc6638742fb126de225_hd.jpg" alt="img"></p>
<p>判别器在这里是一种分类器，用于区分样本的真伪，因此我们常常使用交叉熵（cross entropy）来进行判别分布的相似性，交叉熵公式如下图所示：</p>
<p>$H(p, q) :=-\sum_{i} p_{i} \log q_{i}$</p>
<p><code>Tips:公式中的pi和qi为真实的样本分布和生成器的样本分布。</code></p>
<p>在当前模型的情况下，判别器为一个二分类问题，因此可以对基本交叉熵进行更具体地展开：</p>
<p><img src="https://pic2.zhimg.com/80/v2-b3442ba7058c07d82a17f6a6478ed569_hd.jpg" alt="img"></p>
<p><code>Tips: 其中，假定y1为正确样本分布，那么对应的(1-y1))就是生成样本的分布。D表示判别器，则D(x1)表示判别样本为正确的概率，(1-D(x1)))则对应着判别为错误样本的概率。这里仅仅是对当前情况下的交叉熵损失的具体化。相信大家也还是比较熟悉。</code></p>
<p>将上式推广到N个样本后，将N个样本相加得到对应的公式如下：</p>
<p><img src="https://pic4.zhimg.com/80/v2-a69772e79f153fd05748d4d1f4b0caef_hd.jpg" alt="img"></p>
<p>下面加入GAN中特殊的地方：</p>
<p><strong>对于GAN中的样本点 <img src="https://www.zhihu.com/equation?tex=x_i" alt="[公式]"> ，对应于两个出处，要么来自于真实样本，要么来自于生成器生成的样本</strong> <img src="https://www.zhihu.com/equation?tex=%5Cwidetilde+x" alt="[公式]"> ~ <img src="https://www.zhihu.com/equation?tex=G%28z%29" alt="[公式]"> ( 这里的 <img src="https://www.zhihu.com/equation?tex=z" alt="[公式]"> 是服从于投到生成器中噪声的分布)。</p>
<p>其中，对于来自于真实的样本，我们要判别为正确的分布 <img src="https://www.zhihu.com/equation?tex=y_i" alt="[公式]"> 。来自于生成的样本我们要判别其为错误分布（ <img src="https://www.zhihu.com/equation?tex=1+-+y_i" alt="[公式]"> ）。将上面式子进一步使用概率分布的期望形式写出（为了表达无限的样本情况，相当于无限样本求和情况），并且让 <img src="https://www.zhihu.com/equation?tex=y_i" alt="[公式]"> 为 1/2 且使用 <img src="https://www.zhihu.com/equation?tex=G%28z%29" alt="[公式]"> 表示生成样本可以得到如下图8的公式：</p>
<p><img src="https://pic2.zhimg.com/80/v2-be9ca3874041e3e820cb228851b7eef9_hd.jpg" alt="img"></p>
<p>实际上就是原本的 <img src="https://www.zhihu.com/equation?tex=%5Cmin+%5Climits_G+%5Cmax+%5Climits_D" alt="[公式]"> 公式，发现他们是不是其实就是同一个东西呢！:-D</p>
<p><img src="https://pic2.zhimg.com/80/v2-8ae44c8e2e7f740300055c8944cd2281_hd.jpg" alt="img"></p>
<ul>
<li><p>这里的 <img src="https://www.zhihu.com/equation?tex=V%28G%2C+D%29" alt="[公式]">相当于表示真实样本和生成样本的差异程度。</p>
</li>
<li><p>先看 <img src="https://www.zhihu.com/equation?tex=%5Cmax+%5Climits_DV%28D%2C+G%29" alt="[公式]"> 。这里的意思是固定生成器G，尽可能地让判别器能够最大化地判别出样本来自于真实数据还是生成的数据。</p>
</li>
<li><p>再将后面部分看成一个整体令 <img src="https://www.zhihu.com/equation?tex=L" alt="[公式]"> = <img src="https://www.zhihu.com/equation?tex=%5Cmax+%5Climits_DV%28D%2C+G%29" alt="[公式]"> ，看 <img src="https://www.zhihu.com/equation?tex=%5Cmin+%5Climits_G+L" alt="[公式]">，这里是在固定判别器D的条件下得到生成器G，这个G要求能够最小化真实样本与生成样本的差异。</p>
</li>
<li><p>通过上述min max的博弈过程，理想情况下会收敛于生成分布拟合于真实分布。</p>
</li>
</ul>
<h3 id="DCGAN"><a href="#DCGAN" class="headerlink" title="DCGAN"></a>DCGAN</h3><p>对现行CNN架构三个改进的学习和纠正</p>
<ul>
<li><p>所有的卷积网络，凡是自卷积开始，使用了确定性pooling函数的，都能学习到自己空间上的降采样。我们在生成器中使用了这种方法，允许生成器学习到它自己的空间降采样，也包括判别器</p>
</li>
<li><p>消除卷积特征顶部的全连接层：全局pooling增强了模型的稳定性，但减缓了收敛速度。将最该层的卷积特征和输入连接起来，生成器和判别器各自做自己的输出。</p>
</li>
<li><p>不使用BN。将每一层的输入都正则化为期望0方差1。改进了训练问题，也缓解了深层网络中的梯度溢出问题。但实际上，在这种方法在深层的生成器中被证明是不适用的，它会导致生成器反复震荡生成单点数据，这在GANs中往往是失败的。对于直接将BN使用在所有层上的方法，同样会引起震荡并导致模型不稳定，所以，不要再生成器的输入层上使用BN，也不要在判别器的输出层上使用BN</p>
</li>
</ul>
<p>DCGAN的架构指导：</p>
<ul>
<li>在判别器中，使用带步长的卷积层来替换所有pooling层，生成器中使用小步长卷积来代替pooling层</li>
<li>在生成器和判别器中使用BN（有效的使数据服从某个固定的数据分布）</li>
<li>去除深度架构中的全连接层（因为全连接层的参数过多，容易使网络过拟合）</li>
<li>生成器中，除去最后一层使用Tanh，每一层都使用ReLU来激活（因为发现有边界的激活函数可以让模型更快的学习，并且能快速的覆盖彩色空间）</li>
<li>判别器中，每一层都用LeakReLU来激活（激活函数的作用是为了在神经网络中进行非线性变换，在DCGAN中，生成器和判别器使用不同的激活函数。）</li>
</ul>
<p><img src="https://pic4.zhimg.com/v2-f6ce32e325de1f56fe06811de767084c_1200x500.jpg" alt="ä¸æçæGANæ¼è¿å¾è°±"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://woojoo520.github.io/2019/09/10/LeetCode-Day26/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mariana">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Celery Fairy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/10/LeetCode-Day26/" itemprop="url">LeetCode-Day26</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-10T19:01:20+08:00">
                2019-09-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="164-最大间距"><a href="#164-最大间距" class="headerlink" title="164. 最大间距"></a>164. 最大间距</h3><p>给定一个无序的数组，找出数组在排序之后，相邻元素之间最大的差值。</p>
<p>如果数组元素个数小于 2，则返回 0。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,6,9,1]</span><br><span class="line">输出: 3</span><br><span class="line">解释: 排序后的数组是 [1,3,6,9], 其中相邻元素 (3,6) 和 (6,9) 之间都存在最大差值 3。</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [10]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 数组元素个数小于 2，因此返回 0。</span><br></pre></td></tr></table></figure>

<p>说明:</p>
<p>你可以假设数组中所有元素都是非负整数，且数值在 32 位有符号整数范围内。<br>请尝试在线性时间复杂度和空间复杂度的条件下解决此问题。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 保存最大位数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxbit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> d = <span class="number">1</span>, p = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(nums[i] &gt;= p) &#123;</span><br><span class="line">                d++;</span><br><span class="line">                p *= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 基数排序</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> d = maxbit(nums, n);</span><br><span class="line">        <span class="keyword">int</span> size = nums.size();</span><br><span class="line">        <span class="keyword">int</span> temp[size];</span><br><span class="line">        <span class="keyword">int</span> count[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> radix = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 进行d次排序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; d;i++) &#123;</span><br><span class="line">            <span class="comment">// 每次排序前清空计算器</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">10</span>;j++) &#123;</span><br><span class="line">                count[j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 统计每个桶中的计数器</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j++) &#123;</span><br><span class="line">                count[(nums[j] / radix) % <span class="number">10</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将temp中的位置一次分配给每个桶</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; <span class="number">10</span>;j++) &#123;</span><br><span class="line">                count[j] += count[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 先按照个位上的数字大小放到相应的桶中，注意这边是倒着来的！！</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = n - <span class="number">1</span>;j &gt;= <span class="number">0</span>;j--) &#123;</span><br><span class="line">                temp[--count[(nums[j] / radix) % <span class="number">10</span>]] = nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 收集数据</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j++) &#123;</span><br><span class="line">                nums[j] = temp[j];</span><br><span class="line">            &#125;</span><br><span class="line">            radix *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumGap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        radixSort(nums, nums.size());</span><br><span class="line">        <span class="keyword">int</span> maxGap = nums[<span class="number">1</span>] - nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; nums.size();i++) &#123;</span><br><span class="line">            maxGap = max(maxGap, nums[i] - nums[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxGap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>解释：这里采用的是<strong>桶排序</strong>（<strong>基数排序</strong>）</p>
<h4 id="基数排序详解："><a href="#基数排序详解：" class="headerlink" title="基数排序详解："></a>基数排序详解：</h4><p>假设我们有输入数组A {53, 3, 542, 748, 14, 214, 154, 63, 616}. 这里数组位数比较小，所以我们采用LSD 的基数排序。</p>
<p> 我们这里先在数位较短的数前面的位数上补上零，比如53补上至053，3补上至003，14补上至014，63补上至063。现在的数组表现形式为{053, 003, 542, 748, 014, 214, 154, 063, 616}。我们将它们放置至一个个单独的桶中。</p>
<p>现在我们首先按照“个位”上数字大小对数组中的数进行排序，排序后结果是{542, 053, 003, 063, 014, 214, 154, 616, 748}.</p>
<p>接着按照“十位”上数字大小对数组中的数进行排序，排序后结果是{003, 014, 214, 616, 542, 748, 053, 154, 063}.</p>
<p>最后按照“百位”上数字大小对数组中的数进行排序，排序后结果是{003, 014, 053, 063, 154, 214, 542, 616, 748}. 这也是我们的最终输出数组B。</p>
<p><img src="https://pic1.zhimg.com/v2-61e73d035ee3f330a60c615569f7b310_b.jpg" alt="img"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://woojoo520.github.io/2019/09/09/NAS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mariana">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Celery Fairy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/09/NAS/" itemprop="url">NAS</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-09T13:53:08+08:00">
                2019-09-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="NAS综述"><a href="#NAS综述" class="headerlink" title="NAS综述"></a>NAS综述</h2><h3 id="1-NAS综述"><a href="#1-NAS综述" class="headerlink" title="1.NAS综述"></a>1.NAS综述</h3><p>AutoML（automated machine learning）是模型选择、特征提取和超参数调优的一系列自动化方法，可以实现自动训练有价值的模型。</p>
<p>深度学习可以自动学习出有用的特征，脱离了对特征工程的依赖，在图像、语音等任务上取得了超越其他算法的结果。这种成功很大程度上得益于新神经网络结构的出现，如ResNet、Inception、DenseNet等。但设计出高性能的神经网络需要大量的专业知识与反复实验，成本极高，限制了神经网络在很多问题上的应用。神经结构搜索（Neural Architecture Search ，简称NAS）是<strong>一种自动设计神经网络的技术</strong>，可以通过算法根据样本集自动设计出高性能的网络结构，在某些任务上甚至可以媲美人类专家的水准，甚至发现某些人类之前未曾提出过的网络结构，这可以有效的降低神经网络的使用和实现成本。</p>
<p>NAS的<strong>原理</strong>是给定一个称为<strong>搜索空间</strong>的候选神经网络结构集合，用某种策略从中<strong>搜索出最优网络结构</strong>。神经网络结构的优劣即性能用某些指标如精度、速度来度量，称为<strong>性能评估</strong>。</p>
<p><img src="https://pic2.zhimg.com/80/v2-261f4e89d5c60e5d336052e7fc6d116d_hd.png" alt="img"></p>
<p>在搜索的每次迭代中，从<strong>搜索空间产生“样本”</strong>即得到一个神经网络结构，称为“子网络”。在<strong>训练样本集上训练子网络</strong>，然后<strong>在验证集上评估其性能</strong>。逐步优化网络结构，知道找到最优子结构。</p>
<p><strong>搜索空间</strong>、<strong>搜索策略</strong>、<strong>性能评估</strong>策略是<code>NAS算法</code>的核心要素。搜索空间定义了可以搜索的神经网络结构的集合，即解的空间。搜索策略定义了如何在搜索空间中寻找最有网络结构。性能评估策略定义了如何评估搜索出的网络结构的性能。对这些要素的不同实现得到了各种不同的NAS算法。</p>
<h3 id="空间"><a href="#空间" class="headerlink" title="空间"></a>空间</h3><p>搜索空间定义了NAS算法可以搜索的神经网络的类型，同时也定义了如何描述神经网络。神经网络所实现的计算可以抽象成一个无孤立节点的有向无环图（DAG），图的节点代表神经网络的层，边代表数据的流动。每个节点从其前驱节点（有边射入）接收数据，经过计算之后将数据输出到后续节点（有边射出）。理论上说，只要是无孤立节点的DAG，都是合法的神经网络结构。按照不同的尺度，神经网络的结构定义包含如下层次的信息：</p>
<ul>
<li><p><strong>网络的拓扑结构</strong></p>
<p>网络有多少个层，这些层的连接关系。从简单的图结构到任意的DAG也反映了整个神经网络结构的发展历程。最简单的神经网络是线性链式结构，其对应的图的每个节点最多只有一个前驱，一个后续，类似于数据结构中的链表。早期的全连接神经网络，卷积神经网络都是这种拓扑结构。Inception、ResNet、DenseNet中的节点允许有多个前驱，多个后续，从而形成了多分支、跨层连接结构，它们是更复杂的图。这些典型的拓扑结构如下图所示。</p>
<p><img src="https://pic3.zhimg.com/80/v2-0e574807c1ef41d73e80d67eb6dbe5d2_hd.png" alt="img"></p>
<p>在描述网络的拓扑结构时，一般采用前驱节点来定义，即定义每个节点的前驱节点，一旦该信息确定，则网络拓扑结构确定。</p>
</li>
<li><p><strong>每个层的类型。</strong></p>
<p>除了第一个层必须为输入层，最后一个层必须为输出之外，中间的层的类型是可选的，它们代表了各种不同的运算即层的类型。典型有<code>全连接，卷积，反卷积，空洞卷积，池化，激活函数</code>等。但这些层的组合使用一般要符合某些规则。</p>
</li>
<li><p><strong>每个层内部的超参数</strong></p>
<p><code>卷积层</code>的超参数有<code>卷积核的数量，卷积核的通道数，高度，宽度，水平方向的步长，垂直方向的步长</code>等。<code>全连接层</code>的超参数有<code>神经元的数量</code>。<code>激活函数层</code>的超参数有<code>激活函数的类型，函数的参数（如果有）</code>等。各种典型层的超参数如下表所示</p>
<p><img src="https://pic1.zhimg.com/80/v2-926c10c9ca9f9a5feff26ad0cd1b10f8_hd.png" alt="img"></p>
</li>
</ul>
<p>​        如果一个节点的前驱节点只有一个，则直接以前驱节点的输出值作为本节点的输入。如果<code>前驱节点有多个</code>，需要将前驱节点的值汇总后输入本节点，这里有两种策略：<strong>相加和拼接</strong>，前者的典型代表是<code>ResNet</code>，后者的典型代表是<code>DenseNet</code>。由于神经网络的层数不固定，每层的超参数数量也不固定，因此描述网络结构的参数是变长的。</p>
<p>​        为了提高搜索效率，有时候会<strong>对搜索空间进行限定或简化</strong>。在某些NAS实现中会<code>把网络切分成基本单元</code>（cell，或block），通过这些单元的堆叠形成更复杂的网络。基本单元由多个节点（神经网络的层）组成，它们在整个网络中重复出现多次，但具有不同的权重参数。另外一种做法是<strong>限定神经网络的整体拓扑结构</strong>，借鉴于人类设计神经网络的经验。这些做法虽然减少了NAS算法的计算量，但也限定了算法能够寻找的神经网络的类型。</p>
<p>​        由于描述神经网络结构的参数含有离散数据（如拓扑结构的定义，层的类型，层内的离散型超参数），因此<strong>网络结构搜索是一个离散优化问题</strong>。定义结构的参数数量一般比较大，因此<strong>属于高维优化问题</strong>。另外，对于该问题，<strong>算法不知道优化目标函数的具体形式</strong>（每种网络结构与该网络的性能的函数关系），因此属于<strong>黑盒优化</strong>问题。这些特点为NAS带来了巨大的挑战。</p>
<h3 id="搜索策略"><a href="#搜索策略" class="headerlink" title="搜索策略"></a>搜索策略</h3><p><strong>搜索策略定义了如何找到最优的网络结构</strong>，通常是一个<strong>迭代优化</strong>过程，<strong>本质上是超参数优化问题</strong>。目前已知的搜索方法有随机搜索，贝叶斯优化，遗传算法，强化学习，基于梯度的算法。其中强化学习，遗传学习，基于梯度的优化是目前的主流算法，也是本章介绍的重点。</p>
<h4 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h4><p>​        基于强化学习的NAS算法[4-6]将神经网络结构设计看作一个强化学习问题，学习得到一个产生网络结构的最优策略。这里的智能体是设计神经网络结构的算法，用于输出神经网络结构描述，强化学习算法使得生成的神经网络的性能最优化。为了用强化学习求解，可以<strong>将神经网络的设计看做一个动作序列</strong>，每次执行动作确定网络的一部分结构如层。神经网络在验证集上的性能值是强化学习中的奖励值。</p>
<p>​        由于神经网络的结构参数长度不固定，因此需要用一个可变长度的串描述网络结构，算法需要输出这种不定长的串。循环神经网络可以输出不固定长度是数据，因此可以用它来生成网络结构的描述，文献[2]提出的NAS采用了这种方案。</p>
<p>​        算法用一个称为<strong>控制器</strong>的<strong>循环神经网络</strong>生成描述子网络结构的串，从而确定子网络的结构。然后在训练集上训练子网络，在验证集上计算其精度值。以精度值作为反馈信号，采用策略梯度算法更新控制器网络的参数。在迭代时，控制器会以给予那些有更高精度值的神经网络以更高的概率值，从而确保策略函数能够输出最优网络结构。这一过程如下图所示。</p>
<p><img src="https://pic2.zhimg.com/80/v2-b4040b08e683800e815365184d6f6025_hd.png" alt="img"></p>
<p>​       算法的<strong>输出限定为分层的网络结构</strong>，第n个网络层以第n-1个网络层为基础。网络结构生成可抽象为<strong>序列生成问题</strong>，按层逐次预测网络结构。在RNN中，每5个输出值定义一个神经网络层。上一时刻的输出是本时刻的输入，确保RNN基于前面n-1层所有的结构信息来预测第n层的结构。<strong>RNN的输出层是softmax回归，根据它确定结构参数</strong>。对于卷积核高度，可以限定输出值为[ 1,3,5,7]四个数，RNN的softmax输出是取这4个数的概率值。</p>
<p>​        控制器每一时刻的输出包括：卷积核的数量，卷积核的高度，卷积核的宽度，卷积操作在水平方向的步长，卷积操作在垂直方向的步长。这一过程如下图所示</p>
<p><img src="https://pic4.zhimg.com/80/v2-6d1a397e485909024f33a6989cbd1ccb_hd.png" alt="img"></p>
<p>​         实现时考虑典型的网络结构。对于卷积核的数量，取值范围为[ 24,36,48,64]，卷积核的高度取值范围为[ 1,3,5,7]，卷积核宽度的取值范围与高度相同。卷积步长可以固定为1，也可以按照 [ 1,2,3]取值。</p>
<p>​        这里需要考虑的一个问题是<strong>何时终止预测</strong>，实现时限定了神经网络的层数，达到一定的层之后，停止输出。<strong>在训练过程中这个值会逐步增加</strong>。</p>
<p>​        控制器生成该描述串之后，接下来在训练集上训练该子网络，这里采用了<strong>REINFORCE算法</strong>。<strong>目标函数为子网络在验证集上的精度的数学期望</strong></p>
<p><img src="https://www.zhihu.com/equation?tex=L%28%5Ctheta+%29%3DE_%7B%5CDelta+%5Csim+p_%7B%5Ctheta+%28%5Ccdot+%29%7D%7D%5Cleft+%5B+R%28%5CDelta+%29+%5Cright+%5D" alt="[å¬å¼]"></p>
<p>其中 <img src="https://www.zhihu.com/equation?tex=%5Ctheta+" alt="[公式]"> 是控制器的参数， <img src="https://www.zhihu.com/equation?tex=%5CDelta+" alt="[公式]"> 是子网络， <img src="https://www.zhihu.com/equation?tex=P_%7B%5Ctheta+%7D%28%5CDelta+%29" alt="[公式]"> 是控制器输出的子网络所服从的概率分布， <img src="https://www.zhihu.com/equation?tex=R%28%5CDelta+%29" alt="[公式]"> 是子网络在验证集上的精度值。<strong>直观的目标是某种结构的子网络准确率越高，则控制器生成该网络结构的概率越大</strong>。因此可以按照下式计算控制器的参数</p>
<p><img src="https://www.zhihu.com/equation?tex=%5Cbigtriangledown+_%7B%5Ctheta+%7DL%28%5Ctheta+%29%3D+%5Csum_%7B1%7D%5E%7BT%7DE_%7Bp%28a_%7B1%3AT%7D%3B%5Ctheta+%29%7D%5Cleft+%5B+%5Cbigtriangledown+_%7B%5Ctheta+%7D%5Cln+p%28a_%7Bt%7D%5Cmid+a_%7Bt-1%3A1%7D%3B%5Ctheta+%29+R%5Cright+%5D" alt="[公式]"></p>
<p>其中R为子网络的准确率，p为生成该子网络结构的概率。实现时使用采样来近似数学期望值<br>  <img src="https://www.zhihu.com/equation?tex=%5Cfrac%7B1%7D%7Bm%7D%5Csum_%7Bk%3D1%7D%5E%7Bm%7D%5Csum_%7Bt%3D1%7D%5E%7BT%7D%5Cbigtriangledown+_%7B%5Ctheta+%7D%5Cln+p%28a_%7Bt%7D%5Cmid+a_%7Bt-1%3A1%7D%3B%5Ctheta+%29R_%7Bk%7D" alt="[公式]"></p>
<p>其中m为mini-batch的样本数，T为神经网络的层数。为了解决REINFORCE算法计算出的梯度值偏差问题，在计算梯度时减掉了均值b</p>
<p><img src="https://www.zhihu.com/equation?tex=%5Cfrac%7B1%7D%7Bm%7D%5Csum_%7Bk%3D1%7D%5E%7Bm%7D%5Csum_%7Bt%3D1%7D%5E%7BT%7D%5Cbigtriangledown+_%7B%5Ctheta+%7D%5Cln+p%28a_%7Bt%7D%5Cmid+a_%7Bt-1%3A1%7D%3B%5Ctheta+%29%28R_%7Bk%7D-b%29" alt="[公式]"></p>
<p>其中b为所有奖励的均值。前面介绍的方法只能生成标准的线性结构网络，通过改进可以生成跨层连接的卷积神经网络以及循环神经网络，通过在控制器softmax输出中增加相关信息而实现。</p>
<p>​       文献[2]奠定了用强化学习解决NAS问题的基础，但面临计算量大的问题。一种解决方案是对搜索空间进行简化，限定网络结构为某些类型。回顾卷积网络的发展历史，<strong>各种典型卷积神经网络一般都具有某些重复、规整的结构</strong>，如ResNet中的跨层连接块，GoogLeNet中的Inception块等。<strong>如果能预测出这种基本块结构，然后将其堆叠形成网络，既可以降低搜索成本，又能使得网络随着输入数据的尺寸动态扩展，对于大尺寸的输入图像，只需要增加堆叠的块数即可。</strong></p>
<p>​        文献[3]采用了这种思想，提出了一种称为NASNet的方法。NASNet预测出基本块（building block），在小规模的CIFAR-10数据集上训练，然后将学习得到的网络结构迁移到更大规模的ImageNet数据集上。<strong>控制器预测的是基本两种网络单元，分别称为普通单元（Normal Cell）和约简单元（Reduction Cell）</strong>。前者不改变输入图像的尺寸，后者将图像的高度和宽度减半。根据这种设计，<strong>搜索整个神经网络结构的任务被简化为搜索最优基本块结构</strong>。除了降低搜索空间的大小，这种做法还使得在一个数据集上搜索得到的网络结构更容易泛化到其他数据集上。</p>
<p>​        完整的神经网络通过这些相同结构的基本单元堆叠形成，但各个基本单元有不同的权重参数。对于不同尺寸和规模的数据集，使用了不同数量的基本块。下图为用于CIFAR-10和ImageNet数据集的网络结构。</p>
<p><img src="https://pic3.zhimg.com/80/v2-3f15a91ff3431a49e87c4b515e326d46_hd.png" alt="img"></p>
<p>​       上图中的乘以N表示这种基本块堆叠N次。<strong>算法的核心是如何生成基本块</strong>。控制器网络用RNN实现，其输出层为softmax，用于生成描述神经网络结构的决策。每个基本单元由B个块构成，每个块有两个输入，执行某一运算后产生输出。下图为生成每个块的方法，包含5个步骤：</p>
<ul>
<li>选择一个隐含状态作为第一个输入</li>
<li>选择一个隐含状态作为第二个输入</li>
<li>为第一个隐含状态选择一个运算</li>
<li>为第二个隐含状态选择一个运算</li>
<li>为两个运算的结果选择一个合并方式，执行合并</li>
</ul>
<p>隐含状态即神经网络前面的层的输出结果，如CNN中的卷积特征图像，或RNN中的隐含状态。然后对两个输入各选择一个运算，再将两个运算的结果合并。这一过程如下图所示。</p>
<p><img src="https://pic1.zhimg.com/80/v2-cb5e1634ec0e10ff10b3c64801f39a1c_hd.png" alt="img"></p>
<p>作用于隐含状态上的<strong>运算包括各种卷积，池化等操作</strong>。<strong>运算结果的合并方式有相加，拼接两种选择</strong>。</p>
<p>下图为生成一个基本单元的过程。图中上方为候选隐含状态集合，第1次选择H1和H2作为输入，分别执行池化和卷积运算，然后相加，得到H3，并将其加入候选隐含状态集合。接下来生成第2个块，选择H2和H3作为输入，分布执行卷积和恒等运算，将结果进行拼接，产生H4。其他的以此类推。在这里B的值由人工设定。</p>
<p><img src="https://pic4.zhimg.com/80/v2-57e5e32c98acc4675afc6c45a79584d7_hd.png" alt="img"></p>
<p>下图是典型的约简块，同样的B=4，这里将4个临时结果拼接，形成 <img src="https://www.zhihu.com/equation?tex=h_%7Bt%7D" alt="[公式]"> 作为本单元的输出值。</p>
<p><img src="https://pic1.zhimg.com/80/v2-9457ff0a3ac4a0d9f262616f6d7ece08_hd.png" alt="img"></p>
<p>​       在生成网络结构描述之后，训练子网络和控制器网络的方法与文献[2]相同，不同的是策略梯度算法采用了<strong>PPO算法</strong>（Proximal Policy Optimization）。</p>
<p>​        NASNet虽然在速度上有提升，但计算量还是太大。作为这一系列方法的改进，文献[4]提出了一种称为ENAS（Efficient Neural Architecture Search）的算法，<strong>通过在各个网络之间共享权重来减少计算量</strong>。由于各个子网络共享权重，因此每个子网络不需要从头开始训练，这极大的提高了搜索速度。</p>
<p>​        ENAS将NAS看做是寻找最优子图的问题，问题的解是一张大的图的子图。图23-1展示了这一概念。在这种图表示中，图的顶点为某种计算（如卷积，池化，相加），边表示数据的流动。下图的图有6个顶点，<strong>任意两个节点之间都可能有边连接，但边的方向只能是从编号较小的节点指向编号较大的节点，以防止环的出现</strong>。各个顶点可以对应于神经网络中的层，数据只能从编号小的层流向编号大的层。这个图的最优子图包含全部6个顶点，边为图中红色的边。</p>
<p><img src="https://pic2.zhimg.com/80/v2-fb009a576bba7f77afd1b012672892a9_hd.png" alt="img"></p>
<p>​       使用这种表示，可以将NAS限定为在一个固定顶点数的图中寻找最优子图。神经网络的结构描述同样由RNN实现的控制器生成。对于卷积神经网络和循环神经网络采用了不同的描述，控制器生成这两种神经网络单元的方法也不同，下面分别介绍。</p>
<p>​        循环神经网络中可以选择的操作为激活函数，包括ReLU和tanh两种类型。下图为一个子图以及对应的循环神经网络。</p>
<p><img src="https://pic3.zhimg.com/80/v2-d937276289ee331c8315dab46fac8e16_hd.png" alt="img"></p>
<p>该图有4个顶点，红色的边表示信息的流动，黑色的边无效即没有使用。右图为对应的循环神经网络单元，运算节点的编号与左图中图的顶点编号对应。节点1接收 <img src="https://www.zhihu.com/equation?tex=x_%7Bt%7D" alt="[公式]"> 和 <img src="https://www.zhihu.com/equation?tex=h_%7Bt-1%7D" alt="[公式]"> 作为输入，执行下面的运算</p>
<p><img src="https://www.zhihu.com/equation?tex=h_%7B1%7D%3Dtanh%28x_%7Bt%7D%5Ccdot+W%5E%7B%28x%29%7D%2Bh_%7Bt-1%7D%5Ccdot+W_%7B1%7D%5E%7B%28h%29%7D%29" alt="[公式]"></p>
<p>这里的激活函数选用tanh，权重矩阵为本节点的参数。节点2以节点1的输出值为输入，选择ReLU作为激活函数，执行下面的运算</p>
<p><img src="https://www.zhihu.com/equation?tex=h_%7B2%7D%3DReLU%28h_%7B1%7D%5Ccdot+W_%7B2%2C1%7D%5E%7B%28h%29%7D%29" alt="[公式]"></p>
<p>该节点同样有权重矩阵。节点3以节点2的输出值为输入，选择ReLU作为激活函数，执行下面的运算</p>
<p><img src="https://www.zhihu.com/equation?tex=h_%7B3%7D%3DReLU%28h_%7B2%7D%5Ccdot+W_%7B3%2C2%7D%5E%7B%28h%29%7D%29" alt="[公式]"></p>
<p>节点4以节点1的输出值作为输入，选择tanh作为激活函数，执行下面运算</p>
<p><img src="https://www.zhihu.com/equation?tex=h_%7B4%7D%3DReLU%28h_%7B1%7D%5Ccdot+W_%7B4%2C1%7D%5E%7B%28h%29%7D%29" alt="[公式]"></p>
<p>节点3和4没有后续节点，因此根据它们计算输出值。输出值为它们的均值</p>
<p><img src="https://www.zhihu.com/equation?tex=h_%7Bt%7D%3D%28h_%7B3%7D%2Bh_%7B4%7D%29%2F2" alt="[公式]"></p>
<p>对每个 <img src="https://www.zhihu.com/equation?tex=j%3C+l" alt="[公式]"> 的节点对，<strong>都有一个独立的权重矩阵</strong> <img src="https://www.zhihu.com/equation?tex=W_%7Bl%2Cj%7D%5E%7B%28h%29%7D" alt="[公式]"> ，<strong>为每个节点l一旦确定其前驱节点j，则使用该矩阵</strong>。在ENAS中，所有循环单元共用一组相同的权重参数。</p>
<p>​       下面介绍控制器如何生成该网络结构。控制器在每次预测时需要做两个决策：确定以哪个节点的输出值作为输入即作为当前节点的前驱，为当前节点选用哪种激活函数。对于第1个节点，输入值是确定的，为 <img src="https://www.zhihu.com/equation?tex=x_%7Bt%7D" alt="[公式]"> 和 <img src="https://www.zhihu.com/equation?tex=h_%7Bt-1%7D" alt="[公式]"> ，控制器只用为其选择激活函数。接下来生成节点2，首先选择一个节点作为输入即作为节点2的前驱节点，然后为节点2选择激活函数。其他节点依次类推，这一过程如下图所示。</p>
<p><img src="https://pic4.zhimg.com/80/v2-b0153571a7b252d0ebf1ca80445ee8d3_hd.png" alt="img"></p>
<p>​       假设循环神经网络的单元有N个节点，在生成第i个节点时，可以选择的前驱节点为[0,i-1]之间的整数，有i种情况，因此网络的拓扑结构有N!种。对于每种网络拓扑，每个节点的激活函数有4种选择，分别为tanh，sigmoid，identity，ReLU。因此可以搜索的网络结构总共有 <img src="https://www.zhihu.com/equation?tex=4%5E%7BN%7D%5Ctimes+N%21" alt="[公式]"> 种情况。</p>
<p>​        下面介绍卷积神经网络的生成方式。下图给4个节点的卷积神经网络，同样的，红色的边表示有效边，黑色的未激活。这个图对应的网络结构如右图所示。</p>
<p><img src="https://pic2.zhimg.com/80/v2-25b74be6615d7c472de50487c0729a01_hd.png" alt="img"></p>
<pre><code>与循环神经网络不同的是，**这里每个节点可以允许有多个前驱节点**。例如节点3有两个前驱，分别为1和2。</code></pre><p>​        生成卷积神经网络结构的方法与循环神经网络类似：为当前节点选择前驱节点，为当前节点选择要使用的运算。这两个决策结果形成卷积神经网络的一个层。这一过程如上图所示。</p>
<p>​        <strong>对于第k层，小于等于k-1的不同层都可以用来作为它的输入</strong>，因此有 <img src="https://www.zhihu.com/equation?tex=2%5E%7Bk-1%7D" alt="[公式]"> 种连接关系。对于上图中的卷积神经网络，在k=4时选择{1,3}作为它的前驱，导致第1、3个层都与第4个层连接。这种做法可以形成任意的跨层连接。</p>
<p>​        在每个节点处允许的运算有6种情况，分别是： <img src="https://www.zhihu.com/equation?tex=3%5Ctimes+3" alt="[公式]"> 卷积， <img src="https://www.zhihu.com/equation?tex=5%5Ctimes+5" alt="[公式]"> 卷积， <img src="https://www.zhihu.com/equation?tex=3%5Ctimes+3" alt="[公式]"> 深度可分离卷积， <img src="https://www.zhihu.com/equation?tex=5%5Ctimes+5" alt="[公式]"> 深度可分离卷积， <img src="https://www.zhihu.com/equation?tex=3%5Ctimes+3" alt="[公式]"> 均值池化， <img src="https://www.zhihu.com/equation?tex=3%5Ctimes+3" alt="[公式]"> 最大值池化。与循环神经网络相同，每个节点处都有所有运算的参数，并被所有网络结构共享。生成卷积神经网络结构的过程如下图所示。</p>
<p><img src="https://pic1.zhimg.com/80/v2-1b54654c641c486000a35ab5a1eb4abc_hd.png" alt="img"></p>
<p>如果一个卷积神经网络有L个层，则在第k层处有 <img src="https://www.zhihu.com/equation?tex=2%5E%7Bk-1%7D" alt="[公式]"> 种连接关系，由于各个层之间的连接关系是单独确定即相互独立的，因此网络的连接关系及拓扑结构有</p>
<p><img src="https://www.zhihu.com/equation?tex=2%5E%7B1%2B2%2B...%2BL-1%7D%3D2%5E%7BL%28L-1%29%2F2%7D" alt="[公式]"></p>
<p>种情况，对于每种网络结构，在每个层有6种可供选择的运算，因此所有可能的网络结构有</p>
<p><img src="https://www.zhihu.com/equation?tex=6%5E%7BL%7D%5Ctimes+2%5E%7BL%28L-1%29%2F2%7D" alt="[公式]"></p>
<p>种情况。如果L=12，则所有可能的网络结构数为 <img src="https://www.zhihu.com/equation?tex=1.6%5Ctimes+10%5E%7B29%7D" alt="[公式]">。</p>
<p>​        除了生成整个卷积网络，还可以生成卷积网络额单元然后将其堆叠形成完整的网络，具体做法与NASNet类似，不再重复介绍。</p>
<p>​        生成网络结构之后，接下来的核心任务是训练子网络和控制器网络。假设控制器网络的参数为 <img src="https://www.zhihu.com/equation?tex=%5Ctheta" alt="[公式]"> ，子网络的参数为W，后者被所有子网络共享。这两组参数交替训练，在每次迭代时分两个阶段，首先训练W，然后训练 <img src="https://www.zhihu.com/equation?tex=%5Ctheta" alt="[公式]"> 。</p>
<p>​        <strong>第一阶段先固定住控制器的参数</strong>，控制器的输出策略为 <img src="https://www.zhihu.com/equation?tex=%5Cpi+%28m%3B%5Ctheta+%29" alt="[公式]">，<strong>从中采样出网络结构</strong>。以交叉熵作为损失函数，计算损失函数对w的梯度并更新。<strong>第二阶段固定住w</strong>，用 REINFORCE算法更新控制器的参数 <img src="https://www.zhihu.com/equation?tex=%5Ctheta" alt="[公式]"> ，<strong>最大化奖励值的数学期望</strong></p>
<p><img src="https://www.zhihu.com/equation?tex=E_%7Bm-%5Cpi+%28m%3B%5Ctheta+%29%7D%5Cleft+%5B+R%28m%2Cw%29+%5Cright+%5D" alt="[公式]"></p>
<p>奖励值 <img src="https://www.zhihu.com/equation?tex=R%28m%2Cw%29" alt="[公式]"> 为子网络m在验证集上的<strong>精度值</strong>。训练完成之后，根据控制器的策略 <img src="https://www.zhihu.com/equation?tex=%5Cpi+%28m%3B%5Ctheta+%29" alt="[公式]"> 采样出多个子网络并训练，计算它们在验证集上的表现，选择表现最好的网络作为最终生成的网络。</p>
<p>​        除上述方法之外，用强化学习实现NAS还有其他方案，具体可以阅读参考文献[11-13]。</p>
<h3 id="性能评估策略"><a href="#性能评估策略" class="headerlink" title="性能评估策略"></a>性能评估策略</h3><p>​        对于搜索策略搜索出的神经网络结构，首先在一个训练集上训练，然后在验证集上测试精度值。训练和验证过程非常耗时，因此有必要采取措施以降低性能评估的成本。<strong>降低训练成本的简单做法有减少训练时间（迭代次数）</strong>，在训练样本的一个子集上进行训练，在低分辨率的图像上进行训练，或者在训练时减少某些层的卷积核的数量。这些做法在降低计算成本的同时可能会导致性能评估值的偏差。虽然搜索策略只需对各种网络结构的优劣进行排序，无需知道它们准确的性能指标，但这种近似可能还是会导致排序结果的偏差。</p>
<p>​        更复杂的做法是<strong>对神经网络的性能进行预测（外推），即通过训练时前面若干次迭代时的性能表现推断其最终的性能，或者用搜索出的单元（块）的特性预测整个网络的性能</strong>。<strong>权值共享</strong>也是一种方案。以之前训练过的子网络的权重作为当前要评估的子网络的初始权重可以有效的提高训练速度，加速收敛，避免从头开始训练。<strong>ENAS和DARTS则直接让各个子网络共享同一套权重参数</strong>。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://woojoo520.github.io/2019/09/09/LeetCode-Day25/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mariana">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Celery Fairy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/09/LeetCode-Day25/" itemprop="url">LeetCode-Day25</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-09T08:44:24+08:00">
                2019-09-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72. 编辑距离"></a>72. 编辑距离</h3><p>给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。</p>
<p>你可以对一个单词进行如下三种操作：</p>
<p>插入一个字符<br>删除一个字符<br>替换一个字符<br>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: word1 = &quot;horse&quot;, word2 = &quot;ros&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: </span><br><span class="line">horse -&gt; rorse (将 &apos;h&apos; 替换为 &apos;r&apos;)</span><br><span class="line">rorse -&gt; rose (删除 &apos;r&apos;)</span><br><span class="line">rose -&gt; ros (删除 &apos;e&apos;)</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: word1 = &quot;intention&quot;, word2 = &quot;execution&quot;</span><br><span class="line">输出: 5</span><br><span class="line">解释: </span><br><span class="line">intention -&gt; inention (删除 &apos;t&apos;)</span><br><span class="line">inention -&gt; enention (将 &apos;i&apos; 替换为 &apos;e&apos;)</span><br><span class="line">enention -&gt; exention (将 &apos;n&apos; 替换为 &apos;x&apos;)</span><br><span class="line">exention -&gt; exection (将 &apos;n&apos; 替换为 &apos;c&apos;)</span><br><span class="line">exection -&gt; execution (插入 &apos;u&apos;)</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>这是一个关于<strong>动态规划</strong>的问题</p>
<p>这里有一个<code>dp</code>二维数组，<code>dp[i][j]</code>表示的是<code>word1</code>从0到第<code>i</code>个位置与<code>word2</code>从0到第<code>j</code>个位置的编辑距离，那么就可以有动态规划的逻辑</p>
<p>当<code>word1</code>的第<code>i</code>个位置与<code>word2</code>的第<code>j</code>个位置相同的时候，<code>dp[i][j] = dp[i - 1][j - 1]</code>，否则：</p>
<p><code>dp[i][j] = min(dp[i - 1][j] + 1, min(dp[i][j - 1] + 1, dp[i - 1][j - 1] + 1))</code></p>
<p>这里比较烦恼的是dp数组的初始化问题，就是因为在这里发生了很多bug</p>
<p>正确的初始化方法（见code）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(word1.length() == <span class="number">0</span> || word2.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> max(word1.length(), word2.length());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len1 = word1.length(), len2 = word2.length();</span><br><span class="line">        <span class="keyword">int</span> dp[len1][len2];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = word1[<span class="number">0</span>] == word2[<span class="number">0</span>] ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">bool</span> flag = word1[<span class="number">0</span>] == word2[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; len2;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(word1[<span class="number">0</span>] == word2[i]) &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[<span class="number">0</span>][i] = flag ? i : i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        flag = word1[<span class="number">0</span>] == word2[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; len1;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(word1[i] == word2[<span class="number">0</span>]) &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][<span class="number">0</span>] = flag ? i : i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; len1;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; len2;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(word1[i] == word2[j]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = min(dp[i - <span class="number">1</span>][j <span class="number">-1</span>] + <span class="number">1</span>, min(dp[i - <span class="number">1</span>][j] + <span class="number">1</span>, dp[i][j - <span class="number">1</span>] + <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">return</span> dp[len1 - <span class="number">1</span>][len2 - <span class="number">1</span>];      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://woojoo520.github.io/2019/09/08/LeetCode-Day24/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mariana">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Celery Fairy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/08/LeetCode-Day24/" itemprop="url">LeetCode-Day24</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-08T09:32:14+08:00">
                2019-09-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148. 排序链表"></a>148. 排序链表</h3><p>在 $O(nlogn)$ 时间复杂度和常数级空间复杂度下，对链表进行排序。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 4-&gt;2-&gt;1-&gt;3</span><br><span class="line">输出: 1-&gt;2-&gt;3-&gt;4</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: -1-&gt;5-&gt;3-&gt;4-&gt;0</span><br><span class="line">输出: -1-&gt;0-&gt;3-&gt;4-&gt;5</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>因为<strong>时间复杂度</strong>是$O(nlogn)$，所以就会想到归并排序，但是<strong>常数级空间复杂度</strong>又限制了不能采用递归，因此：</p>
<p>定义了三个函数:</p>
<ul>
<li><p><code>ListNode* sortList(ListNode* head)</code>：用于进行归并排序</p>
</li>
<li><p><code>ListNode* cut(ListNode* head, int size)</code>： 用于拆分，从<code>head</code>节点开始，拆分<code>size</code>长度，即进行如下图的操作：</p>
<p>![img](file:///C:\Users\12751\Documents\Tencent Files\1275121799\Image\C2C{0BB96E9F-E75D-2FDE-2714-7A2DF391FC3B}.png)</p>
</li>
<li><p><code>ListNode* merge(ListNode* l1, ListNode* l2)</code>：应该是闭着眼睛都会写的，归并两个有序链表。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        ListNode* tempH = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        tempH-&gt;next = head;</span><br><span class="line">        ListNode* lenP = head;</span><br><span class="line">        <span class="keyword">while</span>(lenP) &#123;</span><br><span class="line">            length++;</span><br><span class="line">            lenP = lenP-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 先计算链表的总长度为length</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> size = <span class="number">1</span>;size &lt; length;size &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 总共进行logn次排序</span></span><br><span class="line">            ListNode* H = tempH;</span><br><span class="line">            ListNode* cur = H-&gt;next;</span><br><span class="line">            <span class="keyword">while</span>(H-&gt;next) &#123;</span><br><span class="line">                <span class="comment">// left表示l1, right表示l2，cur表示l2之后的一个节点 </span></span><br><span class="line">                ListNode* left = cur;</span><br><span class="line">                ListNode* right = cut(left, size);</span><br><span class="line">                cur = cut(right, size);</span><br><span class="line">                <span class="comment">// 进行归并操作</span></span><br><span class="line">                H-&gt;next = merge(left, right);</span><br><span class="line">                <span class="comment">// 将H挪到归并之后的前一段链表的尾节点</span></span><br><span class="line">                <span class="keyword">while</span>(H-&gt;next) &#123;</span><br><span class="line">                    H = H-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 将两段链表连接起来</span></span><br><span class="line">                H-&gt;next = cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tempH-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">cut</span><span class="params">(ListNode* head, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        ListNode* temp = head;</span><br><span class="line">        <span class="keyword">while</span>(--size &amp;&amp; temp)  &#123;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* last = temp;</span><br><span class="line">        <span class="keyword">if</span>(!temp) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">        last-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode* temp = head;</span><br><span class="line">        <span class="keyword">while</span>(l1 &amp;&amp; l2) &#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">                temp-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        temp-&gt;next = l1 ? l1 : l2;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>图解：</p>
<p><img src="https://pic.leetcode-cn.com/c1d5347aa56648afdec22372ee0ed13cf4c25347bd2bb9727b09327ce04360c2-Picture1.png" alt="Picture1.png"></p>
<h3 id="146-LRU缓存机制"><a href="#146-LRU缓存机制" class="headerlink" title="146. LRU缓存机制"></a>146. LRU缓存机制</h3><p>运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。</p>
<p>获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。<br>写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。</p>
<p>进阶:</p>
<p>你是否可以在 O(1) 时间复杂度内完成这两种操作？</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LRUCache cache = new LRUCache( 2 /* 缓存容量 */ );</span><br><span class="line"></span><br><span class="line">cache.put(1, 1);</span><br><span class="line">cache.put(2, 2);</span><br><span class="line">cache.get(1);       // 返回  1</span><br><span class="line">cache.put(3, 3);    // 该操作会使得密钥 2 作废</span><br><span class="line">cache.get(2);       // 返回 -1 (未找到)</span><br><span class="line">cache.put(4, 4);    // 该操作会使得密钥 1 作废</span><br><span class="line">cache.get(1);       // 返回 -1 (未找到)</span><br><span class="line">cache.get(3);       // 返回  3</span><br><span class="line">cache.get(4);       // 返回  4</span><br></pre></td></tr></table></figure>

<p><strong>思路详解：</strong></p>
<p>要让 put 和 get 方法的时间复杂度为 O(1)O(1)，我们可以总结出 cache 这个数据结构必要的条件：查找快，插入快，删除快，有顺序之分。</p>
<p>因为显然 cache 必须有顺序之分，以区分最近使用的和久未使用的数据；而且我们要在 cache 中查找键是否已存在；如果容量满了要删除最后一个数据；每次访问还要把数据插入到队头。</p>
<p>那么，什么数据结构同时符合上述条件呢？哈希表查找快，但是数据无固定顺序；链表有顺序之分，插入删除快，但是查找慢。所以结合一下，形成一种新的数据结构：哈希链表。</p>
<p>LRU 缓存算法的核心数据结构就是哈希链表，双向链表和哈希表的结合体。这个数据结构长这样：</p>
<p><img src="https://pic.leetcode-cn.com/9201fabe4dfdb5a874b43c325d39857182c8ec267f830649a52dda90a63d6671-file_1562356927818" alt="HashLinkedList"></p>
<p>思想很简单，就是借助哈希表赋予了链表快速查找的特性嘛：可以快速查找某个 key 是否存在缓存（链表）中，同时可以快速删除、添加节点。回想刚才的例子，这种数据结构是不是完美解决了 LRU 缓存的需求？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> cap;</span><br><span class="line">    <span class="comment">// 双链表： 装着(key, value)元组</span></span><br><span class="line">    <span class="built_in">list</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; cache;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">list</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;::iterator&gt; <span class="built_in">map</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LRUCache(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;cap = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = <span class="built_in">map</span>.find(key);</span><br><span class="line">        <span class="keyword">if</span>(it == <span class="built_in">map</span>.end()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; kv = *<span class="built_in">map</span>[key];</span><br><span class="line">        cache.erase(<span class="built_in">map</span>[key]);</span><br><span class="line">        cache.push_front(kv);</span><br><span class="line">        <span class="built_in">map</span>[key] = cache.begin();</span><br><span class="line">        <span class="keyword">return</span> kv.second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = <span class="built_in">map</span>.find(key);</span><br><span class="line">        <span class="keyword">if</span>(it == <span class="built_in">map</span>.end()) &#123;</span><br><span class="line">            <span class="comment">// key不存在，判断cache是否已满</span></span><br><span class="line">            <span class="keyword">if</span>(cache.size() == cap) &#123;</span><br><span class="line">                <span class="keyword">auto</span> lastPair = cache.back();</span><br><span class="line">                <span class="keyword">int</span> lastKey = lastPair.first;</span><br><span class="line">                <span class="built_in">map</span>.erase(lastKey);</span><br><span class="line">                cache.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            cache.push_front(make_pair(key, value));</span><br><span class="line">            <span class="built_in">map</span>[key] = cache.begin();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cache.erase(<span class="built_in">map</span>[key]);</span><br><span class="line">            cache.push_front(make_pair(key, value));</span><br><span class="line">            <span class="built_in">map</span>[key] = cache.begin();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="149-直线上最多的点数"><a href="#149-直线上最多的点数" class="headerlink" title="149. 直线上最多的点数"></a>149. 直线上最多的点数</h3><p>给定一个二维平面，平面上有 n 个点，求最多有多少个点在同一条直线上。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: [[1,1],[2,2],[3,3]]</span><br><span class="line">输出: 3</span><br><span class="line">解释:</span><br><span class="line">^</span><br><span class="line">|</span><br><span class="line">|        o</span><br><span class="line">|     o</span><br><span class="line">|  o  </span><br><span class="line">+-------------&gt;</span><br><span class="line">0  1  2  3  4</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入: [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]</span><br><span class="line">输出: 4</span><br><span class="line">解释:</span><br><span class="line">^</span><br><span class="line">|</span><br><span class="line">|  o</span><br><span class="line">|     o        o</span><br><span class="line">|        o</span><br><span class="line">|  o        o</span><br><span class="line">+-------------------&gt;</span><br><span class="line">0  1  2  3  4  5  6</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>针对每一个点，利用<strong>hashmap</strong>，然后遍历每一个点，计算斜率，利用<code>hashmap</code>检查该斜率是否已经出现过，然后更新<code>hashmap</code></p>
<p>这里需要注意的是精度问题！因为斜率计算的时候是double类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPoints</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(points.size() &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> points.size();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; points.size();i++) &#123;</span><br><span class="line">            mp.clear();</span><br><span class="line">            <span class="keyword">int</span> col = <span class="number">1</span>, tp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>;j &lt; points.size();j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> dely = points[j][<span class="number">1</span>] - points[i][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">int</span> delx = points[j][<span class="number">0</span>] - points[i][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">if</span>(delx == <span class="number">0</span> &amp;&amp; dely == <span class="number">0</span>)  &#123;</span><br><span class="line">                    col++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> gcd = __gcd(delx, dely);</span><br><span class="line">                dely = dely / gcd;</span><br><span class="line">                delx = delx / gcd;</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> hash = <span class="number">1l</span>l * delx * <span class="number">1000000</span> + dely;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; "hash = " &lt;&lt; hash &lt;&lt; endl; </span></span><br><span class="line">                <span class="keyword">if</span>(mp.count(hash) == <span class="number">0</span>) &#123;</span><br><span class="line">                    mp[hash] = <span class="number">1</span>;</span><br><span class="line">                    tp = max(tp, mp[hash]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mp[hash]++;</span><br><span class="line">                    tp = max(tp, mp[hash]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = max(ans, tp + col);</span><br><span class="line">            <span class="comment">// cout &lt;&lt; "ans = " &lt;&lt; ans &lt;&lt; endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="152-乘积最大子序列"><a href="#152-乘积最大子序列" class="headerlink" title="152. 乘积最大子序列"></a>152. 乘积最大子序列</h3><p>给定一个整数数组 nums ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,3,-2,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 子数组 [2,3] 有最大乘积 6。</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [-2,0,-1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。</span><br></pre></td></tr></table></figure>

<p>思路：这里还是才有用动态规划的思路，但是需要注意，仅仅用一个dp是不够的，因为你可能遇到的是如下数据：</p>
<p><code>[-2,3,-4]</code></p>
<p>如果只有一个<code>dp[]</code>，则你记录下的<code>dp[]</code>的值为<code>[-2,3,3]</code></p>
<p>因为忽略了负数乘以负数得到最大值的情形，，因此下面的方法记录了两个<code>dp</code>数组，分别是<code>dpmin[]</code>,<code>dpmax</code>，这样，就可以顺利解决刚刚的bug了。</p>
<p>Code如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">int</span> ans = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dpmax(nums.size(), <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dpmin(nums.size(), <span class="number">0</span>);</span><br><span class="line">        dpmax[<span class="number">0</span>] = ans;</span><br><span class="line">        dpmin[<span class="number">0</span>] = ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; nums.size();i++) &#123;</span><br><span class="line">            dpmax[i] = max(dpmax[i - <span class="number">1</span>] * nums[i], max(dpmin[i - <span class="number">1</span>] * nums[i], nums[i]));</span><br><span class="line">            dpmin[i] = min(dpmin[i - <span class="number">1</span>] * nums[i], min(dpmax[i - <span class="number">1</span>] * nums[i], nums[i]));</span><br><span class="line">            ans = max(ans, dpmax[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155. 最小栈"></a>155. 最小栈</h3><p>设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。</p>
<p>push(x) – 将元素 x 推入栈中。<br>pop() – 删除栈顶的元素。<br>top() – 获取栈顶元素。<br>getMin() – 检索栈中的最小元素。<br>示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MinStack minStack = new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.getMin();   --&gt; 返回 -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; 返回 0.</span><br><span class="line">minStack.getMin();   --&gt; 返回 -2.</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>一般来说，为了做到提取最小值，一般采用的是$O(n)$的做法，但是，为了做到$O(1)$的解法，我们可以有以下思路：</p>
<p>就是在每一次push的时候push两个值，一个是当前的<code>x</code>，另一个是<code>当前的最小值</code>，而push进去的最小值只需要在之前的最小值和x之间选择较小的一个即可。pop的时候同理，每次pop两个元素。而这样在去的最小值的时候，可以直接取栈顶元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    <span class="keyword">int</span> nums[<span class="number">20000</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    MinStack() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        nums[++index] = x;</span><br><span class="line">        <span class="keyword">if</span>(index == <span class="number">0</span>) &#123;</span><br><span class="line">            nums[++index] = x; </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nums[++index] = min(x, nums[index - <span class="number">1</span>]);   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        index -= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nums[index - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nums[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://woojoo520.github.io/2019/09/07/Excel操作之添加数据透视图/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mariana">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Celery Fairy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/07/Excel操作之添加数据透视图/" itemprop="url">Excel操作之添加数据透视图</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-07T13:15:18+08:00">
                2019-09-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Excel操作之添加数据透视图"><a href="#Excel操作之添加数据透视图" class="headerlink" title="Excel操作之添加数据透视图"></a>Excel操作之添加数据透视图</h2><h4 id="First-step"><a href="#First-step" class="headerlink" title="First step:"></a>First step:</h4><p>先通过筛选，将<code>face</code>和<code>Re-ID</code>数据分离</p>
<p><img src="C:%5CUsers%5C12751%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1567832801786.png" alt="1567832801786"></p>
<h4 id="Second-Step"><a href="#Second-Step" class="headerlink" title="Second Step:"></a>Second Step:</h4><p><code>Alt+d</code>，然后按<code>p</code>，会出现<code>数据透视图向导</code>，如图：</p>
<p><img src="C:%5CUsers%5C12751%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1567832720855.png" alt="1567832720855"></p>
<p>然后选择区域：</p>
<p><img src="C:%5CUsers%5C12751%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1567832861918.png" alt="1567832861918"></p>
<h4 id="Third-Step："><a href="#Third-Step：" class="headerlink" title="Third Step："></a>Third Step：</h4><p>然后如图操作：</p>
<p><img src="C:%5CUsers%5C12751%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1567832942797.png" alt="1567832942797"></p>
<p>第二步：将Direction拖入$\sum$值中</p>
<p><img src="C:%5CUsers%5C12751%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1567833050205.png" alt="1567833050205"></p>
<p>然后，数据就统计完毕了</p>
<p>![1567833074081](E:\Study\Machine Learning\实验室论文整理\1567833074081.png)</p>
<h4 id="Fourth-Step："><a href="#Fourth-Step：" class="headerlink" title="Fourth Step："></a>Fourth Step：</h4><p>最后选中数据区域，直接插入饼状图即可。</p>
<p><img src="C:%5CUsers%5C12751%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1567833164535.png" alt="1567833164535"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Mariana</p>
              <p class="site-description motion-element" itemprop="description">a study blog</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">102</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mariana</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
