<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="a study blog">
<meta property="og:type" content="website">
<meta property="og:title" content="Celery Fairy">
<meta property="og:url" content="https://woojoo520.github.io/page/2/index.html">
<meta property="og:site_name" content="Celery Fairy">
<meta property="og:description" content="a study blog">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Celery Fairy">
<meta name="twitter:description" content="a study blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://woojoo520.github.io/page/2/">





  <title>Celery Fairy</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <a href="https://github.com/woojoo520" class="github-corner" aria-label="View source on GitHub">
      <svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/>
      </svg>
    </a>
    <style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Celery Fairy</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Celery's Blog</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://woojoo520.github.io/2019/09/30/LeetCode-Day42/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mariana">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Celery Fairy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/30/LeetCode-Day42/" itemprop="url">LeetCode-Day42</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-30T14:34:57+08:00">
                2019-09-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="背包问题的详解"><a href="#背包问题的详解" class="headerlink" title="背包问题的详解"></a>背包问题的详解</h2><h3 id="1-01背包问题"><a href="#1-01背包问题" class="headerlink" title="1. 01背包问题"></a>1. 01背包问题</h3><h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p>有N 件物品和一个容量为V 的背包。放入第<code>i</code>件物品耗费的费用是$C_i$，得到的价值是$W_i$。求解将哪些物品装入背包可使价值总和最大。</p>
<h4 id="基本思路："><a href="#基本思路：" class="headerlink" title="基本思路："></a>基本思路：</h4><p>这是最基础的背包问题，特点是：每种物品仅有一件，可以选择放或者不放</p>
<p>用子问题定义状态，即<code>f[i,v]</code>表示前<code>i</code>间物品恰放入一个容量为<code>v</code>的背包可以获得的最大值。则其状态转移方程便是$f[i,v] = max(F[i - 1,v], F[i - 1, v - C_i] + W_i)$</p>
<h4 id="伪代码如下："><a href="#伪代码如下：" class="headerlink" title="伪代码如下："></a>伪代码如下：</h4><p><img src="C:%5CUsers%5C12751%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1569847212976.png" alt="1569847212976"></p>
<h4 id="优化空间复杂度："><a href="#优化空间复杂度：" class="headerlink" title="优化空间复杂度："></a>优化空间复杂度：</h4><p>以上方法的时间和空间复杂度均为$O(VN)$，其中时间复杂度已经不能再优化了，但是空间复杂度却可以优化到$O(V)$</p>
<p>我们可以将代码写成下面这种形式：</p>
<p><img src="C:%5CUsers%5C12751%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1569847314337.png" alt="1569847314337"></p>
<p>首先，这里本来是个二维数组，但是由于我们每次更新当前行的时候，只用到了前一行的数据，因此可以变成一个一维数组。</p>
<p>这里注意到：$v \leftarrow V \text { to } C_{i}$</p>
<p>为什么要这样写呢？</p>
<p>因为当我们变成一维数组的时候，在进行状态更新的时候，当前的状态依赖于前面的状态，如图：</p>
<p>![img](file:///C:\Users\12751\Documents\Tencent Files\1275121799\Image\C2C{5ABE66EB-46E4-094C-B286-7156B3D63719}.png)</p>
<p>更新完之后，还得写回当前的位置，为了不影响后面的操作，所以这里需要倒过来写</p>
<h4 id="初始化的细节问题："><a href="#初始化的细节问题：" class="headerlink" title="初始化的细节问题："></a>初始化的细节问题：</h4><p>我们看到的求最优解的背包问题题目中，事实上有两种不太相同的问法。有的题目要求“恰好装满背包”时的最优解，有的题目则并没有要求必须把背包装满。一种区别这两种问法的实现方法是在初始化的时候有所不同。</p>
<p>如果是第一种问法，要求恰好装满背包，那么在初始化时除了<code>f[0] = 0</code>，其他<code>F[1...V]</code>均设为$-\infty$。这样就能保证最终得到的<code>f[V]</code>是一种恰好装满背包的最优解。</p>
<p>如果并没有要求必须把背包装满，而是只希望价格尽量大，初始化时应将<code>F[0...V]</code>全部设为0</p>
<p>为什么呢？可以这样理解：初始化的<code>F</code>数组事实上就是在没有任何物品可以放入背包时的合法状态。如果要求背包恰好装满，那么此时只有容量为0的背包可以在什么也不装且价值为0的情况下被“恰好装满”，其他容量的背包均没有合法的解，属于未定义的状态，应该就被赋值为$-\infty$。如果背包并非必须被装满，那么任何容量的背包都有一个合法解“什么都不装”，这个解的价值为0，所以初始时状态的值也就是全部为0了</p>
<h3 id="2-完全背包问题"><a href="#2-完全背包问题" class="headerlink" title="2. 完全背包问题"></a>2. 完全背包问题</h3><h4 id="题目：-1"><a href="#题目：-1" class="headerlink" title="题目："></a>题目：</h4><p>有$N$ 种物品和一个容量为$V $的背包，每种物品都有无限件可用。放入第i 种物品的费用是$C_i$，价值是$W_i$。求解：将哪些物品装入背包，可使这些物品的耗费的费用总和不超过背包容量，且价值总和最大。</p>
<h4 id="常规思路："><a href="#常规思路：" class="headerlink" title="常规思路："></a>常规思路：</h4><p>常规思路应该写出这样的表达式：</p>
<p>$F[i, v] = max(F[i - 1,v - k * (C_i)] + kW_i), 0 \le kC_i \le v$</p>
<h4 id="一个简单有效的优化："><a href="#一个简单有效的优化：" class="headerlink" title="一个简单有效的优化："></a>一个简单有效的优化：</h4><p>完全背包问题有一个很简单有效的优化，是这样的：若两件物品$i$、$j$ 满足 $C_i \le C_j$，且$W_i \ge W_j$，则可以直接将物品<code>j</code>去掉，不用考虑。这个优化的正确性是显然的：任何情况下都可以将价值小费用高的<code>j</code>换成物美价廉的<code>i</code>，得到的方案至少不会更差。</p>
<h4 id="O-VN-的算法："><a href="#O-VN-的算法：" class="headerlink" title="$O(VN)$的算法："></a>$O(VN)$的算法：</h4><p>伪代码：</p>
<p><img src="C:%5CUsers%5C12751%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1569849873174.png" alt="1569849873174"></p>
<p>你会发现，这个伪代码与01背包的伪代码只有v的循环次序不同而已。 </p>
<p>为什么这个方法可行呢？我们先来看看原来为什么需要逆序？</p>
<p>![img](file:///C:\Users\12751\Documents\Tencent Files\1275121799\Image\C2C{5ABE66EB-46E4-094C-B286-7156B3D63719}.png)</p>
<p>因为我们怕改变当前的值会影响到后面，但是现在我们恰恰需要这种影响，因为这个时候，我们的物品不止一件了，可以无限的放进背包，而且这种影响可以表示为：我在已经放入<code>k</code>个<code>i</code>物品之后，在放入一件<code>i</code>物品不会不会使得我的价值更大呢？</p>
<h3 id="3-多重背包问题"><a href="#3-多重背包问题" class="headerlink" title="3. 多重背包问题"></a>3. 多重背包问题</h3><h4 id="题目：-2"><a href="#题目：-2" class="headerlink" title="题目："></a>题目：</h4><p>有N 种物品和一个容量为$V$ 的背包。第$i$ 种物品最多有$M_i$ 件可用，每件耗费的空间是$C_i$，价值是$W_i$。求解将哪些物品装入背包可使这些物品的耗费的空间总和不超过背包容量，且价值总和最大。</p>
<h4 id="基本算法："><a href="#基本算法：" class="headerlink" title="基本算法："></a>基本算法：</h4><p>$F[i, v] = max(F[i - 1,v - k * (C_i)] + kW_i), 0 \le k \le M_i$</p>
<h4 id="转换为01背包问题："><a href="#转换为01背包问题：" class="headerlink" title="转换为01背包问题："></a>转换为01背包问题：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">k &lt;- <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span>(k &lt; M) </span><br><span class="line">	ZeroOnePack(kC, kW)</span><br><span class="line">	M &lt;- M - k</span><br><span class="line">	k &lt;- <span class="number">2</span>k</span><br><span class="line">ZeroOnePack(CM, WM)</span><br></pre></td></tr></table></figure>

<h3 id="377-组合总和IV"><a href="#377-组合总和IV" class="headerlink" title="377. 组合总和IV"></a>377. 组合总和IV</h3><p>给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">nums = [1, 2, 3]</span><br><span class="line">target = 4</span><br><span class="line">所有可能的组合为：</span><br><span class="line">(1, 1, 1, 1)</span><br><span class="line">(1, 1, 2)</span><br><span class="line">(1, 2, 1)</span><br><span class="line">(1, 3)</span><br><span class="line">(2, 1, 1)</span><br><span class="line">(2, 2)</span><br><span class="line">(3, 1)</span><br><span class="line">请注意，顺序不同的序列被视作不同的组合。</span><br><span class="line">因此输出为 7。</span><br></pre></td></tr></table></figure>

<p>思路：实际上就是一个完全背包的问题</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> dp[target + <span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= target;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i &gt;= num) &#123;</span><br><span class="line">                    dp[i] = dp[i] &gt;= INT_MAX - dp[i - num] ? <span class="number">0</span> : dp[i] + dp[i - num];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里需要注意有可能会出现<code>int</code>范围爆炸的问题。所以需要提前判断一下！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://woojoo520.github.io/2019/09/27/LeetCode-Day41/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mariana">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Celery Fairy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/27/LeetCode-Day41/" itemprop="url">LeetCode-Day41</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-27T10:01:32+08:00">
                2019-09-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="172-阶乘后的零"><a href="#172-阶乘后的零" class="headerlink" title="172. 阶乘后的零"></a>172. 阶乘后的零</h3><p>给定一个整数 n，返回 n! 结果尾数中零的数量。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: 0</span><br><span class="line">解释: 3! = 6, 尾数中没有零。</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 5</span><br><span class="line">输出: 1</span><br><span class="line">解释: 5! = 120, 尾数中有 1 个零.</span><br></pre></td></tr></table></figure>

<p>思路：能产生0的情况只有<code>5 * 2 = 10</code>，其他情况分解后也是这个，2的数目要远多于5，所以问题就转变为求5的个数</p>
<p>比如<code>25! = 1 * 2 * 3 * ... * 24 * 25</code></p>
<ul>
<li>去掉无法产生0的，<code>5 * 10 * 15 * 20 * 25</code></li>
<li>再分解，<code>1*5 * 2*5 * 3*5 * 4*5 * 5*5</code></li>
<li>那些5的倍数的都能构造出<code>2*5</code>，而25有两层5</li>
<li>所以只要<code>n /= 5</code>就能得到第一层的5的个数，剩下<code>1 * 2 * 3 * 4 * 5</code></li>
<li>上面的结果再除以5就是下一层的5的个数</li>
<li>最终<code>5 + 1 = 6</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt;= <span class="number">5</span>) &#123;</span><br><span class="line">            n /= <span class="number">5</span>;</span><br><span class="line">            ans += n;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> ans;     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="179-最大数"><a href="#179-最大数" class="headerlink" title="179. 最大数"></a>179. 最大数</h3><p>给定一组非负整数，重新排列它们的顺序使之组成一个最大的整数。</p>
<p>示例 1:</p>
<p>输入: [10,2]<br>输出: 210<br>示例 2:</p>
<p>输入: [3,30,34,5,9]<br>输出: 9534330<br>说明: 输出结果可能非常大，所以你需要返回一个字符串而不是整数。</p>
<p>思路：</p>
<p>其实想了好久才突然明白一件事情…</p>
<p>就是在作为排序条件的时候，如何判断<code>a &gt; b</code></p>
<p>一开始一直在想长度不相等的话怎么办，后来才发现自己的判断依据其实一直是<code>a + b 是否大于 b + a</code>(这里的相加指的是字符串的相加)</p>
<p>所以判断依据就是上面这个，然后排个序穿起来就行了，但是要注意全零的情况，此时只需要返回0</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">largestNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(index &lt; nums.size()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[index] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(index == nums.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(nums.begin(), nums.end(), [](<span class="keyword">int</span>&amp; a, <span class="keyword">int</span>&amp; b) &#123;</span><br><span class="line">            <span class="built_in">string</span> stra = to_string(a), strb = to_string(b);</span><br><span class="line">            <span class="built_in">string</span> str1 = stra + strb, str2 = strb + stra;</span><br><span class="line">            <span class="keyword">return</span> str1 &gt; str2;  </span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            res += to_string(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="130-被围绕的区域"><a href="#130-被围绕的区域" class="headerlink" title="130. 被围绕的区域"></a>130. 被围绕的区域</h3><p>给定一个二维的矩阵，包含 ‘X’ 和 ‘O’（字母 O）。</p>
<p>找到所有被 ‘X’ 围绕的区域，并将这些区域里所有的 ‘O’ 用 ‘X’ 填充。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">X X X X</span><br><span class="line">X O O X</span><br><span class="line">X X O X</span><br><span class="line">X O X X</span><br><span class="line">运行你的函数后，矩阵变为：</span><br><span class="line"></span><br><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X O X X</span><br><span class="line">解释:</span><br><span class="line"></span><br><span class="line">被围绕的区间不会存在于边界上，换句话说，任何边界上的 &apos;O&apos; 都不会被填充为 &apos;X&apos;。 任何不在边界上，或不与边界上的 &apos;O&apos; 相连的 &apos;O&apos; 最终都会被填充为 &apos;X&apos;。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。</span><br></pre></td></tr></table></figure>

<p>思路：这个问题很容易就能想到DFS，所以照着思路写代码就可以了</p>
<p><strong>简单总结dfs和bfs：</strong></p>
<ul>
<li><code>bfs:递归。可以想象二叉树中如何递归进行层序遍历</code></li>
<li><code>bfs:非递归，一般用队列存储</code></li>
<li><code>dfs:递归，最常用，如二叉树的先序遍历</code></li>
<li><code>dfs:非递归，一般用stack</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = board.size(), n = board[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j++) &#123;</span><br><span class="line">                <span class="comment">// 从边缘第一个是O开始搜索</span></span><br><span class="line">                <span class="keyword">bool</span> isEdge = (i == <span class="number">0</span> || i == m - <span class="number">1</span> || j == <span class="number">0</span> || j == n - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(isEdge &amp;&amp; board[i][j] == <span class="string">'O'</span>) &#123;</span><br><span class="line">                    dfs(board, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">'O'</span>) &#123;</span><br><span class="line">                    board[i][j] = <span class="string">'X'</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(board[i][j] == <span class="string">'#'</span>) &#123;</span><br><span class="line">                    board[i][j] = <span class="string">'O'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = board.size(), n = board[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">stack</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; st;</span><br><span class="line">        st.push(&#123;i, j&#125;);</span><br><span class="line">        board[i][j] = <span class="string">'#'</span>;</span><br><span class="line">        <span class="keyword">while</span>(!st.empty()) &#123;</span><br><span class="line">            pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; current = st.top();</span><br><span class="line">            <span class="keyword">if</span>(current.first &gt;= <span class="number">1</span> &amp;&amp; board[current.first - <span class="number">1</span>][current.second] == <span class="string">'O'</span>) &#123;</span><br><span class="line">                st.push(&#123;current.first - <span class="number">1</span>, current.second&#125;);</span><br><span class="line">                board[current.first - <span class="number">1</span>][current.second] = <span class="string">'#'</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span>(current.first + <span class="number">1</span> &lt; m &amp;&amp; board[current.first + <span class="number">1</span>][current.second] == <span class="string">'O'</span>) &#123;</span><br><span class="line">                st.push(&#123;current.first + <span class="number">1</span>, current.second&#125;);</span><br><span class="line">                board[current.first + <span class="number">1</span>][current.second] = <span class="string">'#'</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span>(current.second &gt;= <span class="number">1</span> &amp;&amp; board[current.first][current.second - <span class="number">1</span>] == <span class="string">'O'</span>) &#123;</span><br><span class="line">                st.push(&#123;current.first, current.second - <span class="number">1</span>&#125;);</span><br><span class="line">                board[current.first][current.second - <span class="number">1</span>] = <span class="string">'#'</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span>(current.second + <span class="number">1</span> &lt; n &amp;&amp; board[current.first][current.second + <span class="number">1</span>] == <span class="string">'O'</span>) &#123;</span><br><span class="line">                st.push(&#123;current.first, current.second + <span class="number">1</span>&#125;);</span><br><span class="line">                board[current.first][current.second + <span class="number">1</span>] = <span class="string">'#'</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            st.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a>200. 岛屿数量</h3><p>给定一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">11110</span><br><span class="line">11010</span><br><span class="line">11000</span><br><span class="line">00000</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">11000</span><br><span class="line">11000</span><br><span class="line">00100</span><br><span class="line">00011</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure>

<p>思路：与上一题很类似</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(grid.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = grid.size(), n = grid[<span class="number">0</span>].size();</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                DFS(grid, i, j);</span><br><span class="line">                sum += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = grid.size(), n = grid[<span class="number">0</span>].size();</span><br><span class="line">    <span class="built_in">stack</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; st;</span><br><span class="line">    st.push(&#123;i, j&#125;);</span><br><span class="line">    grid[i][j] = <span class="string">'#'</span>;</span><br><span class="line">    <span class="keyword">while</span>(!st.empty()) &#123;</span><br><span class="line">        pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; current = st.top();</span><br><span class="line">        <span class="keyword">if</span>(current.first &gt;= <span class="number">1</span> &amp;&amp; grid[current.first - <span class="number">1</span>][current.second] == <span class="string">'1'</span>) &#123;</span><br><span class="line">            st.push(&#123;current.first - <span class="number">1</span>, current.second&#125;);</span><br><span class="line">            grid[current.first - <span class="number">1</span>][current.second] = <span class="string">'#'</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(current.first + <span class="number">1</span> &lt; m &amp;&amp; grid[current.first + <span class="number">1</span>][current.second] == <span class="string">'1'</span>) &#123;</span><br><span class="line">            st.push(&#123;current.first + <span class="number">1</span>, current.second&#125;);</span><br><span class="line">            grid[current.first + <span class="number">1</span>][current.second] = <span class="string">'#'</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(current.second &gt;= <span class="number">1</span> &amp;&amp; grid[current.first][current.second - <span class="number">1</span>] == <span class="string">'1'</span>) &#123;</span><br><span class="line">            st.push(&#123;current.first, current.second - <span class="number">1</span>&#125;);</span><br><span class="line">            grid[current.first][current.second - <span class="number">1</span>] = <span class="string">'#'</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(current.second + <span class="number">1</span> &lt; n &amp;&amp; grid[current.first][current.second + <span class="number">1</span>] == <span class="string">'1'</span>) &#123;</span><br><span class="line">            st.push(&#123;current.first, current.second + <span class="number">1</span>&#125;);</span><br><span class="line">            grid[current.first][current.second + <span class="number">1</span>] = <span class="string">'#'</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        st.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://woojoo520.github.io/2019/09/25/cGAN/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mariana">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Celery Fairy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/25/cGAN/" itemprop="url">cGAN</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-25T21:17:11+08:00">
                2019-09-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="cGAN"><a href="#cGAN" class="headerlink" title="cGAN"></a>cGAN</h2><h3 id="为什么要有cGAN？"><a href="#为什么要有cGAN？" class="headerlink" title="为什么要有cGAN？"></a>为什么要有cGAN？</h3><p>首先，GAN虽然厉害，但有个问题，其生成模型生成的样本完全是随机的，也就是完全取决于输入的噪声z，根本无法预测会生成数字1还是数字2.因此偶人提出了条件GAN，其思想也很简单，就是想要生成哪个数字，你输入的时候告诉我你想要的标签即可。为了达到这个目标，在训练的时候，就要加上标签。也就是G想要伪造数字1，就要在原本的z向量后面加十维的one-hot向量，在D那里也是，要判别什么，也要在尾部加上十维的one-hot向量</p>
<p><img src="https://pic4.zhimg.com/v2-b112245a817b2e813a65cdb3fe4620eb_b.jpg" alt="img"></p>
<p>以上图为例，如果迷行的输入是文字，输出是图片，使用传统的做法会产生模糊的问题。比如输入火车，希望得到一张火车的图片，可是火车有侧面，有不同的形态，如果不加约束，则可能产生一张包含各种样式的火车的平均（模糊）图。</p>
<p>​    GAN的机制是只要识别器能分辨得出一张图是人工生成的还是原图就行，所以不能确保输入火车就回生成火车图片，比如输入火车生成一张很逼真的猫图，生成器也会被认为是一个成功的生成器（GAN容易钻空子，即如果某种特定形式可以骗过生成器，生成器会倾向于生成这种模式）</p>
<p>生成器输出一张图片，然后将同样的语句（条件）和生成的图片一起输入识别器，关键是，识别器不仅需要分辨真假，还需要分辨出语句（条件）和图片是否匹配。总的来说有三种情况：</p>
<p>原图 + 图和条件匹配   —-&gt;     高分</p>
<p>原图 + 图和条件不匹配   —-&gt;     低分</p>
<p>人工图      —-&gt;     低分</p>
<p><img src="https://pic1.zhimg.com/v2-ec6da03ab4ea2b7eb4cb7b32bb81b428_b.jpg" alt="img"></p>
<p>通过这样的操作，可以确保输出样本和条件是匹配的</p>
<p>CGAN有两种比较常用的结构：</p>
<p><img src="https://pic4.zhimg.com/v2-2e71198971ecf978048df60d6862dfef_b.jpg" alt="img"></p>
<p>这两种结构的主要区别在生成器的输出部分，下面的可能更加合理：</p>
<p>下半部分的结构中生成器的输出分为两部分：</p>
<ul>
<li>是否是真实图片</li>
<li>输出与条件是否匹配</li>
</ul>
<p>这样做的好处是，直观上说，模型能分别知道两个任务的性能，更有针对性地提高模型能力，如果输出的图像不够真实，但是能比较好地是辈出是否匹配，则主要调节生成样本的分支，而第一种结构由于是混合在一起的，就没有这种针对性调节的能力。</p>
<p>值得一提的是，论文里的识别器使用了Patch的方法，即先将输出样本划分为若干个Patch，然后对每个Patch进行评分，最后将所有patch的得分平均作为最后得分。这样做的好处是，识别器能更加关注到生成图像的细节部分，即对高频的部分更加敏感，当然，最极端是每一个像素就是一个patch，这样的话识别器会失去大局观，即失去不同部分空间部分之间的相关信息</p>
<p><img src="https://pic3.zhimg.com/v2-e99cc2059b659feab28652048fda92ba_b.jpg" alt="img"></p>
<p>一些用到的函数的详解：</p>
<p><code>torch.nn.Embedding(num_embeddings, emcedding_dim, padding_idx = None, max_norm = None, norm_type = 2, scale_grad_by_freq = False, sparse = False)</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Pytorch官网的解释是：一个保存了固定字典的带下和简单查找表。这个模块常用来保存字典嵌入和用下标检索它们。模块的输入是一个下标的列表，输出是对应的词嵌入</span></span><br><span class="line"><span class="comment"># 个人理解：这是一个矩阵类，里面初始化了一个随机矩阵，矩阵的长是字典的大小，宽是用来表示字典中每个元素的属性向量，向量的维度根据你想要的元素的复杂度而定。类实例化之后可以根据字典中元素的下标来查找元素对应的向量。例如输入下标0， 输出就是embeds矩阵中的第0行</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> torch</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>label = nn.Embedding(<span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>label(Variable(torch.LongTensor([<span class="number">4</span>])))</span><br><span class="line">tensor([[<span class="number">-0.6134</span>,  <span class="number">0.0528</span>,  <span class="number">2.4490</span>, <span class="number">-0.0294</span>,  <span class="number">1.2371</span>,  <span class="number">0.5792</span>, <span class="number">-1.2843</span>,  <span class="number">0.6881</span>,</span><br><span class="line">         <span class="number">-0.9275</span>,  <span class="number">1.2503</span>]], grad_fn=&lt;EmbeddingBackward&gt;)</span><br></pre></td></tr></table></figure>

<p><code>nn.prod()</code>        连乘函数</p>
<p><code>torch.cat()</code>    连接函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = torch.randn(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = torch.randn(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">tensor([[ <span class="number">2.2045</span>,  <span class="number">1.0283</span>,  <span class="number">0.7637</span>],</span><br><span class="line">        [ <span class="number">0.8578</span>, <span class="number">-0.8376</span>, <span class="number">-0.3780</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y</span><br><span class="line">tensor([[<span class="number">-0.5941</span>, <span class="number">-0.8588</span>,  <span class="number">0.9540</span>],</span><br><span class="line">        [<span class="number">-1.1115</span>,  <span class="number">0.3655</span>,  <span class="number">0.2471</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.cat((x, y), <span class="number">0</span>)</span><br><span class="line">tensor([[ <span class="number">2.2045</span>,  <span class="number">1.0283</span>,  <span class="number">0.7637</span>],</span><br><span class="line">        [ <span class="number">0.8578</span>, <span class="number">-0.8376</span>, <span class="number">-0.3780</span>],</span><br><span class="line">        [<span class="number">-0.5941</span>, <span class="number">-0.8588</span>,  <span class="number">0.9540</span>],</span><br><span class="line">        [<span class="number">-1.1115</span>,  <span class="number">0.3655</span>,  <span class="number">0.2471</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.cat((x, y), <span class="number">1</span>)</span><br><span class="line">tensor([[ <span class="number">2.2045</span>,  <span class="number">1.0283</span>,  <span class="number">0.7637</span>, <span class="number">-0.5941</span>, <span class="number">-0.8588</span>,  <span class="number">0.9540</span>],</span><br><span class="line">        [ <span class="number">0.8578</span>, <span class="number">-0.8376</span>, <span class="number">-0.3780</span>, <span class="number">-1.1115</span>,  <span class="number">0.3655</span>,  <span class="number">0.2471</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.cat((x, y), <span class="number">-1</span>)</span><br><span class="line">tensor([[ <span class="number">2.2045</span>,  <span class="number">1.0283</span>,  <span class="number">0.7637</span>, <span class="number">-0.5941</span>, <span class="number">-0.8588</span>,  <span class="number">0.9540</span>],</span><br><span class="line">        [ <span class="number">0.8578</span>, <span class="number">-0.8376</span>, <span class="number">-0.3780</span>, <span class="number">-1.1115</span>,  <span class="number">0.3655</span>,  <span class="number">0.2471</span>]])</span><br><span class="line"><span class="comment"># torch.cat((), 0)	竖着连接</span></span><br><span class="line"><span class="comment"># torch.cat((), 1 or -1)	横着连接</span></span><br></pre></td></tr></table></figure>

<p><code>numpy.random.randint(low, high, size)</code></p>
<p>low、high、size三个参数。默认high是None，如果只有low，那范围就是<code>[0, low)</code>。如果有high，范围就是<code>[low, high)</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.random.randint(<span class="number">5</span>, <span class="number">16</span>, <span class="number">64</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([<span class="number">13</span>, <span class="number">14</span>, <span class="number">12</span>, <span class="number">15</span>,  <span class="number">8</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">11</span>, <span class="number">11</span>, <span class="number">10</span>, <span class="number">14</span>, <span class="number">15</span>,  <span class="number">8</span>, <span class="number">15</span>,  <span class="number">5</span>, <span class="number">12</span>,  <span class="number">6</span>,</span><br><span class="line">       <span class="number">15</span>,  <span class="number">9</span>,  <span class="number">5</span>,  <span class="number">5</span>, <span class="number">13</span>, <span class="number">13</span>,  <span class="number">8</span>, <span class="number">15</span>, <span class="number">10</span>, <span class="number">11</span>,  <span class="number">6</span>,  <span class="number">8</span>, <span class="number">15</span>,  <span class="number">9</span>,  <span class="number">9</span>,  <span class="number">9</span>,  <span class="number">5</span>,</span><br><span class="line">       <span class="number">13</span>, <span class="number">12</span>, <span class="number">12</span>,  <span class="number">8</span>,  <span class="number">5</span>, <span class="number">14</span>,  <span class="number">7</span>, <span class="number">15</span>, <span class="number">11</span>,  <span class="number">6</span>,  <span class="number">7</span>, <span class="number">12</span>, <span class="number">10</span>,  <span class="number">8</span>, <span class="number">10</span>,  <span class="number">5</span>, <span class="number">13</span>,</span><br><span class="line">        <span class="number">9</span>, <span class="number">14</span>,  <span class="number">8</span>,  <span class="number">7</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">6</span>,  <span class="number">6</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">15</span>, <span class="number">14</span>, <span class="number">10</span>])</span><br></pre></td></tr></table></figure>

<p><code>np.random.normal(loc=0.0, scale=1.0, siez=None)</code></p>
<p>loc：float，此概率分布的均值（对应整个分布的重心center）</p>
<p>scale：float，此概率分布的标准差（对应于分布的宽度，scale越大越矮胖。scale越小，越瘦高）</p>
<p>size：int or tuple of ints</p>
<p>输出的shape，默认为None， 值输出一个值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.random.normal(<span class="number">5</span>, <span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line"><span class="number">4.687275350809846</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.random.normal(<span class="number">5</span>, <span class="number">1</span>, [<span class="number">2</span>, <span class="number">2</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([[<span class="number">5.18009118</span>, <span class="number">4.91448971</span>],</span><br><span class="line">       [<span class="number">6.2771917</span> , <span class="number">5.15529855</span>]])</span><br></pre></td></tr></table></figure>

<p>$IS(G) = exp(E_{x \sim p_g}D_{KL}(p(y|x)||p(y)))$</p>
<p>$D(p||q) = \sum p(x) log \frac{p(x)} {q(x)} $</p>
<p>$FID = ||u_r - u_g||^2 + T_r(\sum_r + \sum_g - 2(\sum_r - \sum_g)^{\frac{1} {2}})$</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://woojoo520.github.io/2019/09/25/交叉熵/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mariana">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Celery Fairy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/25/交叉熵/" itemprop="url">交叉熵</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-25T15:20:30+08:00">
                2019-09-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="关于交叉熵在loss函数中使用的理解"><a href="#关于交叉熵在loss函数中使用的理解" class="headerlink" title="关于交叉熵在loss函数中使用的理解"></a>关于交叉熵在loss函数中使用的理解</h2><h3 id="信息论"><a href="#信息论" class="headerlink" title="信息论"></a>信息论</h3><p>交叉熵是信息论中的一个概念，想要了解交叉熵的本质，需要从最基本的概念讲起。</p>
<h3 id="1-信息量"><a href="#1-信息量" class="headerlink" title="1. 信息量"></a>1. 信息量</h3><p>首先是信息量。假设我们听到了两件事，分别如下：<br>事件A：巴西队进入了2018世界杯决赛圈。<br>事件B：中国队进入了2018世界杯决赛圈。<br>仅凭直觉来说，显而易见事件B的信息量比事件A的信息量要大。究其原因，是因为事件A发生的概率很大，事件B发生的概率很小。所以当越不可能的事件发生了，我们获取到的信息量就越大。越可能发生的事件发生了，我们获取到的信息量就越小。那么信息量应该和事件发生的概率有关。</p>
<p>假设$X$是一个离散型随机变量，其取值集合为$χ$,概率分布函数$p(x)=Pr(X=x),x∈χ$,则定义事件$X=x_0$的信息量为：</p>
<p>$I(x_0) = -log(p(x_0))$</p>
<p>由于是概率所以$p(x_0)$的取值范围是[0, 1],绘制为图形如下：</p>
<p><img src="https://img-blog.csdn.net/20180125164333234?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdHN5Y2NuaA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="è¿éåå¾çæè¿°"></p>
<h3 id="2-熵"><a href="#2-熵" class="headerlink" title="2. 熵"></a>2. 熵</h3><p>考虑另一个问题，对于某个事件，有nn种可能性，每一种可能性都有一个概率$p(xi)$这样就可以计算出某一种可能性的信息量。举一个例子，假设你拿出了你的电脑，按下开关，会有三种可能性，下表列出了每一种可能的概率及其对应的信息量</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>事件</th>
<th>概率p</th>
<th>信息量I</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>电脑正常开机</td>
<td>0.7</td>
<td>-log(p(A))=0.36</td>
</tr>
<tr>
<td>B</td>
<td>电脑无法开机</td>
<td>0.2</td>
<td>-log(p(B))=1.61</td>
</tr>
<tr>
<td>C</td>
<td>电脑爆炸了</td>
<td>0.1</td>
<td>-log(p(C))=2.30</td>
</tr>
</tbody></table>
<p><code>注：文中的对数均为自然对数</code></p>
<p>我们现在有了信息量的定义，而熵用来表示所有信息量的期望，即：</p>
<p>$H(X) = -\sum_{i = 1}^{n}{p(x_i)log(p(x_i))}$</p>
<p>其中n代表所有的n种可能性，所以上面的问题的结果就是</p>
<p>$H(X) = -[p(A)log(p(A)) + p(B)log(p(B)) + p(C)log(p(C))] = 0.7\times0.36 + 0.2 \times 1.61 + 0.1 \times * 2.30 = 0.804$</p>
<p>然而，有一类比较太特殊的问题，比如，投掷硬币只有两种可能，字朝上或花朝上。买彩票只有两种可能，中奖或不中奖。我们称之为0-1分布（二项分布的特例），对于这类问题，熵的计算方法可以简化为如下算式：</p>
<p>$H(X) = -\sum_{i = 1}^{n} p(x_i)log(p(x_i)) = -p(x)log(p(x)) - (1 - p(x))log(1-p(x))$</p>
<h3 id="3-相对熵"><a href="#3-相对熵" class="headerlink" title="3. 相对熵"></a>3. 相对熵</h3><p>相对熵又称<strong>KL散度</strong>，如果我们对于同一个随机变量x有两个单独的概率分布P(x)或Q(x)，我们可以使用KL散度来衡量这两个分布的差异。</p>
<p>即如果用P来描述目标问题，而不是用Q来描述目标问题，得到的信息增量。</p>
<p>在机器学习中，P往往用来表示样本的真实分布，比如[1,0,0]表示当前样本属于第一类。Q用来表示模型所预测的分布，比如[0.7,0.2,0.1]<br>直观的理解就是如果用P来描述样本，那么就非常完美。而用Q来描述样本，虽然可以大致描述，但是不是那么的完美，信息量不足，需要额外的一些“信息增量”才能达到和P一样完美的描述。如果我们的Q通过反复训练，也能完美的描述样本，那么就不再需要额外的“信息增量”，Q等价于P。</p>
<p>KL散度的计算公式：</p>
<p><img src="C:%5CUsers%5C12751%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1569397275231.png" alt="1569397275231"></p>
<p>n为事件的所有可能性。</p>
<p>$D_{KL}$的值越小，表示q分布和p分布越接近</p>
<h3 id="4-交叉熵"><a href="#4-交叉熵" class="headerlink" title="4. 交叉熵"></a>4. 交叉熵</h3><p>对于KL散度的公式进行变形可以得到：</p>
<p><img src="C:%5CUsers%5C12751%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1569397402578.png" alt="1569397402578"></p>
<p>等式的前一部分恰巧就是p的熵，等式的后一部分，就是交叉熵</p>
<p>$H(p, q) = -\sum_{i = 1}^n p(x_i)log(q(x_i))$</p>
<p>在机器学习中，我们需要评估<code>label</code>和<code>predicts</code>之间的差距，使用KL散度刚刚好，即$D_{KL}(y||\hat y)$，由于KL散度中的前一部分$-H(y)$不变，故在优化过程中，只需要关注交叉熵就可以了。所以，一般在机器学习中直接使用交叉熵做loss，评估模型。</p>
<p>参考：<a href="https://blog.csdn.net/tsyccnh/article/details/79163834?tdsourcetag=s_pctim_aiomsg" target="_blank" rel="noopener">https://blog.csdn.net/tsyccnh/article/details/79163834?tdsourcetag=s_pctim_aiomsg</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://woojoo520.github.io/2019/09/25/LeetCode-Day40/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mariana">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Celery Fairy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/25/LeetCode-Day40/" itemprop="url">LeetCode-Day40</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-25T08:10:05+08:00">
                2019-09-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="464-我能赢吗"><a href="#464-我能赢吗" class="headerlink" title="464. 我能赢吗"></a>464. 我能赢吗</h3><p>在 “100 game” 这个游戏中，两名玩家轮流选择从 1 到 10 的任意整数，累计整数和，先使得累计整数和达到 100 的玩家，即为胜者。</p>
<p>如果我们将游戏规则改为 “玩家不能重复使用整数” 呢？</p>
<p>例如，两个玩家可以轮流从公共整数池中抽取从 1 到 15 的整数（不放回），直到累计整数和 &gt;= 100。</p>
<p>给定一个整数 maxChoosableInteger （整数池中可选择的最大数）和另一个整数 desiredTotal（累计和），判断先出手的玩家是否能稳赢（假设两位玩家游戏时都表现最佳）？</p>
<p>你可以假设 maxChoosableInteger 不会大于 20， desiredTotal 不会大于 300。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">maxChoosableInteger = 10</span><br><span class="line">desiredTotal = 11</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">false</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">无论第一个玩家选择哪个整数，他都会失败。</span><br><span class="line">第一个玩家可以选择从 1 到 10 的整数。</span><br><span class="line">如果第一个玩家选择 1，那么第二个玩家只能选择从 2 到 10 的整数。</span><br><span class="line">第二个玩家可以通过选择整数 10（那么累积和为 11 &gt;= desiredTotal），从而取得胜利.</span><br><span class="line">同样地，第一个玩家选择任意其他整数，第二个玩家都会赢。</span><br></pre></td></tr></table></figure>

<p>暂时还不知道什么想法…</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> bits, <span class="keyword">int</span> distance, <span class="keyword">int</span> maxChoosableInteger, <span class="keyword">int</span> dp[])</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 已经计算过。0：未计算，1：true， 2：false</span></span><br><span class="line">        <span class="keyword">if</span>(dp[bits] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> dp[bits] == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> result = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> cur = maxChoosableInteger;cur &gt; <span class="number">0</span>;cur--) &#123;</span><br><span class="line">            <span class="keyword">int</span> curBit = <span class="number">1</span> &lt;&lt; (cur - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 如果当前值没有被使用</span></span><br><span class="line">            <span class="keyword">if</span>((bits &amp; curBit) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 可以一步成功</span></span><br><span class="line">                <span class="keyword">if</span>(cur &gt;= distance || !helper(bits | curBit, distance - cur, maxChoosableInteger, dp)) &#123;</span><br><span class="line">                    result = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[bits] = result ? <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canIWin</span><span class="params">(<span class="keyword">int</span> maxChoosableInteger, <span class="keyword">int</span> desiredTotal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> canReachTotal = (<span class="number">1</span> + maxChoosableInteger) * maxChoosableInteger / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(canReachTotal &lt; desiredTotal) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(canReachTotal == desiredTotal) &#123;</span><br><span class="line">            <span class="comment">// 刚好达到的时候，maxChoosableInteger是奇数的时候赢</span></span><br><span class="line">            <span class="keyword">return</span> (maxChoosableInteger &amp; <span class="number">1</span>) == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> dp[<span class="number">1</span> &lt;&lt; maxChoosableInteger] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">0</span>, desiredTotal, maxChoosableInteger, dp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="410-分割数组的最大值"><a href="#410-分割数组的最大值" class="headerlink" title="410. 分割数组的最大值"></a>410. 分割数组的最大值</h3><p>给定一个非负整数数组和一个整数 m，你需要将这个数组分成 m 个非空的连续子数组。设计一个算法使得这 m 个子数组各自和的最大值最小。</p>
<p>注意:<br>数组长度 n 满足以下条件:</p>
<p>1 ≤ n ≤ 1000<br>1 ≤ m ≤ min(50, n)<br>示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">nums = [7,2,5,10,8]</span><br><span class="line">m = 2</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">18</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">一共有四种方法将nums分割为2个子数组。</span><br><span class="line">其中最好的方式是将其分为[7,2,5] 和 [10,8]，</span><br><span class="line">因为此时这两个子数组各自的和的最大值为18，在所有情况中最小。</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>我们能够找到这个答案的一个性质：</p>
<p><code>如果我们找到了一种分割方案，使得最大的分割子数组和不超过x，那么我们也能找到一种分割方案使得最大的分割子数组和不超过y，其中y &gt; x</code></p>
<p>对于值<code>x</code>，我们把这个性质定义为<code>F(x)</code>。如果<code>F(x)</code>为真，那就意味着我们一定可以找到一种分割方案使得最大分割的子数组和不超过<code>x</code></p>
<p>我们让<code>x</code>的区间为<code>负无穷大</code>到<code>无穷大</code>，一旦我们找到一个值<code>x0</code>，使得所有的<code>x &lt; x0</code>,<code>F(x)</code>都为假，所有的<code>x &gt; x0</code>，<code>F(x)</code>都为真。那么显然，这个<code>x0</code>就是我们要的答案了。</p>
<p>算法描述：</p>
<ul>
<li>找到一个数，把它作为分割后各个子数组的和的最大值</li>
<li>根据这个最大值，分割数组，使每个子数组的和都不超过这个最大值</li>
<li>如果不能将数组中所有数字都分割进子数组，即还没分割完，子数组数量就已经用完了。则表示这个最大值还不够大。寻找下一个数，循环步骤1-3</li>
<li>如果全部都分割进子数组，则返回这个最大值。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">splitArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> l = nums[<span class="number">0</span>], h = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : nums) &#123;</span><br><span class="line">            h += i;</span><br><span class="line">            l = max(l, <span class="keyword">long</span>(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; h) &#123;</span><br><span class="line">            <span class="keyword">long</span> mid = (l + h) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">long</span> temp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">1</span>;    <span class="comment">// 初始值必须为1</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> i : nums) &#123;</span><br><span class="line">                temp += i;</span><br><span class="line">                <span class="keyword">if</span>(temp &gt; mid) &#123;</span><br><span class="line">                    temp = i;</span><br><span class="line">                    ++cnt;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cnt &gt; m) &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 能够找到这个分组的时候，开始缩小范围</span></span><br><span class="line">                h = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="467-环绕字符串中唯一的字符串"><a href="#467-环绕字符串中唯一的字符串" class="headerlink" title="467. 环绕字符串中唯一的字符串"></a>467. 环绕字符串中唯一的字符串</h3><p>把字符串 s 看作是“abcdefghijklmnopqrstuvwxyz”的无限环绕字符串，所以 s 看起来是这样的：”…zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd….”. </p>
<p>现在我们有了另一个字符串 p 。你需要的是找出 s 中有多少个唯一的 p 的非空子串，尤其是当你的输入是字符串 p ，你需要输出字符串 s 中 p 的不同的非空子串的数目。 </p>
<p>注意: p 仅由小写的英文字母组成，p 的大小可能超过 10000。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;a&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 字符串 S 中只有一个&quot;a&quot;子字符。</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;cac&quot;</span><br><span class="line">输出: 2</span><br><span class="line">解释: 字符串 S 中的字符串“cac”只有两个子串“a”、“c”。</span><br></pre></td></tr></table></figure>

<p>示例 3:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;zab&quot;</span><br><span class="line">输出: 6</span><br><span class="line">解释: 在字符串 S 中有六个子串“z”、“a”、“b”、“za”、“ab”、“zab”。</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findSubstringInWraproundString</span><span class="params">(<span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = p.length();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录到这个字符为止的最长子序列长度</span></span><br><span class="line">        <span class="keyword">int</span> len_string[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        len_string[p[<span class="number">0</span>] - <span class="string">'a'</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// dp用于记录到目前为止的最长的子序列长度</span></span><br><span class="line">        <span class="keyword">int</span> dp = <span class="number">1</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++) &#123;</span><br><span class="line">            <span class="comment">// 更新dp</span></span><br><span class="line">            <span class="keyword">if</span>(p[i] == p[i - <span class="number">1</span>] + <span class="number">1</span> || (p[i - <span class="number">1</span>] == <span class="string">'z'</span> &amp;&amp; p[i] == <span class="string">'a'</span>)) &#123;</span><br><span class="line">                dp += <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新len_string(可以这么做的原因是某个字符前面的连续串是确定的，所以以某个字符结尾的串的长度一旦大于原先以这个字符结尾的串的长度，则说明，现在的串一定是覆盖了原来的串，不会出现重复的问题的)</span></span><br><span class="line">            len_string[p[i] - <span class="string">'a'</span>] = max(len_string[p[i] - <span class="string">'a'</span>], dp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>;i++) &#123;</span><br><span class="line">            sum += len_string[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="516-最长回文子序列"><a href="#516-最长回文子序列" class="headerlink" title="516. 最长回文子序列"></a>516. 最长回文子序列</h3><p>给定一个字符串s，找到其中最长的回文子序列。可以假设s的最大长度为1000。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">&quot;bbbab&quot;</span><br><span class="line">输出:</span><br><span class="line">4</span><br><span class="line">一个可能的最长回文子序列为 &quot;bbbb&quot;。</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">&quot;cbbd&quot;</span><br><span class="line">输出:</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>典型的动态规划。记<code>dp[i][j]</code>表示从<code>i-j</code>的最长回文子序列</p>
<p>如果<code>s[i] == s[j]</code>，则<code>dp[i][j] = dp[i + 1][j - 1] + 2</code></p>
<p>否则<code>dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])</code></p>
<p>上Code：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxLength =  <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n ,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--) &#123;</span><br><span class="line">            dp[i][i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>;j &lt; n;j++) &#123;</span><br><span class="line">                dp[i][j] = s[i] == s[j] ? dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span> : max(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                maxLength = max(maxLength, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://woojoo520.github.io/2019/09/23/LeetCode-Day39/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mariana">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Celery Fairy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/23/LeetCode-Day39/" itemprop="url">LeetCode-Day39</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-23T13:10:13+08:00">
                2019-09-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209. 长度最小的子数组"></a>209. 长度最小的子数组</h3><p>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组。如果不存在符合条件的连续子数组，返回 0。</p>
<p>示例: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = 7, nums = [2,3,1,2,4,3]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 子数组 [4,3] 是该条件下的长度最小的连续子数组。</span><br></pre></td></tr></table></figure>

<p>思路：这个问题其实很容易就能想到在$O(n^2)$的时间复杂度下解决问题，但是这里采用了一种$O(nlogn)$的做法去解决这个问题。</p>
<p>首先，我们先求解<code>sums</code>数组，表示从头加到当前位置的和。</p>
<p>然后从<code>i = 1</code>到<code>n</code>枚举</p>
<ul>
<li><p>首先<code>to_find</code>定义为当前位置的<code>sum</code>值加上<code>s</code></p>
</li>
<li><p>在<code>sums</code>中找到值<code>to_find</code>最早能插入的地方，即满足从<code>i</code>开始，往后搜索差值为<code>s</code>的需要的最短距离。</p>
<p>在这里搜索的过程中可以采用二分搜索的方法，但是还有一个小技巧，就是利用<code>STL</code>中的<code>lower_bound</code>函数，来表示某一个数字最早能够插入在数组中的位置，这样显然就很高效了鸭~</p>
</li>
</ul>
<p>上Code：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen2</span><span class="params">(<span class="keyword">int</span> s, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sums(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        sums[i] = sums[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>]; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> to_find = s + sums[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">auto</span> bound = lower_bound(sums.begin(), sums.end(), to_find);</span><br><span class="line">        <span class="keyword">if</span>(bound != sums.end()) &#123;</span><br><span class="line">            ans = min(ans, <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt; (bound - (sums.begin() + i - <span class="number">1</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (ans != INT_MAX) ? ans : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于<code>lower_bound &amp;&amp; upper_bound</code>的测试</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; num(a, a + <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; num.size();i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; num[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt; (lower_bound(num.begin(), num.end(), <span class="number">2</span>) - num.begin()) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt; (upper_bound(num.begin(), num.end(), <span class="number">2</span>) - num.begin()) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<h3 id="128-最长连续序列"><a href="#128-最长连续序列" class="headerlink" title="128. 最长连续序列"></a>128. 最长连续序列</h3><p>给定一个未排序的整数数组，找出最长连续序列的长度。</p>
<p>要求算法的时间复杂度为 O(n)。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [100, 4, 200, 1, 3, 2]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 最长连续序列是 [1, 2, 3, 4]。它的长度为 4。</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p><strong>哈希表 + 线性空间的构造</strong></p>
<p>我们先将所有元素放进一个<code>Hash set</code>中，然后遍历<code>num_set</code>中的每一个元素，如果它前面一个数字没有在<code>num_set</code>中，那么它一定不是一个连续数组的开始，则跳过。如果是连续数组的开始，那么就需要一种往后找连续的元素是否存在，然后记录下最长的数列长度。</p>
<p>上Code：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; num_set;</span><br><span class="line">        <span class="keyword">int</span> maxLength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            num_set.insert(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : num_set) &#123;</span><br><span class="line">            <span class="keyword">if</span>(num_set.find(num - <span class="number">1</span>) == num_set.end()) &#123;</span><br><span class="line">                <span class="keyword">int</span> currentNum = num;</span><br><span class="line">                <span class="keyword">int</span> currentLen = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(num_set.find(currentNum + <span class="number">1</span>) != num_set.end()) &#123;</span><br><span class="line">                    currentNum += <span class="number">1</span>;</span><br><span class="line">                    currentLen += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                maxLength = max(maxLength, currentLen);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里虽然看上去复杂度挺高，但实际上是$O(n)$复杂度的，因为每个数字只会遍历到一次，因为如果不是连续数字开头的，就直接跳过了，而是连续数字开头的，就一直遍历到连续数字的末尾，所以总的时间复杂度是$O(n)$的。</p>
<h3 id="126-单词接龙II"><a href="#126-单词接龙II" class="headerlink" title="126. 单词接龙II"></a>126. 单词接龙II</h3><p>给定两个单词（beginWord 和 endWord）和一个字典 wordList，找出所有从 beginWord 到 endWord 的最短转换序列。转换需遵循如下规则：</p>
<p>每次转换只能改变一个字母。<br>转换过程中的中间单词必须是字典中的单词。<br>说明:</p>
<p>如果不存在这样的转换序列，返回一个空列表。<br>所有单词具有相同的长度。<br>所有单词只由小写字母组成。<br>字典中不存在重复的单词。<br>你可以假设 beginWord 和 endWord 是非空的，且二者不相同。<br>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">beginWord = &quot;hit&quot;,</span><br><span class="line">endWord = &quot;cog&quot;,</span><br><span class="line">wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [&quot;hit&quot;,&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;cog&quot;],</span><br><span class="line">  [&quot;hit&quot;,&quot;hot&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">beginWord = &quot;hit&quot;</span><br><span class="line">endWord = &quot;cog&quot;</span><br><span class="line">wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]</span><br><span class="line"></span><br><span class="line">输出: []</span><br><span class="line">解释: endWord &quot;cog&quot; 不在字典中，所以不存在符合要求的转换序列。</span><br></pre></td></tr></table></figure>

<p>思路：<strong>双向BFS</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(<span class="built_in">string</span> beginWord, <span class="built_in">string</span> endWord, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordList)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; freqs;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;word:wordList)</span><br><span class="line">			freqs[word]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(freqs.count(endWord)==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; q1(&#123;beginWord&#125;), q2(&#123;endWord&#125;);</span><br><span class="line">		<span class="keyword">int</span> step=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(freqs[beginWord]|=<span class="number">1</span>,freqs[endWord]|=<span class="number">2</span>; q1.size() &amp;&amp; q2.size(); ++step)&#123;</span><br><span class="line">			<span class="keyword">bool</span> first=q1.size()&lt;q2.size();</span><br><span class="line">			<span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; &amp;q=first?q1:q2;</span><br><span class="line">			<span class="keyword">int</span> flag=first?<span class="number">1</span>:<span class="number">2</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> size=q.size(); size--; q.pop())&#123;</span><br><span class="line">				<span class="built_in">string</span> &amp;word=q.front();</span><br><span class="line">				<span class="keyword">if</span>(freqs[word]==<span class="number">3</span>) <span class="keyword">return</span> step;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;word.length(); ++i)&#123;</span><br><span class="line">					<span class="keyword">for</span>(<span class="keyword">char</span> ch=<span class="string">'a'</span>; ch&lt;=<span class="string">'z'</span>; ++ch)&#123;</span><br><span class="line">						<span class="built_in">string</span> s=word;</span><br><span class="line">						<span class="keyword">if</span>(s[i]==ch) <span class="keyword">continue</span>;</span><br><span class="line">						s[i]=ch;</span><br><span class="line">						<span class="keyword">if</span>(freqs.count(s)==<span class="number">0</span> || freqs[s]&amp;flag) <span class="keyword">continue</span>;</span><br><span class="line">						freqs[s]|=flag;</span><br><span class="line">						q.push(s);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://woojoo520.github.io/2019/09/23/FFT/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mariana">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Celery Fairy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/23/FFT/" itemprop="url">FFT</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-23T13:09:48+08:00">
                2019-09-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="快速傅里叶变换FFT-Fast-Fourier-Transform"><a href="#快速傅里叶变换FFT-Fast-Fourier-Transform" class="headerlink" title="快速傅里叶变换FFT(Fast Fourier Transform)"></a>快速傅里叶变换FFT(Fast Fourier Transform)</h2><h3 id="傅里叶变换"><a href="#傅里叶变换" class="headerlink" title="傅里叶变换"></a>傅里叶变换</h3><p>快速傅里叶变换是一种可以在$O(nlogn)$时间内完成的离散傅里叶变换（DFT）算法。</p>
<p>在算法竞赛中的应用主要是用来加速多项式的乘法。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://woojoo520.github.io/2019/09/22/LeetCode-Day38/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mariana">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Celery Fairy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/22/LeetCode-Day38/" itemprop="url">LeetCode-Day38</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-22T21:53:02+08:00">
                2019-09-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="189-旋转数组"><a href="#189-旋转数组" class="headerlink" title="189. 旋转数组"></a>189. 旋转数组</h3><p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,5,6,7] 和 k = 3</span><br><span class="line">输出: [5,6,7,1,2,3,4]</span><br><span class="line">解释:</span><br><span class="line">向右旋转 1 步: [7,1,2,3,4,5,6]</span><br><span class="line">向右旋转 2 步: [6,7,1,2,3,4,5]</span><br><span class="line">向右旋转 3 步: [5,6,7,1,2,3,4]</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [-1,-100,3,99] 和 k = 2</span><br><span class="line">输出: [3,99,-1,-100]</span><br><span class="line">解释: </span><br><span class="line">向右旋转 1 步: [99,-1,-100,3]</span><br><span class="line">向右旋转 2 步: [3,99,-1,-100]</span><br></pre></td></tr></table></figure>

<p>思路：这道题虽然很简单，但是却有更加快速的操作。</p>
<p>就是先翻转整个数组，然后在要求的节点前后进行两次翻转。</p>
<p>举个栗子：</p>
<p><code>[1, 2, 3, 4, 5, 6, 7] k = 3</code></p>
<p>整个数组翻转：<code>[7, 6, 5, 4, 3, 2, 1]</code></p>
<p>前半部分翻转：<code>[5, 6, 7, 4, 3, 2, 1]</code></p>
<p>后半部分翻转：<code>[5, 6, 7, 1, 2, 3, 4]</code></p>
<p>上Code：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums.size() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        k %= nums.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n / <span class="number">2</span>;i++) &#123;</span><br><span class="line">            swap(nums[i], nums[n - <span class="number">1</span> - i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k / <span class="number">2</span>;i++) &#123;</span><br><span class="line">            swap(nums[i], nums[k - i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = k;i &lt; (n + k) / <span class="number">2</span>;i++) &#123;</span><br><span class="line">            swap(nums[i], nums[n - <span class="number">1</span> - i + k]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://woojoo520.github.io/2019/09/21/LeetCode-Day37/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mariana">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Celery Fairy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/21/LeetCode-Day37/" itemprop="url">LeetCode-Day37</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-21T07:13:57+08:00">
                2019-09-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="LeetCode-Day37——还在动态规划"><a href="#LeetCode-Day37——还在动态规划" class="headerlink" title="LeetCode-Day37——还在动态规划"></a>LeetCode-Day37——还在动态规划</h2><h3 id="368-最大整除子集"><a href="#368-最大整除子集" class="headerlink" title="368. 最大整除子集"></a>368. 最大整除子集</h3><p>给出一个由无重复的正整数组成的集合，找出其中最大的整除子集，子集中任意一对 (Si，Sj) 都要满足：Si % Sj = 0 或 Sj % Si = 0。</p>
<p>如果有多个目标子集，返回其中任何一个均可。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">输出: [1,2] (当然, [1,3] 也正确)</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: [1,2,4,8]</span><br><span class="line">输出: [1,2,4,8]</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>其实也没啥思路，就是先进行排序，然后用<code>i</code>顺序遍历, 用<code>j</code> 在<code>[0, i]</code>区间内遍历，查找能否加入当前满足的最大的整除子集，记录下满足的点的下标。</p>
<p>然后逆向查找，返回<code>res</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; largestDivisibleSubset(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; index(n, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    sort(nums.begin(), nums.end());</span><br><span class="line">    <span class="keyword">int</span> maxStart = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; i;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] % nums[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[i] &lt; dp[j] + <span class="number">1</span>) &#123;</span><br><span class="line">                    dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">                    index[i] = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        maxStart = dp[maxStart] &gt; dp[i] ? maxStart : i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(maxStart &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">        res.push_back(nums[maxStart]);</span><br><span class="line">        maxStart = index[maxStart];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="375-猜数字大小II"><a href="#375-猜数字大小II" class="headerlink" title="375. 猜数字大小II"></a>375. 猜数字大小II</h3><p><strong>依然DP</strong></p>
<p>算法：</p>
<p>以<code>i</code>为第一次尝试找到最小开销的过程可以被分解为找左右区间内最小开销的子问题。对于每个区间，我们重复问题拆分的过程，得到更多子问题，这启发我们可以用DP解决这个问题。</p>
<p>我们需要使用一个<code>dp</code>数组，其中<code>dp(i, j)</code>代表在<code>(i, j)</code>中最坏情况下的最小开销。现在我们只需要考虑如何求出这个<code>dp</code>数组。如果区间只剩下一个数<code>k</code>,那么猜中的代价永远为0，因为我们区间里只剩下一个数字，也就是说，所有的<code>dp(k, k)</code>都初始化为0。然后，对于长度为2的区间，我们需要所有长度为1的区间的结果。由此我们可以看出，为了求出长度为len区间的解。因此我们按照区间长度从短到长求出<code>dp</code>数组。</p>
<p>现在，我们应该按照什么办法来求出<code>dp</code>矩阵呢？对于每个<code>dp(i, j)</code>，当前长度为<code>len = j - i + 1</code>，我们一次挑选每个数字作为第一次尝试的答案。</p>
<p><code>cost(i, j) = pivot + max(cost(i, pivot - 1), cost(pivot + 1, n))</code></p>
<p>但是在计算开销的时候，我们有一个便利之处，就是我们已经知道了小于len长度的<code>dp</code>数组的所有答案。因此dp方程变成了</p>
<p>$dp(i, j) = min_{pivots(i, j)}[pivot + max(dp[i, pivot - 1], dp[pivot + 1, n])]$</p>
<p>其中$min_{pivots(i, j)}$表示将<code>(i, j)</code>中的每个数作为第一个尝试的数字</p>
<p>上Code：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMoney</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="comment">// 遍历长度，分别枚举长度从2 - n的分段，因为长度为1的花销为0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> len = <span class="number">2</span>;len &lt;= n;len++) &#123;</span><br><span class="line">        <span class="comment">// 遍历start的位置，从start开始，取长度为len，所以start必须要小于等于(n - len + 1)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> start = <span class="number">1</span>;start &lt;= n - len + <span class="number">1</span>;start++) &#123;</span><br><span class="line">            <span class="keyword">int</span> minres = INT_MAX;</span><br><span class="line">            <span class="comment">// 遍历(start, start + len)的区间，寻找最小代价</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> piv = start; piv &lt; start + len - <span class="number">1</span>;piv++) &#123;</span><br><span class="line">                <span class="keyword">int</span> res = piv + max(dp[start][piv - <span class="number">1</span>], dp[piv + <span class="number">1</span>][start + len - <span class="number">1</span>]);</span><br><span class="line">                minres = min(res, minres);</span><br><span class="line">            &#125;</span><br><span class="line">            dp[start][start + len - <span class="number">1</span>] = minres;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">1</span>][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="403-青蛙过河"><a href="#403-青蛙过河" class="headerlink" title="403. 青蛙过河"></a>403. 青蛙过河</h3><p>一只青蛙想要过河。 假定河流被等分为 x 个单元格，并且在每一个单元格内都有可能放有一石子（也有可能没有）。 青蛙可以跳上石头，但是不可以跳入水中。</p>
<p>给定石子的位置列表（用单元格序号升序表示）， 请判定青蛙能否成功过河（即能否在最后一步跳至最后一个石子上）。 开始时， 青蛙默认已站在第一个石子上，并可以假定它第一步只能跳跃一个单位（即只能从单元格1跳至单元格2）。</p>
<p>如果青蛙上一步跳跃了 k 个单位，那么它接下来的跳跃距离只能选择为 k - 1、k 或 k + 1个单位。 另请注意，青蛙只能向前方（终点的方向）跳跃。</p>
<p>请注意：</p>
<p>石子的数量 ≥ 2 且 &lt; 1100；<br>每一个石子的位置序号都是一个非负整数，且其 &lt; 231；<br>第一个石子的位置永远是0。<br>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[0,1,3,5,6,8,12,17]</span><br><span class="line">总共有8个石子。</span><br><span class="line">第一个石子处于序号为0的单元格的位置, 第二个石子处于序号为1的单元格的位置,</span><br><span class="line">第三个石子在序号为3的单元格的位置， 以此定义整个数组...</span><br><span class="line">最后一个石子处于序号为17的单元格的位置。</span><br><span class="line"></span><br><span class="line">返回 true。即青蛙可以成功过河，按照如下方案跳跃： </span><br><span class="line">跳1个单位到第2块石子, 然后跳2个单位到第3块石子, 接着 </span><br><span class="line">跳2个单位到第4块石子, 然后跳3个单位到第6块石子, </span><br><span class="line">跳4个单位到第7块石子, 最后，跳5个单位到第8个石子（即最后一块石子）。</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[0,1,2,3,4,8,9,11]</span><br><span class="line"></span><br><span class="line">返回 false。青蛙没有办法过河。 </span><br><span class="line">这是因为第5和第6个石子之间的间距太大，没有可选的方案供青蛙跳跃过去。</span><br></pre></td></tr></table></figure>

<p>有点难… 嗯…看看代码注释吧</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canCross</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(stones[<span class="number">1</span>] != <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> len = stones.size();</span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">bool</span> dp[len+<span class="number">5</span>][<span class="number">1200</span>]; <span class="comment">//在第i个石头并且是跳j步过来的可以不?</span></span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; len;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; i;j++)&#123;   <span class="comment">//遍历前面的所有石头</span></span><br><span class="line">            <span class="keyword">int</span> dist = stones[i] - stones[j];  <span class="comment">//前面的石头一定是跳dist步过来的</span></span><br><span class="line">            <span class="keyword">if</span>(dist &gt; <span class="number">1100</span>) <span class="keyword">continue</span>;</span><br><span class="line">            dp[i][dist] |= dp[j][dist<span class="number">-1</span>]|dp[j][dist]|dp[j][dist+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(i == len<span class="number">-1</span> &amp;&amp; dp[i][dist])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="硬核的东西来辽-各种背包问题！！"><a href="#硬核的东西来辽-各种背包问题！！" class="headerlink" title="硬核的东西来辽~ 各种背包问题！！"></a>硬核的东西来辽~ 各种背包问题！！</h3><h4 id="一-01背包"><a href="#一-01背包" class="headerlink" title="一. 01背包"></a>一. 01背包</h4><h5 id="【题目描述】："><a href="#【题目描述】：" class="headerlink" title="【题目描述】："></a>【题目描述】：</h5><p><code>一个旅行者有一个最多能装M公斤的背包，现在有n件物品，他们的重量分别是W1，W2…Wn，它们的价值分别是C1，C2……Cn，求旅行者能够获得的最大总价值。</code></p>
<h5 id="【输入格式】："><a href="#【输入格式】：" class="headerlink" title="【输入格式】："></a>【输入格式】：</h5><p><code>第一行：两个整数，M，（背包容量，M&lt;=200）和N（物品数量N&lt;=30）</code></p>
<p><code>第2至N+1行，每行两个整数，Wi,Ci,表示每个物品的重量和价值。</code></p>
<h5 id="【输出格式】："><a href="#【输出格式】：" class="headerlink" title="【输出格式】："></a>【输出格式】：</h5><p><code>仅一行，一个数，表示最大总价值。</code></p>
<h5 id="【输入样例】："><a href="#【输入样例】：" class="headerlink" title="【输入样例】："></a>【输入样例】：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">10 4</span><br><span class="line">2 1</span><br><span class="line">3 3</span><br><span class="line">4 5</span><br><span class="line">7 9</span><br></pre></td></tr></table></figure>

<p>【输出样例】：12</p>
<h5 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h5><p>01背包问题可以说是最简单的背包问题，简单之处在于：它的每个物品只有一个。</p>
<p>首先定义一个<code>f[MAXN][MAXN]</code>数组，用来记录最大值，即<code>f[i][v]</code>表示的是当前<code>i</code>件物品放入一个容量为<code>v</code>的背包的时候可以获得的最大值。</p>
<p>01背包的<strong>状态转移方程</strong>为: <code>f[i][v] = max(f[i - 1][v], f[i - 1][v - w[i]] + c[i])</code></p>
<p> 解释：如果只考虑第<code>i</code>件物品的方式策略，那么就只和第<code>i - 1</code>件物品有关了，如果是放第<code>i</code>间物品，那么问题就转换为：“前<code>i - 1</code>件物品放入容量为v的背包中”，此时能够获得的最大价值就是<code>f[i - 1][v - w[i]]</code>，也就是第<code>i - 1</code>件物品放入容量为v(原来的总容量)减去<code>w[i]</code>(第<code>i</code>间物品的占容产生的价值)，再加上放通过第<code>i</code>件物品增加的价值<code>c[i]</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bag01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// m表示背包总容量，n表示有n件物品</span></span><br><span class="line">    <span class="keyword">int</span> m, n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> w[n + <span class="number">1</span>] = &#123;<span class="number">0</span>&#125;, c[n + <span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;dp(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; (m + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; w[i] &gt;&gt; c[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="comment">// 这里需要注意是逆序的，因为保证第i次循环dp[i][j]的状态是从dp[i][j - w[i]]递推而来的，也就是为了保证每件物品只选一次，保证在考虑“选入第i件物品”这件策略时，依据的绝不可能选入第i件物品的子结果f[i][v - w[i]]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = m;j &gt; <span class="number">0</span>;j--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(w[i] &lt;= j) &#123;</span><br><span class="line">                dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - w[i]] + c[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二-完全背包问题"><a href="#二-完全背包问题" class="headerlink" title="二. 完全背包问题"></a>二. 完全背包问题</h4><h5 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h5><p>设有n种物品，每种物品有一个价值，但每种物品的数量是无限的，同时有一个背包，最大承载量为m，今从n种物品中选取若干件，（同一种物品可以多次选举）使其重量的和小于等于m，而且价值的和最大。</p>
<h5 id="【输入】"><a href="#【输入】" class="headerlink" title="【输入】"></a>【输入】</h5><p>共N+1行</p>
<p>第一行：两个整数：M（背包容量M&lt;=200）和N（物品数量，N&lt;=30）；</p>
<p>第二行至第N+1行，每行两个整数，Wi，Ci，表示每个物品的重量和价值。</p>
<h5 id="【输出】"><a href="#【输出】" class="headerlink" title="【输出】"></a>【输出】</h5><p>近一行：一个数，表示最大的价值；</p>
<h5 id="【输入样例】"><a href="#【输入样例】" class="headerlink" title="【输入样例】"></a>【输入样例】</h5><p>10 4</p>
<p>2 1</p>
<p>3 3</p>
<p>4 5</p>
<p>7 9</p>
<h5 id="【输出样例】"><a href="#【输出样例】" class="headerlink" title="【输出样例】"></a>【输出样例】</h5><p>12</p>
<h5 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h5><p>这一个问题与01背包唯一不同的地方，就是<strong>每种物品的数量是无限多的</strong>。</p>
<p>既然每种物品可以取很多次，那么，与它相关的策略就不是取或者不取的问题了，而是<strong>不取和取多少</strong>的问题了。</p>
<p>这个时候，其实我们只需要多一层关于每种物品选多少次的循环就可以了。相对的，状态转移方程也会有相应的改动。</p>
<p><code>f[i][v] = max(f[i - 1][v], f[i - 1][v - k * w[i]] + k * c[i])</code></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://woojoo520.github.io/2019/09/20/LeetCode-Day36/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mariana">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Celery Fairy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/20/LeetCode-Day36/" itemprop="url">LeetCode-Day36</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-20T10:50:48+08:00">
                2019-09-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="264-丑数II"><a href="#264-丑数II" class="headerlink" title="264. 丑数II"></a>264. 丑数II</h3><p>编写一个程序，找出第 n 个丑数。</p>
<p>丑数就是只包含质因数 2, 3, 5 的正整数。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: n = 10</span><br><span class="line">输出: 12</span><br><span class="line">解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。</span><br><span class="line">说明:  </span><br><span class="line">    1 是丑数。</span><br><span class="line">    n 不超过1690。</span><br></pre></td></tr></table></figure>

<p>思路：<strong>动态规划</strong></p>
<p>每次都找已经存在的数中 * 2或 * 3 或 * 5之后较小的值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> i2 = <span class="number">0</span>, i3 = <span class="number">0</span>, i5 = <span class="number">0</span>, i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i++ &lt; n) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = min(<span class="number">2</span> * res[i2], min(<span class="number">3</span> * res[i3], <span class="number">5</span> * res[i5]));</span><br><span class="line">            res.push_back(tmp);</span><br><span class="line">            <span class="keyword">if</span>(tmp == <span class="number">2</span> * res[i2])  i2++;</span><br><span class="line">            <span class="keyword">if</span>(tmp == <span class="number">3</span> * res[i3])  i3++;</span><br><span class="line">            <span class="keyword">if</span>(tmp == <span class="number">5</span> * res[i5])  i5++;</span><br><span class="line">        &#125;     </span><br><span class="line">        <span class="keyword">return</span> res.back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Mariana</p>
              <p class="site-description motion-element" itemprop="description">a study blog</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">100</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mariana</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
