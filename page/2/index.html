<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="a study blog">
<meta property="og:type" content="website">
<meta property="og:title" content="Celery Fairy">
<meta property="og:url" content="https://woojoo520.github.io/page/2/index.html">
<meta property="og:site_name" content="Celery Fairy">
<meta property="og:description" content="a study blog">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Celery Fairy">
<meta name="twitter:description" content="a study blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://woojoo520.github.io/page/2/">





  <title>Celery Fairy</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <a href="https://github.com/woojoo520" class="github-corner" aria-label="View source on GitHub">
      <svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/>
      </svg>
    </a>
    <style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Celery Fairy</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Celery's Blog</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://woojoo520.github.io/2019/10/09/SQLServer-Day1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mariana">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Celery Fairy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/09/SQLServer-Day1/" itemprop="url">SQLServer-Day1</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-09T21:05:27+08:00">
                2019-10-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">表1: Person</span><br><span class="line"></span><br><span class="line">+-------------+---------+</span><br><span class="line">| 列名         | 类型     |</span><br><span class="line">+-------------+---------+</span><br><span class="line">| PersonId    | int     |</span><br><span class="line">| FirstName   | varchar |</span><br><span class="line">| LastName    | varchar |</span><br><span class="line">+-------------+---------+</span><br><span class="line">PersonId 是上表主键</span><br><span class="line">表2: Address</span><br><span class="line"></span><br><span class="line">+-------------+---------+</span><br><span class="line">| 列名         | 类型    |</span><br><span class="line">+-------------+---------+</span><br><span class="line">| AddressId   | int     |</span><br><span class="line">| PersonId    | int     |</span><br><span class="line">| City        | varchar |</span><br><span class="line">| State       | varchar |</span><br><span class="line">+-------------+---------+</span><br><span class="line">AddressId 是上表主键</span><br></pre></td></tr></table></figure>

<p>编写一个 SQL 查询，满足条件：无论 person 是否有地址信息，都需要基于上述两表提供 person 的以下信息：</p>
<p><code>FirstName, LastName, City, State</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> FirstName, LastName, City, State</span><br><span class="line"><span class="keyword">FROM</span> Person <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> Address</span><br><span class="line"><span class="keyword">on</span> Person.PersonId = Address.PersonId;</span><br></pre></td></tr></table></figure>

<p>数据库在连接两张或多张表来返回记录时，都会生成一张中间的临时表，然后再将这张临时表返回给用户。在使用<code>left join</code>时，<code>on</code>和<code>while</code>条件的区别如下：</p>
<ul>
<li><code>on</code>条件实在生成临时表时使用的条件，他不管on中的条件是否为真，都会返回左边表中的记录</li>
<li><code>where</code>条件是在临时表生成好后，再对临时表进行过滤的条件。这时已经没有<code>left join</code>的含义（必须返回左边表的记录了），条件不为真的就全部过滤掉。</li>
</ul>
<h3 id="183-从不订购的客户"><a href="#183-从不订购的客户" class="headerlink" title="183. 从不订购的客户"></a>183. 从不订购的客户</h3><p>某网站包含两个表，Customers 表和 Orders 表。编写一个 SQL 查询，找出所有从不订购任何东西的客户。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Customers 表：</span><br><span class="line">+----+-------+</span><br><span class="line">| Id | Name  |</span><br><span class="line">+----+-------+</span><br><span class="line">| 1  | Joe   |</span><br><span class="line">| 2  | Henry |</span><br><span class="line">| 3  | Sam   |</span><br><span class="line">| 4  | Max   |</span><br><span class="line">+----+-------+</span><br><span class="line">Orders 表：</span><br><span class="line">+----+------------+</span><br><span class="line">| Id | CustomerId |</span><br><span class="line">+----+------------+</span><br><span class="line">| 1  | 3          |</span><br><span class="line">| 2  | 1          |</span><br><span class="line">+----+------------+</span><br><span class="line">例如给定上述表格，你的查询应返回：</span><br><span class="line">+-----------+</span><br><span class="line">| Customers |</span><br><span class="line">+-----------+</span><br><span class="line">| Henry     |</span><br><span class="line">| Max       |</span><br><span class="line">+-----------+</span><br></pre></td></tr></table></figure>

<p>可以使用 <code>not in</code> 来查询不在此列表中的客户</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customers.name <span class="keyword">as</span> <span class="string">'Customers'</span></span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">where</span> customers.id <span class="keyword">not</span> <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> customerid <span class="keyword">from</span> orders   </span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="196-删除重复的电子邮箱"><a href="#196-删除重复的电子邮箱" class="headerlink" title="196. 删除重复的电子邮箱"></a>196. 删除重复的电子邮箱</h3><p>编写一个 SQL 查询，来删除 Person 表中所有重复的电子邮箱，重复的邮箱里只保留 Id 最小 的那个。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+----+------------------+</span><br><span class="line">| Id | Email            |</span><br><span class="line">+----+------------------+</span><br><span class="line">| 1  | john@example.com |</span><br><span class="line">| 2  | bob@example.com  |</span><br><span class="line">| 3  | john@example.com |</span><br><span class="line">+----+------------------+</span><br><span class="line">Id 是这个表的主键。</span><br><span class="line">例如，在运行你的查询语句之后，上面的 Person 表应返回以下几行:</span><br><span class="line"></span><br><span class="line">+----+------------------+</span><br><span class="line">| Id | Email            |</span><br><span class="line">+----+------------------+</span><br><span class="line">| 1  | john@example.com |</span><br><span class="line">| 2  | bob@example.com  |</span><br><span class="line">+----+------------------+</span><br></pre></td></tr></table></figure>

<p>先将词表与它自身在电子邮箱列中连接起来，然后我们需要找到其他记录中具有相同电子邮件地址的更大ID。所以在``WHERE`自自居中添加一个新的条件。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> p1 <span class="keyword">FROM</span> Person p1,</span><br><span class="line">    Person p2</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    p1.Email = p2.Email <span class="keyword">AND</span> p1.Id &gt; p2.Id</span><br></pre></td></tr></table></figure>

<h3 id="197-上升的温度"><a href="#197-上升的温度" class="headerlink" title="197. 上升的温度"></a>197. 上升的温度</h3><p>给定一个 Weather 表，编写一个 SQL 查询，来查找与之前（昨天的）日期相比温度更高的所有日期的 Id。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">+---------+------------------+------------------+</span><br><span class="line">| Id(INT) | RecordDate(DATE) | Temperature(INT) |</span><br><span class="line">+---------+------------------+------------------+</span><br><span class="line">|       1 |       2015-01-01 |               10 |</span><br><span class="line">|       2 |       2015-01-02 |               25 |</span><br><span class="line">|       3 |       2015-01-03 |               20 |</span><br><span class="line">|       4 |       2015-01-04 |               30 |</span><br><span class="line">+---------+------------------+------------------+</span><br><span class="line">例如，根据上述给定的 Weather 表格，返回如下 Id:</span><br><span class="line"></span><br><span class="line">+----+</span><br><span class="line">| Id |</span><br><span class="line">+----+</span><br><span class="line">|  2 |</span><br><span class="line">|  4 |</span><br><span class="line">+----+</span><br></pre></td></tr></table></figure>

<p>DATEIFF：计算DATA时间差</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A.Id <span class="keyword">as</span> <span class="string">"Id"</span></span><br><span class="line"><span class="keyword">FROM</span> Weather <span class="keyword">as</span> A, Weather <span class="keyword">as</span> B </span><br><span class="line"><span class="keyword">where</span> <span class="keyword">DATEDIFF</span>(A.RecordDate, B.RecordDate) = <span class="number">1</span> <span class="keyword">AND</span> A.Temperature &gt; B.Temperature</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://woojoo520.github.io/2019/10/09/LisGAN/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mariana">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Celery Fairy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/09/LisGAN/" itemprop="url">LisGAN</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-09T15:54:52+08:00">
                2019-10-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="论文阅读：Leveraging-the-Invariant-Side-of-Generative-Zero-Shot-Learning"><a href="#论文阅读：Leveraging-the-Invariant-Side-of-Generative-Zero-Shot-Learning" class="headerlink" title="论文阅读：Leveraging the Invariant Side of Generative Zero-Shot Learning"></a>论文阅读：Leveraging the Invariant Side of Generative Zero-Shot Learning</h2><h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><p><img src="C:%5CUsers%5C12751%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1570607788988.png" alt="1570607788988"></p>
<p>基于GAN的ZSL方法，通过生成样本的方式，将ZSL问题转换成全监督问题</p>
<p>本文的动机是利用（域）边的信息的GAN来<strong>生成特征</strong>，而不是生成样本。</p>
<blockquote>
<p>生成特征比生成样本好在那里?</p>
</blockquote>
<ul>
<li><p>提出了一个conditional Wasserstein GAN，输入是噪声和语义描述</p>
</li>
<li><p>定义了soul sample来作为generative ZSL不变方面【soul sample是类别的元表示】</p>
</li>
<li><p>提出串联的两个分类器，得到由粗到细的结果</p>
</li>
</ul>
<blockquote>
<p>generative ZSL不变的方面是每个类的soul sample，变的方面是每一个生成的样本，具体来说，seen类，每个生成样本是2048维的Resnet特征，而soul sample是seen类所有特征的均值</p>
</blockquote>
<p>GAN-based方法的主要问题：</p>
<ul>
<li>diversity多样性：怎么保证有限（一个）或者详细的属性条件下的生成多样性</li>
<li>reliability可靠性（discrimination判别性）：怎么确保每个生成样本和真实样本及其语义描述高度相关？</li>
</ul>
<h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><p><img src="C:%5CUsers%5C12751%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1570608194811.png" alt="1570608194811"></p>
<ul>
<li>利用WGAN生成未见类特征，输入是随机噪声和语义描述</li>
<li>多个soul samples用来对生成器进行调整</li>
<li>利用信心分数的未见类样本微调最后的结果</li>
</ul>
<h4 id="问题定义"><a href="#问题定义" class="headerlink" title="问题定义"></a>问题定义</h4><p>ZSL：$f: \mathcal {X}<em>{u} \rightarrow \mathcal {Y}</em>{u}$</p>
<p>GZSL: $f:{ \mathcal {X}, \mathcal {X}<em>{u} } \rightarrow \mathcal {Y} \cup {\mathcal {Y}</em>{u}}$</p>
<h4 id="整体的想法"><a href="#整体的想法" class="headerlink" title="整体的想法"></a>整体的想法</h4><ul>
<li>部署CWGAN是为了让类别嵌入（属性，语义描述）能够并入生成器G和判别器D</li>
<li>因为${A, Y}$ 和 ${A_u, Y_u}$ 是有联系的，即 $A$ 和 $A_u$ 有共同的语义空间，条件GAN如果能够为类生成高质量的样本，也可以期待它为unseen类生成高质量的样本</li>
</ul>
<h4 id="两个创新点"><a href="#两个创新点" class="headerlink" title="两个创新点"></a>两个创新点</h4><ul>
<li>利用soul sample来调整生成器</li>
<li>利用高信心分数的unseen类样本来微调后面的unseen类样本</li>
</ul>
<h4 id="soul-sample的好处"><a href="#soul-sample的好处" class="headerlink" title="soul sample的好处"></a>soul sample的好处</h4><p>soul sample缓解了域漂移问题</p>
<h3 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h3><h4 id="G的loss："><a href="#G的loss：" class="headerlink" title="G的loss："></a>G的loss：</h4><p>$L_{G}=-\mathbb{E}[D(G(z, a))]-\lambda \mathbb{E}[\log P(y | G(z, a))]$</p>
<p>其中，随机噪声${\mathrm{z}} \sim \mathcal{N}(0,1)$，语义描述a。第一项是Wasserstein损失，第二项是监督分类损失。</p>
<h4 id="D的loss："><a href="#D的loss：" class="headerlink" title="D的loss："></a>D的loss：</h4><p>$\begin{array}{c}{L_{D}=\mathbb{E}[D(G(z, a))]-E[D(x)]} \ {-\lambda(\mathbb{E}[\log P(y | G(z, a))])+\mathbb{E}[\log P(y | x)]} \ {-\beta \mathbb{E}\left[\left(\left|\nabla_{\hat{x}} D(\hat{x})\right|_{2}-1\right)^{2}\right]}\end{array}$</p>
<p>最后一项是强制的Lipschitz约束，$\hat{x}=\mu x+(1-\mu) G(z, a), \mu \sim U(0,1)$</p>
<h4 id="k个soul-sample"><a href="#k个soul-sample" class="headerlink" title="k个soul sample"></a>k个soul sample</h4><p>c类所有样本的均值就是c类的soul sample</p>
<h4 id="每个类别c应该有多个soul-sample来解决多视角问题"><a href="#每个类别c应该有多个soul-sample来解决多视角问题" class="headerlink" title="每个类别c应该有多个soul sample来解决多视角问题"></a>每个类别c应该有多个soul sample来解决多视角问题</h4><p>作者提出，将所有特征聚类成k个簇。为了简便，论文中k=3</p>
<p>每个类训练样本的soul sample的定义：</p>
<p>$s_{k}^{c}=\frac{1}{\left|X_{k}^{c}\right|} \sum_{x_{i} \in X_{k}^{c}} x_{i}$</p>
<p>每个类生成样本的soul sample的定义：</p>
<p>$\widetilde{s}<em>{k}^{c}=\frac{1}{\left|\tilde{X}</em>{k}^{c}\right|} \sum_{\tilde{x}<em>{i} \in \tilde{X}</em>{k}^{c}} \tilde{x}_{i}$</p>
<p>其中，$\tilde{x}_{i}=G(z, a)$是生成特征。</p>
<h4 id="两个正则项"><a href="#两个正则项" class="headerlink" title="两个正则项"></a>两个正则项</h4><p>每个生成样本至少要靠近某一个soul sample</p>
<p>$L_{R 1}=\frac{1}{n_{1}} \sum_{i=1}^{n_{1}} \min <em>{j \in[1, k]}\left|\tilde{x}</em>{i}-s_{j}^{c}\right|_{2}^{2}$</p>
<p>每个生成的soul sample必须靠近至少一个真实的soul sample</p>
<p>$L_{R 2}=\frac{1}{C} \sum_{c=1}^{C} \min <em>{j \in[1, k]}\left|\tilde{s}</em>{j}^{c}-s_{j}^{c}\right|_{2}^{2}$</p>
<h3 id="预测unseen类"><a href="#预测unseen类" class="headerlink" title="预测unseen类"></a>预测unseen类</h3><p>论文训练一个softmax分类器，对生成样本进行分类</p>
<p>$\begin{array}{l}{\min <em>{\theta}-\frac{1}{|\mathcal{X}|} \sum</em>{(x, y) \in(\mathcal{X}, \mathcal{Y})} \log P(y | x ; \theta)} \ {\log P(y | x ; \theta)=\frac{\exp \left(\theta_{y}^{T} x\right)}{\sum_{i=1}^{N} \exp \left(\theta_{i}^{T} x\right)}}\end{array}$</p>
<p>向量的熵可以用来测量结果的确定性。如果一个概率向量比较低的熵，我们对结果更有信心。</p>
<p>所以我们利用分类熵较低的样本，部署他们作为参考来对其他的未见类样本进行分类。</p>
<h4 id="样本熵"><a href="#样本熵" class="headerlink" title="样本熵"></a>样本熵</h4><p>$E(y)=-\sum_{c=1}^{C} y_{c} \log y_{c}$</p>
<p>本文的模型包含两个分类器。第一个分类器用来评估分类信心，第二个分类器用来利用正确分类的样本。本文的领样本是杯中，第一个分类器是一个生成假样本上训练的softmax，第二个分类器可以是一个训练的分类器，比如softmax分类器，SVM，或者就是一个不用训练的最近邻分类器。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://woojoo520.github.io/2019/10/09/CPU-affinity/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mariana">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Celery Fairy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/09/CPU-affinity/" itemprop="url">CPU affinity</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-09T09:17:13+08:00">
                2019-10-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="CPU-affinity（亲和性）"><a href="#CPU-affinity（亲和性）" class="headerlink" title="CPU affinity（亲和性）"></a>CPU affinity（亲和性）</h2><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h3><p>CPU affinity是一种调度属性，它可以将一个进程“绑定”到一个或一组CPU上</p>
<p>在SMP（Symmetric Multi-Processing对称多处理器）架构下，Linux调度器（scheduler）会根据CPU affinity的设置让指定的进程运行在“绑定”的CPU上，而不会在别的CPU上运行。</p>
<p>Linux调度器同样支持自然CPU亲和性；调度器会试图保持进程在相同的CPU上运行，这意味着进程通常不会在处理器之间频繁迁移，进程迁移的频率小意味着产生的负载小</p>
<p>因为程序的坐着比调度器更了解程序，所以我们可以手动地为其分配CPU核，而不会过多的占用CPU0，或者让我们关键进程和一对别的进程挤在一起，所有设置CPU亲和性可以是某些程序提高性能</p>
<h3 id="2-表示方法"><a href="#2-表示方法" class="headerlink" title="2. 表示方法"></a>2. 表示方法</h3><p>CPU affinity 使用位掩码（bitmask）表示，每一位都表示一个CPU，置1表示“绑定”</p>
<p>最低位表示第一个逻辑CPU，最高位表示最后一个逻辑CPU</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0x00000001</span><br><span class="line">    is processor #0</span><br><span class="line">0x00000003</span><br><span class="line">    is processors #0 and #1</span><br><span class="line">0xFFFFFFFF</span><br><span class="line">    is all processors (#0 through #31)</span><br></pre></td></tr></table></figure>

<h3 id="3-taskset-命令"><a href="#3-taskset-命令" class="headerlink" title="3. taskset 命令"></a>3. taskset 命令</h3><p>taskset命令用于获取或设定CPU亲和性</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://woojoo520.github.io/2019/10/06/自编码器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mariana">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Celery Fairy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/06/自编码器/" itemprop="url">自编码器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-06T21:02:40+08:00">
                2019-10-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="自编码器（Autoencoder）介绍"><a href="#自编码器（Autoencoder）介绍" class="headerlink" title="自编码器（Autoencoder）介绍"></a>自编码器（Autoencoder）介绍</h3><p><img src="https://pic4.zhimg.com/v2-f4444b7343ef311fd04f0dc0dc1db3b7_b.jpg" alt="img"></p>
<p>从上图可以看出，自编码器模型主要有编码器（encoder）和解码器（decoder）组成，其主要目的是将输入x转换成中间变量y，然后再将y转换成 $\widetilde x$，然后对比输入x和输出 $\widetilde x$ 使得他们两个无限接近</p>
<h3 id="神经网络自编码模型"><a href="#神经网络自编码模型" class="headerlink" title="神经网络自编码模型"></a>神经网络自编码模型</h3><p><img src="https://pic1.zhimg.com/v2-79a703718a568bbbe19a5cf6dfe1dc88_b.jpg" alt="img"></p>
<h4 id="神经网络自编码器的三大特点"><a href="#神经网络自编码器的三大特点" class="headerlink" title="神经网络自编码器的三大特点"></a>神经网络自编码器的三大特点</h4><ul>
<li>自编码器是数据相关的，这意味着自动编码器只能压缩那些与训练数据类似的数据，比如，使用人脸训练出来的自动编码器在压缩别的别的图片，比如树木，时性能很差，因为它学习到的特征是与人脸相关的</li>
<li>自动编码器是有损的，意思是解压缩的输出与原来的输入相比是退化的</li>
<li>自编码器是从数据样本中自动学习的，这意味着很容易对指定类的输入训练出一种特定的编码器，而不需要完成任何新工作</li>
</ul>
<h4 id="自编码器（Autoencode）搭建"><a href="#自编码器（Autoencode）搭建" class="headerlink" title="自编码器（Autoencode）搭建"></a>自编码器（Autoencode）搭建</h4><p>三洋工作：搭建编码器，搭建解码器，设定一个损失函数（用以衡量由于压缩而损失掉的信息）</p>
<p>编码器和解码器一般都是参数化的方程，并关于损失函数可导，典型的情况是使用神经网络。编码器和解码器的参数可以通过最小化损失函数而优化，根据上面介绍，自动编码器可看做由两个级联网络组成</p>
<ul>
<li><p>第一个网络是编码器，负责接收输入x，并将输入通过函数h变换为信号y：</p>
<p>$y = h(x)$</p>
</li>
<li><p>第二个网络将编码的信号y作为输入，通过函数f得到重构的信号r：</p>
<p>$r = f(y) = f(h(x))$</p>
</li>
<li><p>定义误差e为原始输入x与重构信号r之差，即$e = x - r$，网络训练的目标是减少均方误差（MSE），误差被反向传播回隐藏层</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://woojoo520.github.io/2019/10/06/PCA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mariana">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Celery Fairy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/06/PCA/" itemprop="url">PCA</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-06T20:50:23+08:00">
                2019-10-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>推导过程详见：<a href="https://zhuanlan.zhihu.com/p/77151308" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/77151308</a></p>
<h3 id="PCA算法步骤："><a href="#PCA算法步骤：" class="headerlink" title="PCA算法步骤："></a>PCA算法步骤：</h3><p>设有m条n维数据</p>
<ul>
<li>将原始数据按列组成n行m列矩阵$X$</li>
<li>将X的每一行进行零均值化，即减去这一行的均值</li>
<li>求出协方差矩阵$C = \frac {1} {m} X X^T$</li>
<li>求出协方差矩阵的特征值即对应的特征向量</li>
<li>将特征向量按对应特征值大小从上到下按行排列成矩阵，取前k行组成矩阵$P$</li>
<li>$Y=PX$即为降维到$K$维后的数据</li>
</ul>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ul>
<li>缓解维度灾难：PCA算法通过社区一部分信息之后能使得样本的采样密度增大（因为维数降低了），这是缓解维度灾难的重要手段</li>
<li>降噪：当数据收到噪声影响时，最小特征值对应的特征向量往往与噪声有关，将他们舍弃能在一定程度上起到降噪的效果</li>
<li>过拟合：PCA保留了主要信息，但这个主要信息只是针对训练集的，而且这个主要信息未必是重要信息。有可能舍弃了一些看似无用的信息，但这些看似无用的信息恰好是重要信息，只是在训练集上没有很大的表现，所以PCA也可能加剧了过拟合</li>
<li>特征独立：PCA不仅将数据压缩到低维，它也使得降维之后的数据各特征相互独立</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://woojoo520.github.io/2019/10/06/2019-10-6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mariana">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Celery Fairy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/06/2019-10-6/" itemprop="url">2019.10.6</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-06T17:18:00+08:00">
                2019-10-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="np-random-permutation"><a href="#np-random-permutation" class="headerlink" title="np.random.permutation()"></a>np.random.permutation()</h4><p><code>permutation:</code>返回一个新的，打乱顺序的数组，与shuffle的不同之处在于shuffle是直接在原数组上进行操作，没有返回值。而permutation不直接在原来的数组上进行操作，而是返回一个新的打乱顺序的数组，并不改变原来的数组</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = np.random.permutation(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">array([<span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">2</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.random.shuffle(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">6</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://woojoo520.github.io/2019/10/06/先验分布-后验分布-似然估计/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mariana">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Celery Fairy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/06/先验分布-后验分布-似然估计/" itemprop="url">先验分布/后验分布/似然估计</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-06T13:46:48+08:00">
                2019-10-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="后验分布"><a href="#后验分布" class="headerlink" title="后验分布"></a>后验分布</h3><p><strong>知道事情的结果，然后根据结果推测原因，即结果是由某个原因导致的概率就是后验概率。p(原因|结果)</strong></p>
<p>例子：</p>
<p>隔壁老王要去10公里外的一个地方办事，他 可以选择走路，骑自行车或者开车，并花费了一定时间到达目的地。在这个事件中，可以把交通方式（走路、骑车或开车）认为是原因，花费的时间认为是结果。若老王花了一个小时的时间完成了10公里的距离，那么很大可能是骑车过去的，当然也有较小可能老王是个健身达人跑步过去的，或者开车过去但是堵车很严重。若老王一共用了两个小时的时间完成了10公里的距离，那么很有可能他是走路过去的。若老王只用了二十分钟，那么很有可能是开车。这种先知道结果，然后由结果估计原因的概率分布，p(交通方式|时间)，就是后验概率。</p>
<p>预先<strong>已知结果</strong>，然后根据结果<strong>估计原因</strong>的概率分布即后验概率</p>
<p><code>P(因|果)  -&gt; P(θ|x)</code> </p>
<h3 id="先验分布"><a href="#先验分布" class="headerlink" title="先验分布"></a>先验分布</h3><p><strong>对未知参数x的先验信息用一个分布形式p(x)来表示，此分布p(x)称为未知参数x的先验分布.(即在实验前通过已知信息知道的分布)可以理解为对某个原因的经验推断。</strong></p>
<p>对于一个未知参数，在抽取样本之前就已经知道了一些关于该参数的信息。我们知道的途径可能来源于生活经验，自然规律等等。</p>
<p>例子：来源  <a href="https://blog.csdn.net/lsgqjh/article/details/79168156" target="_blank" rel="noopener">https://blog.csdn.net/lsgqjh/article/details/79168156</a></p>
<p>比如，测量自己的体重，在测量之前就可以推断出自己不会超过120斤，也不会少于90斤。这个推断可以理解为我们的生活经验所得。</p>
<p>比如测量某地的重力加速度，测量之前根据自然规律，就知道该地的重力加速度必然在9.8附近。这就是根据自然规律得到的先验信息。再根据自然规律，知道任何一个地方的重力加速度与标准不会相差0.1，这就是先验分布。可以写成G~(9.8,0.01)，这就是先验分布。</p>
<p><code>老王会走路，骑自行车，或者开车去某个地方，假设老王是个健身达人，且大家都知道，那么老王开车去的可能性就较小，跑步的可能性比较大，这就是根据我们的常识得到的先验分布。</code></p>
<p>根据历史规律确定<strong>原因</strong>的概率分布即先验概率</p>
<p><code>P(因) -&gt; P(θ)</code></p>
<h3 id="似然估计"><a href="#似然估计" class="headerlink" title="似然估计"></a>似然估计</h3><p><strong>与后验分布相反，后验分布根据结果推测原因，而似然估计则是根据原因推测该原因导致结果发生的概率。</strong></p>
<p>例子：</p>
<p>老王决定步行过去，那么很大可能10公里的距离大约需要两个小时；较小可能是老王平时坚持锻炼，跑步过去用了一个小时；更小可能是老王是个猛人，40分钟就到了。老王决定骑车过去，很可能一个小时就能到；较小可能是老王那天精神不错加上单双号限行交通很通畅，40分钟就到了；还有一种较小可能是老王运气很差，连着坏了好几辆共享单车，花了一个半小时才到。老王决定开车过去，很大可能是20分钟就到了，较小可能是那天堵车很严重，磨磨唧唧花了一个小时才到。这种先确定原因，根据原因来估计结果的概率分布，p(时间|交通方式)，就是似然估计。</p>
<p>补充：</p>
<p>如果老王去了那个地方好多次，我们只搜集到了老王这么多次花费的时间的信息，那么关于花费时间的概率分布 p(时间) 就叫evidence.</p>
<p><strong>先定下来原因</strong>，<strong>根据原因来估计结果</strong>的概率分布即似然估计。根据原因来统计各种可能结果的概率即似然函数</p>
<p><code>P(果|因) -&gt; P(x|θ)</code></p>
<h3 id="贝叶斯公式"><a href="#贝叶斯公式" class="headerlink" title="贝叶斯公式"></a>贝叶斯公式</h3><p>$P(A|B)=\frac{P(B | A) * P(A)}{P(B)}\ $</p>
<p>即 $P(\theta | x)=\frac{P(x | \theta) * P(\theta)}{P(x)}$</p>
<p>$后验概率=\frac{似然估计 * 先验概率} {evidence}$</p>
<p><code>注：P(x)即evidence。隔壁小哥去公园很多次，忽略交通方式是什么，只统计每次到达公园的时间x，于是得到了一组时间的概率分布。这种不考虑原因，值看到结果的概率分布即evidence，它也称为样本发生的概率分布的证据，即P(果)</code></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://woojoo520.github.io/2019/10/01/Lex-Learning/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mariana">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Celery Fairy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/01/Lex-Learning/" itemprop="url">Lex Learning</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-01T16:29:09+08:00">
                2019-10-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="LEX使用指南"><a href="#LEX使用指南" class="headerlink" title="LEX使用指南"></a>LEX使用指南</h2><p><strong>reference：</strong><a href="https://www.cnblogs.com/wp5719/p/5528896.html" target="_blank" rel="noopener">https://www.cnblogs.com/wp5719/p/5528896.html</a></p>
<p>Lex是由美国Bell实验室M.Lesk等人用C语言开发的一种词法分析器自动生成工具，它提供一种供开发者编写词法规则（正规式等）的语言（Lex语言）以及这种语言的翻译器（这种翻译器将Lex语言编写的规则翻译成为C语言程序）。</p>
<p>​     Lex是linux下的工具，本实验使用的编译工具是cygwin（cygwin在windows下模拟一个linux环境）下的flex，它与lex的使用方法基本相同，只有很少的差别。</p>
<h3 id="1-Lex的基本原理和使用方法Lex的基本工作原理为：由正规式生成NFA，将NFA变换成DFA，DFA经化简后，模拟生成词法分析器。"><a href="#1-Lex的基本原理和使用方法Lex的基本工作原理为：由正规式生成NFA，将NFA变换成DFA，DFA经化简后，模拟生成词法分析器。" class="headerlink" title="1.Lex的基本原理和使用方法Lex的基本工作原理为：由正规式生成NFA，将NFA变换成DFA，DFA经化简后，模拟生成词法分析器。"></a>1.Lex的基本原理和使用方法Lex的基本工作原理为：由正规式生成NFA，将NFA变换成DFA，DFA经化简后，模拟生成词法分析器。</h3><p>​    其中正规式由开发者使用Lex语言编写，其余部分由Lex翻译器完成.翻译器将Lex源程序翻译成一个名为lex.yy.c的C语言源文件，此文件含有两部分内容：一部分是根据正规式所构造的DFA状态转移表，另一部分是用来驱动该表的总控程序yylex()。当主程序需要从输入字符流中识别一个记号时，只需要调用一次yylex()就可以了。为了使用Lex所生成的词法分析器，我们需要将lex.yy.c程序用C编译器进行编译，并将相关支持库函数连入目标代码。Lex的使用步骤可如下图所示：</p>
<p><img src="http://img.blog.csdn.net/20151220202402465?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<h3 id="2-lex源程序的写法"><a href="#2-lex源程序的写法" class="headerlink" title="2.lex源程序的写法"></a>2.lex源程序的写法</h3><p>Lex源程序必须按照Lex语言的规范来写，其核心是一组词法规则（正规式）。一般而言，一个Lex程序分为三部分，三部分之间以符号%%分隔。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[第一部分：定义段]</span><br><span class="line">%%</span><br><span class="line">第二部分：词法规则段</span><br><span class="line">[%%</span><br><span class="line">第三部分：辅助函数段]</span><br></pre></td></tr></table></figure>

<p>其中第一部分以及第三部分和第三部分之上的%%都可以省略（即上述方括号括起的部分可以省略）。以%开头的符号和关键字，或者是词法规则段的各个规则一般顶着行首来写，前面没有空格</p>
<p>Lex中可以有注释，注释由/* 和 */括起，但是请注意，注释的行首需要有前导空白</p>
<h4 id="1）第一部分定义段的写法"><a href="#1）第一部分定义段的写法" class="headerlink" title="1）第一部分定义段的写法"></a>1）第一部分定义段的写法</h4><p>定义段可以分为两部分：</p>
<p>第一部分以符号<code>%{</code>和<code>%}</code>包裹，里面为以C语法写的一些定义和声明：例如，文件包含，宏定义，常数定义，全局变量及外部变量定义，函数声明等等。这一部分被Lex翻译器处理后会全部拷贝到文件lex.yy.c中。注意，特殊括号<code>%{</code>和<code>%}</code>都必须顶着行首写。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line">#define LT 1</span><br><span class="line">int yylval;</span><br><span class="line">%&#125;</span><br></pre></td></tr></table></figure>

<p>第二部分是一组正规定义和状态定义。正规定义是为了简化后面的词法规则而给部分正规式定义了名字。每条正规定义也都要顶着行首写。例如下面这组正规定义分别定义了letter，digit和id所表示的正规式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">letter		[A-Za-z]</span><br><span class="line">digit		[0-9]</span><br><span class="line">id			&#123;letter&#125;(&#123;letter&#125;|&#123;digit&#125;)*</span><br></pre></td></tr></table></figure>

<p>注意：上面正规定义中出现的小括号表示分组，而不是被匹配的字符。而大括号括起的部分表示正规定义名</p>
<p>状态定义也叫环境定义，它定义了匹配正规式时所处的状态的名字。状态定义以<code>%s</code>开始，后跟所定义的状态的名字，注意<code>%s</code>也要顶着行首写，例如下面一行就定义了一个名为COMMENT的状态和一个名为BAD的状态，状态名之间用空白符分隔：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%d COMMENT BAD</span><br></pre></td></tr></table></figure>

<h4 id="2-第二部分词法规则段的写法"><a href="#2-第二部分词法规则段的写法" class="headerlink" title="2) 第二部分词法规则段的写法"></a>2) 第二部分词法规则段的写法</h4><p>词法规则段列出的是词法分析器需要匹配的正规式，以及匹配正规式后需要进行的相关动作。其例子如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while		&#123;return (WHILE);&#125;</span><br><span class="line">do			&#123;return (DO);&#125;</span><br><span class="line">&#123;id&#125;		&#123;yylval = installID(); return (ID);&#125;</span><br></pre></td></tr></table></figure>

<p>每行都是一条规则，该规则的前一部分是正规式，需要顶着行首写，后一部分是匹配该正规式后需要进行的动作，这个动作使用C语法来写的，被包裹在<code>{}</code>之内，被Lex翻译器翻译后会被直接拷贝进lex.yy.c。正规式和语义动作之间要有空白隔开。其中用<code>{}</code>括住的正规式表示正规定义的名字</p>
<p>也可以若干个正规式匹配同一条语义动作，此时正规式之间要用<code>|</code>分隔</p>
<h4 id="3）第三部分辅助函数段的写法"><a href="#3）第三部分辅助函数段的写法" class="headerlink" title="3）第三部分辅助函数段的写法"></a>3）第三部分辅助函数段的写法</h4><p>辅助函数段用C语言语法来写，辅助函数一般是在词法规则段中用到的函数。这一部分一般会被直接拷贝进lex.yy.c中</p>
<h4 id="4）Lex源程序中词法规则（即正规式）的相关规定"><a href="#4）Lex源程序中词法规则（即正规式）的相关规定" class="headerlink" title="4）Lex源程序中词法规则（即正规式）的相关规定"></a>4）Lex源程序中词法规则（即正规式）的相关规定</h4><p> 详见Regulation Expression</p>
<h4 id="5）Lex源程序中常用到的变量及函数"><a href="#5）Lex源程序中常用到的变量及函数" class="headerlink" title="5）Lex源程序中常用到的变量及函数"></a>5）Lex源程序中常用到的变量及函数</h4><p><code>yyin</code>和<code>yyout</code>：这是Lex本身已定义的输入和输出文件指针。这两个变量指明了lex生成的词法分析器从哪里获得输入和输出到哪里。默认：键盘输入，屏幕输出</p>
<p><code>yytext</code>和<code>yyleng</code>：这也是lex中已定义的变量，直接用就可以了</p>
<p><code>yytext</code>：指向当前识别的词法单元（词文）的指针</p>
<p><code>yyleng</code>：当前词法单元的长度</p>
<p><code>ECHO</code>：Lex中预定义的宏，可以出现在动作中，相当于<code>fprintf(yyout, “%s”, yytext)</code>，即输出当前匹配的词法单元</p>
<p><code>yylex()</code>：词法分析驱动程序，用Lex翻译器生成的lex.yy.c内必然含有这个函数</p>
<p><code>yywrap()</code>：词法分析器遇到文件结尾时会调用<code>yywrap()</code>来决定下一步怎么做：</p>
<ul>
<li>若<code>yywrap()</code>返回0，则继续扫描</li>
<li>若返回1，则返回报告文件结尾的0标记</li>
</ul>
<p>由于词法分析器总会调用<code>yywrap</code>，因此辅助函数中最好提供<code>yywrap</code>，如果不提供，则在用C编译器编译lex.yy.c时，需要链接相应的库，库中会给出标准的<code>yywrap</code>函数（标准函数返回1）</p>
<h4 id="6）词法分析器的状态（环境）"><a href="#6）词法分析器的状态（环境）" class="headerlink" title="6）词法分析器的状态（环境）"></a>6）词法分析器的状态（环境）</h4><p>词法分析器在匹配正规式时，可以在不同状态（或环境下）运行。我们可以规定在不同状态下具有不同的匹配方式。每个词法分析器都至少有一个状态，这个状态叫做初始状态，可以用INITIAL或0来表示，如果还需要使用其他状态，可以在定义段用<code>%s</code>来定义。</p>
<p>在使用状态时，可以用如下方式写词法规则：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;state1, state2&gt; p0		&#123;action0;&#125;</span><br><span class="line">&lt;state1&gt; p1				&#123;action1;&#125;</span><br></pre></td></tr></table></figure>

<p>这两行词法规则表示：在状态<code>state1</code>和<code>state2</code>下，匹配正规式<code>p0</code>后执行动作<code>action0</code>，而在只有状态<code>state1</code>下，才可以匹配正规式<code>p1</code>后执行动作<code>action1</code>。如果不知名状态，默认情况下处于初始状态INITIAL。</p>
<p>要想进入某个特定状态，可以在动作中协商这样一句：<code>BEGIN state;</code>执行这个动作后，就进入状态<code>state</code></p>
<p>下面是一段处理C语言注释的例子，里面用到了状态的转换，在这个例子里，使用不同的状态，可以让词法分析器在处于注释中和处于注释外时使用不同的匹配规则</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">%s c_comment</span><br><span class="line">...</span><br><span class="line">%%</span><br><span class="line">&lt;INITIAL&gt;&quot;/*&quot; 		&#123;BEGIN c_comment;&#125;</span><br><span class="line">...</span><br><span class="line">&lt;c_comment&gt;&quot;*/&quot;		&#123;BEGIN 0;&#125;</span><br><span class="line">&lt;c_comment&gt;.		&#123;;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7）Lex的匹配原则"><a href="#7）Lex的匹配原则" class="headerlink" title="7）Lex的匹配原则"></a>7）Lex的匹配原则</h4><ul>
<li>按最长匹配原则确定被选中的单词</li>
<li>如果一个字符串能被若干正规式匹配，则先匹配排在前面的正规式</li>
</ul>
<h3 id="3-Lex生成的词法分析器如何使用"><a href="#3-Lex生成的词法分析器如何使用" class="headerlink" title="3.Lex生成的词法分析器如何使用"></a>3.<strong>Lex</strong>生成的词法分析器如何使用</h3><p>lex常常与语法分析器的生成工具yacc（第三章会讲到）同时使用。此时，一般来说，语法分析器每次都调用一次       yylex()获取一个记号。如果想自己写一个程序使用lex生成的词法分析器，则只需要在自己的程序中按需要调用yylex()函数即可。</p>
<p>​     请注意：yylex()调用结束后，输入缓冲区并不会被重置，而是仍然停留在刚才读到的地方。并且，词法分析器当前所处的状态（%s定义的那些状态）也不会改变。</p>
<p>​    完整的Lex源程序例子请见exam1.l和exam2.l。<br>​    <strong>exam1.l</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line">/* 这是注释的形式，与C中的/*...* /注释相同。 */</span><br><span class="line">/* 第一部分是定义、声明部分。这部分内容可以为空。*/</span><br><span class="line"></span><br><span class="line">%&#123;</span><br><span class="line"></span><br><span class="line">/* 写在 %&#123;...%&#125;这对特殊括号内的内容会被直接拷贝到C文件中。</span><br><span class="line"> *</span><br><span class="line"> * 这部分通常进行一些头文件声明，变量（全局，外部）、常量</span><br><span class="line"> * 的定义，用C语法。</span><br><span class="line"> *</span><br><span class="line"> * %&#123;和%&#125;两个符号都必须位于行首 </span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">/* 下面定义了需要识别的记号名，如果和yacc联合使用，这些记号名都应该在yacc中定义 */</span><br><span class="line">#include &lt;stdio.h&gt; </span><br><span class="line">#define LT					1</span><br><span class="line">#define	LE					2</span><br><span class="line">#define GT					3</span><br><span class="line">#define	GE					4</span><br><span class="line">#define	EQ					5</span><br><span class="line">#define NE					6</span><br><span class="line"></span><br><span class="line">#define WHILE				18</span><br><span class="line">#define	DO					19</span><br><span class="line">#define ID          20</span><br><span class="line">#define NUMBER      21</span><br><span class="line">#define RELOP       22</span><br><span class="line"></span><br><span class="line">#define NEWLINE     23</span><br><span class="line">#define ERRORCHAR   24</span><br><span class="line"></span><br><span class="line">int yylval;</span><br><span class="line">/* yylval 是yacc中定义的变量，用来保存记号的属性值，默认是int类型。 </span><br><span class="line"> * 在用lex实现的词法分析器中可以使用这个变量将记号的属性传递给用</span><br><span class="line"> * yacc实现的语法分析器。</span><br><span class="line"> *</span><br><span class="line"> * 注意：该变量只有在联合使用lex和yacc编写词法和语法分析器时才可在lex</span><br><span class="line"> *       中使用，此时该变量不需要定义即可使用。</span><br><span class="line"> *       单独使用lex时，编译器找不到这个变量。这里定义该变量为了“欺骗”编译器。</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">/* 这里进行正规定义和状态定义。</span><br><span class="line"> * 下面就是正规定义，注意，正规定义和状态定义都要顶着行首写。</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">delim		[ \t \n]</span><br><span class="line">/* \用来表示转义，例如\t表示制表符，\n表示换行符。*/</span><br><span class="line">ws			&#123;delim&#125;+</span><br><span class="line">letter	[A-Za-z_]</span><br><span class="line">digit		[0-9]</span><br><span class="line">id			&#123;letter&#125;(&#123;letter&#125;|&#123;digit&#125;)*</span><br><span class="line">/* 注意：上面正规定义中出现的小括号表示分组，而不是被匹配的字符。</span><br><span class="line"> *       而大括号括起的部分表示正规定义名。</span><br><span class="line"> */</span><br><span class="line">number	&#123;digit&#125;+(\.&#123;digit&#125;+)?(E[+-]?&#123;digit&#125;+)?</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* %%作为lex文件三个部分的分割符，必须位于行首 */</span><br><span class="line">/* 下面这个%%不能省略 */</span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">  /* 第二部分是翻译规则部分。 */</span><br><span class="line">  /* 写在这一部分的注释要有前导空格，否则lex编译出错。*/</span><br><span class="line">  /* 翻译规则的形式是：正规式  &#123;动作&#125;</span><br><span class="line">   * 其中，正规式要顶行首写，动作要以C语法写（动作会被拷贝到yylex()函数中，），\</span><br><span class="line">   * 正规式和动作之间要用空白分割。</span><br><span class="line">   */</span><br><span class="line">  </span><br><span class="line">&#123;ws&#125;	          &#123;;/* 此时词法分析器没有动作，也不返回，而是继续分析。 */&#125;</span><br><span class="line">  /* 正规式部分用大括号扩住的表示正规定义名，例如&#123;ws&#125;。</span><br><span class="line">   * 没有扩住的直接表示正规式本身。</span><br><span class="line">   * 一些元字符没办法表示它本身，此时可以用转义字符或</span><br><span class="line">   * 用双引号括起来，例如&quot;&lt;&quot;</span><br><span class="line">   */</span><br><span class="line">while	          &#123;return (WHILE);&#125;</span><br><span class="line">do		          &#123;return (DO);&#125;</span><br><span class="line">&#123;id&#125;	          &#123;yylval = installID (); return (ID);&#125;</span><br><span class="line">&#123;number&#125;	      &#123;yylval = installNum (); return (NUMBER);&#125;</span><br><span class="line">&quot;&lt;&quot;	            &#123;yylval = LT; return (RELOP);&#125;</span><br><span class="line">&quot;&lt;=&quot;	          &#123;yylval = LE; return (RELOP);&#125;</span><br><span class="line">&quot;=&quot;	            &#123;yylval = EQ; return (RELOP);&#125;</span><br><span class="line">&quot;&lt;&gt;&quot;	          &#123;yylval = NE; return (RELOP);&#125;</span><br><span class="line">&quot;&gt;&quot;	            &#123;yylval = GT; return (RELOP);&#125;</span><br><span class="line">&quot;&gt;=&quot;	          &#123;yylval = GE; return (RELOP);&#125;</span><br><span class="line"></span><br><span class="line">.								&#123;yylval = ERRORCHAR; return ERRORCHAR;&#125;</span><br><span class="line"> /*.匹配除换行之外的任何字符，一般可作为最后一条翻译规则。*/</span><br><span class="line"> </span><br><span class="line">%%</span><br><span class="line">/* 第三部分是辅助函数部分，这部分内容以及前面的%%都可以省略 */</span><br><span class="line">/* 辅助函数可以定义“动作”中使用的一些函数。这些函数</span><br><span class="line"> * 使用C语言编写，并会直接被拷贝到lex.yy.c中。</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">int installID () &#123;</span><br><span class="line">  /* 把词法单元装入符号表并返回指针。*/</span><br><span class="line">	return ID;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int installNum () &#123;</span><br><span class="line">	/* 类似上面的过程，但词法单元不是标识符而是数 */</span><br><span class="line">  return NUMBER;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* yywrap这个辅助函数是词法分析器遇到输入文件结尾时会调用的，用来决定下一步怎么做：</span><br><span class="line"> * 若yywrap返回0，则继续扫描；返回1，则词法分析器返回报告文件已结束的0。</span><br><span class="line"> * lex库中的标准yywrap程序就是返回1，你也可以定义自己的yywrap。</span><br><span class="line"> */</span><br><span class="line">int yywrap ()&#123;</span><br><span class="line">  return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void writeout(int c)&#123;</span><br><span class="line">  switch(c)&#123;</span><br><span class="line">  	case ERRORCHAR: fprintf(yyout, &quot;(ERRORCHAR, \&quot;%s\&quot;) &quot;, yytext);break;</span><br><span class="line">  	case RELOP: fprintf(yyout, &quot;(RELOP, \&quot;%s\&quot;) &quot;, yytext);break;  	  </span><br><span class="line">    case WHILE: fprintf(yyout, &quot;(WHILE, \&quot;%s\&quot;) &quot;, yytext);break;</span><br><span class="line">    case DO: fprintf(yyout, &quot;(DO, \&quot;%s\&quot;) &quot;, yytext);break;</span><br><span class="line">    case NUMBER: fprintf(yyout, &quot;(NUM, \&quot;%s\&quot;) &quot;, yytext);break;</span><br><span class="line">    case ID: fprintf(yyout, &quot;(ID, \&quot;%s\&quot;) &quot;, yytext);break;</span><br><span class="line">    case NEWLINE: fprintf(yyout, &quot;\n&quot;);break;</span><br><span class="line">    default:break;</span><br><span class="line">  &#125;</span><br><span class="line">  return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 辅助函数里可以使用yytext和yyleng这些外部定义的变量。</span><br><span class="line"> * yytext指向输入缓冲区当前词法单元(lexeme)的第一个字符，</span><br><span class="line"> * yyleng给出该词法单元的长度		*/</span><br><span class="line"></span><br><span class="line">/* 如果你的词法分析器并不是作为语法分析器的子程序，</span><br><span class="line"> * 而是有自己的输入输出，你可以在这里定义你的词法</span><br><span class="line"> * 分析器的main函数，main函数里可以调用yylex()</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">int main (int argc, char ** argv)&#123;</span><br><span class="line">	int c,j=0;</span><br><span class="line">	if (argc&gt;=2)&#123;</span><br><span class="line">	  if ((yyin = fopen(argv[1], &quot;r&quot;)) == NULL)&#123;</span><br><span class="line">	    printf(&quot;Can&apos;t open file %s\n&quot;, argv[1]);</span><br><span class="line">	    return 1;</span><br><span class="line">	  &#125;</span><br><span class="line">	  if (argc&gt;=3)&#123;</span><br><span class="line">	    yyout=fopen(argv[2], &quot;w&quot;);</span><br><span class="line">	  &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	/* yyin和yyout是lex中定义的输入输出文件指针，它们指明了</span><br><span class="line">	 * lex生成的词法分析器从哪里获得输入和输出到哪里。</span><br><span class="line">	 * 默认：键盘输入，屏幕输出。 </span><br><span class="line">	 */</span><br><span class="line">	while (c = yylex())&#123;</span><br><span class="line">		writeout(c);</span><br><span class="line">		j++;</span><br><span class="line">		if (j%5 == 0) writeout(NEWLINE);</span><br><span class="line">	&#125;</span><br><span class="line">	if(argc&gt;=2)&#123;</span><br><span class="line">	  fclose(yyin);</span><br><span class="line">	  if (argc&gt;=3) fclose(yyout);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>exam2.l</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line">/* 把注释去掉 */</span><br><span class="line"></span><br><span class="line">%&#123;</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt; </span><br><span class="line">#define LT					1</span><br><span class="line">#define	LE					2</span><br><span class="line">#define GT					3</span><br><span class="line">#define	GE					4</span><br><span class="line">#define	EQ					5</span><br><span class="line">#define NE					6</span><br><span class="line">#define LLK                                     7</span><br><span class="line">#define RLK                                     8</span><br><span class="line">#define LBK                                     9</span><br><span class="line">#define RBK                                     10</span><br><span class="line">#define IF                               11</span><br><span class="line">#define ELSE                             12</span><br><span class="line">#define EQU                              13</span><br><span class="line">#define SEM                              14</span><br><span class="line"></span><br><span class="line">#define WHILE				18</span><br><span class="line">#define	DO					19</span><br><span class="line">#define ID          20</span><br><span class="line">#define NUMBER      21</span><br><span class="line">#define RELOP       22</span><br><span class="line"></span><br><span class="line">#define NEWLINE     23</span><br><span class="line">#define ERRORCHAR   24</span><br><span class="line">#define ADD                       25</span><br><span class="line">#define  DEC                         26</span><br><span class="line">#define  MUL                         27</span><br><span class="line">#define  DIV                        28</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">delim		[ \t \n]</span><br><span class="line">ws			&#123;delim&#125;+</span><br><span class="line">letter	[A-Za-z_]</span><br><span class="line">digit		[0-9]</span><br><span class="line">id			&#123;letter&#125;(&#123;letter&#125;|&#123;digit&#125;)*</span><br><span class="line">number	&#123;digit&#125;+(\.&#123;digit&#125;+)?(E[+-]?&#123;digit&#125;+)?</span><br><span class="line"></span><br><span class="line">/* 状态（或条件）定义可以定义在这里 </span><br><span class="line"> * INITIAL是一个默认的状态，不需要定义</span><br><span class="line"> */</span><br><span class="line">%s COMMENT</span><br><span class="line">%s COMMENT2</span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">&lt;INITIAL&gt;&quot;/*&quot;						&#123;BEGIN COMMENT;&#125;</span><br><span class="line">&lt;COMMENT&gt;&quot;*/&quot;						&#123;BEGIN INITIAL;&#125;</span><br><span class="line">&lt;COMMENT&gt;.|\n						&#123;;&#125;</span><br><span class="line">&lt;INITIAL&gt;&quot;//&quot;						&#123;BEGIN COMMENT2;&#125;</span><br><span class="line">&lt;COMMENT2&gt;\n					&#123;BEGIN INITIAL;&#125;</span><br><span class="line">&lt;COMMENT2&gt;.					&#123;;&#125;</span><br><span class="line"></span><br><span class="line"> /* ECHO是一个宏，相当于 fprintf(yyout, &quot;%s&quot;, yytext)*/</span><br><span class="line"></span><br><span class="line">&lt;INITIAL&gt;&#123;ws&#125;	          &#123;;&#125;</span><br><span class="line">&lt;INITIAL&gt;while					&#123;return (WHILE);&#125;</span><br><span class="line">&lt;INITIAL&gt;do		          &#123;return (DO);&#125;</span><br><span class="line">&lt;INITIAL&gt;if		          &#123;return (IF);&#125;</span><br><span class="line">&lt;INITIAL&gt;else		          &#123;return (ELSE);&#125;</span><br><span class="line">&lt;INITIAL&gt;&#123;id&#125;	          &#123;return (ID);&#125;</span><br><span class="line">&lt;INITIAL&gt;&#123;number&#125;	      &#123;return (NUMBER);&#125;</span><br><span class="line">&lt;INITIAL&gt;&quot;&lt;&quot;	          &#123;return (RELOP);&#125;</span><br><span class="line">&lt;INITIAL&gt;&quot;&lt;=&quot;	          &#123;return (RELOP);&#125;</span><br><span class="line">&lt;INITIAL&gt;&quot;=&quot;	          &#123;return (RELOP);&#125;</span><br><span class="line">&lt;INITIAL&gt;&quot;!=&quot;	          &#123;return (RELOP);&#125;</span><br><span class="line">&lt;INITIAL&gt;&quot;&gt;&quot;	          &#123;return (RELOP);&#125;</span><br><span class="line">&lt;INITIAL&gt;&quot;&gt;=&quot;	          &#123;return (RELOP);&#125;</span><br><span class="line">&lt;INITIAL&gt;&quot;(&quot;	          &#123;return (RELOP);&#125;</span><br><span class="line">&lt;INITIAL&gt;&quot;)&quot;	          &#123;return (RELOP);&#125;</span><br><span class="line">&lt;INITIAL&gt;&quot;&#123;&quot;	          &#123;return (RELOP);&#125;</span><br><span class="line">&lt;INITIAL&gt;&quot;&#125;&quot;	          &#123;return (RELOP);&#125;</span><br><span class="line">&lt;INITIAL&gt;&quot;+&quot;	          &#123;return (RELOP);&#125;</span><br><span class="line">&lt;INITIAL&gt;&quot;-&quot;	          &#123;return (RELOP);&#125;</span><br><span class="line">&lt;INITIAL&gt;&quot;*&quot;	          &#123;return (RELOP);&#125;</span><br><span class="line">&lt;INITIAL&gt;&quot;/&quot;	          &#123;return (RELOP);&#125;</span><br><span class="line">&lt;INITIAL&gt;&quot;;&quot;	          &#123;return (RELOP);&#125;</span><br><span class="line"></span><br><span class="line">&lt;INITIAL&gt;.							&#123;return ERRORCHAR;&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">int yywrap ()&#123;</span><br><span class="line">  return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void writeout(int c)&#123;</span><br><span class="line">  switch(c)&#123;</span><br><span class="line">  	case ERRORCHAR: fprintf(yyout, &quot;(ERRORCHAR, \&quot;%s\&quot;) &quot;, yytext);break;</span><br><span class="line">  	case RELOP: fprintf(yyout, &quot;(RELOP, \&quot;%s\&quot;) &quot;, yytext);break;  	  </span><br><span class="line">    case WHILE: fprintf(yyout, &quot;(WHILE, \&quot;%s\&quot;) &quot;, yytext);break;</span><br><span class="line">    case DO: fprintf(yyout, &quot;(DO, \&quot;%s\&quot;) &quot;, yytext);break;</span><br><span class="line">    case IF: fprintf(yyout, &quot;(IF, \&quot;%s\&quot;) &quot;, yytext);break;</span><br><span class="line">   case ELSE: fprintf(yyout, &quot;(ELSE, \&quot;%s\&quot;) &quot;, yytext);break;</span><br><span class="line">    case NUMBER: fprintf(yyout, &quot;(NUM, \&quot;%s\&quot;) &quot;, yytext);break;</span><br><span class="line">    case ID: fprintf(yyout, &quot;(ID, \&quot;%s\&quot;) &quot;, yytext);break;</span><br><span class="line">    case NEWLINE: fprintf(yyout, &quot;\n&quot;);break;</span><br><span class="line">    default:break;</span><br><span class="line">  &#125;</span><br><span class="line">  return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main (int argc, char ** argv)&#123;</span><br><span class="line">	int c,j=0;</span><br><span class="line">	if (argc&gt;=2)&#123;</span><br><span class="line">	  if ((yyin = fopen(argv[1], &quot;r&quot;)) == NULL)&#123;</span><br><span class="line">	    printf(&quot;Can&apos;t open file %s\n&quot;, argv[1]);</span><br><span class="line">	    return 1;</span><br><span class="line">	  &#125;</span><br><span class="line">	  if (argc&gt;=3)&#123;</span><br><span class="line">	    yyout=fopen(argv[2], &quot;w&quot;);</span><br><span class="line">	  &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	while (c = yylex())&#123;</span><br><span class="line">		writeout(c);</span><br><span class="line">		j++;</span><br><span class="line">		if (j%5 == 0) writeout(NEWLINE);</span><br><span class="line">	&#125;</span><br><span class="line">	if(argc&gt;=2)&#123;</span><br><span class="line">	  fclose(yyin);</span><br><span class="line">	  if (argc&gt;=3) fclose(yyout);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-编译Lex文件"><a href="#4-编译Lex文件" class="headerlink" title="4. 编译Lex文件"></a>4. 编译Lex文件</h3><p>先将<code>win_flex.exe</code>加入到环境变量，然后运行：</p>
<p><code>win_flex.exe --wincompat a.l　　　　　　// wincompat参数不能省</code></p>
<p>然后运行</p>
<p><code>g++ .\lex.yy.c</code></p>
<p>然后生成了一个a.exe，并运行</p>
<p><code>.\a.exe hello.cpp out.txt</code></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://woojoo520.github.io/2019/10/01/LeetCode-Day43/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mariana">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Celery Fairy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/01/LeetCode-Day43/" itemprop="url">LeetCode-Day43</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-01T09:31:44+08:00">
                2019-10-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="LeetCode-Day43——背包问题实战"><a href="#LeetCode-Day43——背包问题实战" class="headerlink" title="LeetCode-Day43——背包问题实战"></a>LeetCode-Day43——背包问题实战</h2><h3 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416. 分割等和子集"></a>416. 分割等和子集</h3><p>给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
<p>注意:</p>
<p>每个数组中的元素不会超过 100<br>数组的大小不会超过 200<br>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1, 5, 11, 5]</span><br><span class="line">输出: true</span><br><span class="line">解释: 数组可以分割成 [1, 5, 5] 和 [11].</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1, 2, 3, 5]</span><br><span class="line">输出: false</span><br><span class="line">解释: 数组不能分割成两个元素和相等的子集.</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>这就是一个01背包准确值的问题</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.size();i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">if</span>(sum % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> target = sum / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(target + <span class="number">1</span>, INT_MIN);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = target;i &gt;= num;i--) &#123;</span><br><span class="line">                dp[i] = max(dp[i], dp[i - num] + num);</span><br><span class="line">                dp[i] = dp[i] &lt; <span class="number">0</span> ? INT_MIN : dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[target] == target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="494-目标和"><a href="#494-目标和" class="headerlink" title="494. 目标和"></a>494. 目标和</h3><p>给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。</p>
<p>返回可以使最终数组和为目标数 S 的所有添加符号的方法数。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入: nums: [1, 1, 1, 1, 1], S: 3</span><br><span class="line">输出: 5</span><br><span class="line">解释: </span><br><span class="line"></span><br><span class="line">-1+1+1+1+1 = 3</span><br><span class="line">+1-1+1+1+1 = 3</span><br><span class="line">+1+1-1+1+1 = 3</span><br><span class="line">+1+1+1-1+1 = 3</span><br><span class="line">+1+1+1+1-1 = 3</span><br><span class="line"></span><br><span class="line">一共有5种方法让最终目标和为3。</span><br></pre></td></tr></table></figure>

<p>注意:</p>
<p>数组非空，且长度不会超过20。<br>初始的数组的和不会超过1000。<br>保证返回的最终结果能被32位整数存下。</p>
<p>思路：</p>
<p>这道题实际上就是01背包问题，假设取加号部分的和为<code>x</code>，取减号部分的和为<code>y</code>，则有</p>
<p><code>x + y = sum(nums)</code></p>
<p><code>x - y = S</code></p>
<p>则直接可以求解    <code>x = (sum + S) / 2</code></p>
<p>所以这道题本质上就是在问你，从这些数当中取出哪些数，可以让和为<code>x</code>，这样我们就将问题转换为01背包问题了</p>
<p>上Code：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;           </span><br><span class="line">        <span class="keyword">if</span>(sum &lt; S || (sum + S) % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> target = (sum + S) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; dp(target + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = target;i &gt;= num;i--) &#123;</span><br><span class="line">                dp[i] += dp[i - num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里需要注意一件事情，就是这里的<code>dp</code>数组表示的是方法的种数。</p>
<h3 id="474-一和零"><a href="#474-一和零" class="headerlink" title="474. 一和零"></a>474. 一和零</h3><p>在计算机界中，我们总是追求用有限的资源获取最大的收益。</p>
<p>现在，假设你分别支配着 m 个 0 和 n 个 1。另外，还有一个仅包含 0 和 1 字符串的数组。</p>
<p>你的任务是使用给定的 m 个 0 和 n 个 1 ，找到能拼出存在于数组中的字符串的最大数量。每个 0 和 1 至多被使用一次。</p>
<p>注意:</p>
<p>给定 0 和 1 的数量都不会超过 100。<br>给定字符串数组的长度不会超过 600。<br>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: Array = &#123;&quot;10&quot;, &quot;0001&quot;, &quot;111001&quot;, &quot;1&quot;, &quot;0&quot;&#125;, m = 5, n = 3</span><br><span class="line">输出: 4</span><br><span class="line">解释: 总共 4 个字符串可以通过 5 个 0 和 3 个 1 拼出，即 &quot;10&quot;,&quot;0001&quot;,&quot;1&quot;,&quot;0&quot; 。</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: Array = &#123;&quot;10&quot;, &quot;0&quot;, &quot;1&quot;&#125;, m = 1, n = 1</span><br><span class="line">输出: 2</span><br><span class="line">解释: 你可以拼出 &quot;10&quot;，但之后就没有剩余数字了。更好的选择是拼出 &quot;0&quot; 和 &quot;1&quot; 。</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>就把这个问题想象成有两个约束条件的多维背包问题，状态转换方程为：</p>
<p><code>f[i, u, v] = max(f[i - 1, u, v], f[u - 1][u - Di][v - Ci] + Wi)</code></p>
<p>然后优化空间和时间的方法，就是变成二维数组，加上倒着遍历！</p>
<p>上Code：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; countZO(<span class="built_in">string</span> str) &#123;</span><br><span class="line">        pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; ans(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : str) &#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">'0'</span>) &#123;</span><br><span class="line">                ans.first++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans.second++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaxForm</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">string</span> str : strs) &#123;</span><br><span class="line">            pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; zo = countZO(str);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = m;i &gt;= zo.first;i--) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = n;j &gt;= zo.second;j--) &#123;</span><br><span class="line">                    dp[i][j] = max(dp[i][j], dp[i - zo.first][j - zo.second] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://woojoo520.github.io/2019/10/01/Regular-expression/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mariana">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Celery Fairy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/01/Regular-expression/" itemprop="url">Regular expression</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-01T09:31:19+08:00">
                2019-10-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Regular-Expression——正则表达式"><a href="#Regular-Expression——正则表达式" class="headerlink" title="Regular Expression——正则表达式"></a>Regular Expression——正则表达式</h2><p>正则表达式描述了一种字符串匹配的模式，可以用来检查一个串是否含有某种子串，将匹配的子串替换或者从某个子串中取出某个符合条件的子串等</p>
<h3 id="普通字符"><a href="#普通字符" class="headerlink" title="普通字符"></a>普通字符</h3><p>普通字符包括没有显示指定为元字符的所有可打印和不可打印字符。这包括所有大写字母和小写字母，所有数字，所有标点符号和一些其他符号</p>
<h3 id="非打印字符"><a href="#非打印字符" class="headerlink" title="非打印字符"></a>非打印字符</h3><p>非打印字符也可以是正则表达式的组成部分。下标列出了表示非打印字符的转义序列</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>\cx</td>
<td>匹配由x指明的而控制字符。例如\cM控制一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的‘c’字符</td>
</tr>
<tr>
<td>\f</td>
<td>匹配一个换页符</td>
</tr>
<tr>
<td>\n</td>
<td>匹配一个换行符</td>
</tr>
<tr>
<td>\r</td>
<td>匹配一个回车符</td>
</tr>
<tr>
<td>\s</td>
<td>匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]。注意Unicode正则表达式会匹配全角空格符</td>
</tr>
<tr>
<td>\S</td>
<td>匹配任何非空白字符。等价于[^ \f\n\r\t\v ]</td>
</tr>
<tr>
<td>\t</td>
<td>匹配一个制表符</td>
</tr>
<tr>
<td>\v</td>
<td>匹配一个垂直制表符</td>
</tr>
</tbody></table>
<h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h3><p>许多元字符要求在试图匹配他们时特别对待。托要匹配他们，必须首先使字符“转义”，即，将反斜杠\放在他们前面。下标列出了正则表达式中的特殊字符</p>
<table>
<thead>
<tr>
<th>特殊字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>$</td>
<td>匹配输入字符串的结尾位置。如果设置了RegExp对象的Multiline属性，则 $ 也匹配‘\n’或‘\r’。要匹配\$本身需要使用 \ $</td>
</tr>
<tr>
<td>()</td>
<td>标记一个子表达式的开始和结束位置。字表达式可以获取供以后使用</td>
</tr>
<tr>
<td>*</td>
<td>匹配前面的子表达式零次或多次。</td>
</tr>
<tr>
<td>+</td>
<td>匹配前面的子表达式一次或多次。</td>
</tr>
<tr>
<td>.</td>
<td>匹配除换行符\n以外的任何单字符</td>
</tr>
<tr>
<td>[</td>
<td>标记一个中括号表达式的开始</td>
</tr>
<tr>
<td>?</td>
<td>匹配前面的子表达式零次或一次，或指明一个非贪婪限定符</td>
</tr>
<tr>
<td>\</td>
<td>将下一个字符标记为或特殊字符，或原义字符，或向后引用，或八进制转义符</td>
</tr>
<tr>
<td>^</td>
<td>匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。</td>
</tr>
<tr>
<td>{</td>
<td>标记限定符表达式的开始</td>
</tr>
<tr>
<td>|</td>
<td>指明两项之间的一个选择</td>
</tr>
</tbody></table>
<h3 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h3><p>限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有<code>*</code>或<code>+</code>或<code>?</code>或<code>{n}</code>或<code>{n,}</code>或<code>{n,m}</code>6种。</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>匹配前面的子表达式零次或多次</td>
</tr>
<tr>
<td>+</td>
<td>匹配前面的子表达式一次或多次</td>
</tr>
<tr>
<td>？</td>
<td>匹配前面的子表达式零次或一次</td>
</tr>
<tr>
<td>{n}</td>
<td>n是一个非负整数。匹配确定的n次。例如, ‘o{2}‘’不能匹配“Bob”中的‘o’,但是能匹配“food”中的两个o</td>
</tr>
<tr>
<td>{n,}</td>
<td>n是一个非负整数。至少匹配n次</td>
</tr>
<tr>
<td>{n,m}</td>
<td>m和n均为非负整数，其中n &lt;= m。最少匹配n次且最多匹配m次。<strong>注意在逗号和两个数之间不能有空格</strong></td>
</tr>
</tbody></table>
<p>注意：</p>
<p><strong>*、+限定符都是贪婪的，因为他们会尽可能多的匹配文字，只有在他们后面加上一个？就可以实现非贪婪或最小匹配。</strong></p>
<p>例如，当我们在搜索HTML文档，以查找括在H1标记内的章节标题。该文本在文档中如下：</p>
<p><code>&lt;H1&gt;Chapter 1 - 介绍正则表达式&lt;/H1&gt;</code></p>
<p><strong>贪婪</strong>：下面的表达式匹配从开始小于符号(&lt;)到关闭H1标记的大于符号(&gt;)之间的所有内容</p>
<p><code>/&lt;.*&gt;/</code></p>
<p><strong>非贪婪</strong>：如果您只需要匹配开始和结束H1标签，下面的非贪婪表达式只匹配 &lt;H1&gt;</p>
<p><code>/&lt;.*?&gt;/</code></p>
<p>如果指向匹配开始的H1标签，表达式则是：</p>
<p><code>/&lt;\w+?&gt;/</code></p>
<p>通过在* 、+ 或 ？限定符之后放置？，该表达式从“贪心”表达式转换为“非贪心”表达式或者最小匹配。</p>
<h3 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a>定位符</h3><p>定位符能够将正则表达式固定到行首或行尾。还能够创建这样的表达式：这些正则表达式出现在一个单词内、在一个单词的开头或者一个单词的结尾</p>
<p>定位符用来描述字符串或单词的边界，<code>^</code>和<code>$</code>分贝指字符串的开始与结束，<code>\b</code>描述单词的前或后边界，<code>\B</code>表示非单词边界</p>
<p>正则表达式的定位符有：</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>^</td>
<td>匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \n 或 \r 之后的位置匹配。</td>
</tr>
<tr>
<td>$</td>
<td>匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \n 或 \r 之后的位置匹配。</td>
</tr>
<tr>
<td>\b</td>
<td>匹配一个单词边界，即字与空格间的位置</td>
</tr>
<tr>
<td>\B</td>
<td>非单词边界匹配</td>
</tr>
</tbody></table>
<p><strong>注意：</strong></p>
<p>不能将限定符与定位符一起使用。而且在紧靠换行或者单词边界的前面或后面不能有一个以上位置，因此不允许注入<code>^*</code>之类的表达式</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Mariana</p>
              <p class="site-description motion-element" itemprop="description">a study blog</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">110</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mariana</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
