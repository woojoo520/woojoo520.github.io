<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="a study blog">
<meta property="og:type" content="website">
<meta property="og:title" content="Celery Fairy">
<meta property="og:url" content="https://woojoo520.github.io/page/3/index.html">
<meta property="og:site_name" content="Celery Fairy">
<meta property="og:description" content="a study blog">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Celery Fairy">
<meta name="twitter:description" content="a study blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://woojoo520.github.io/page/3/">





  <title>Celery Fairy</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <a href="https://github.com/woojoo520" class="github-corner" aria-label="View source on GitHub">
      <svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/>
      </svg>
    </a>
    <style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Celery Fairy</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Celery's Blog</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://woojoo520.github.io/2019/09/23/LeetCode-Day39/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mariana">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Celery Fairy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/23/LeetCode-Day39/" itemprop="url">LeetCode-Day39</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-23T13:10:13+08:00">
                2019-09-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209. 长度最小的子数组"></a>209. 长度最小的子数组</h3><p>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组。如果不存在符合条件的连续子数组，返回 0。</p>
<p>示例: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = 7, nums = [2,3,1,2,4,3]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 子数组 [4,3] 是该条件下的长度最小的连续子数组。</span><br></pre></td></tr></table></figure>

<p>思路：这个问题其实很容易就能想到在$O(n^2)$的时间复杂度下解决问题，但是这里采用了一种$O(nlogn)$的做法去解决这个问题。</p>
<p>首先，我们先求解<code>sums</code>数组，表示从头加到当前位置的和。</p>
<p>然后从<code>i = 1</code>到<code>n</code>枚举</p>
<ul>
<li><p>首先<code>to_find</code>定义为当前位置的<code>sum</code>值加上<code>s</code></p>
</li>
<li><p>在<code>sums</code>中找到值<code>to_find</code>最早能插入的地方，即满足从<code>i</code>开始，往后搜索差值为<code>s</code>的需要的最短距离。</p>
<p>在这里搜索的过程中可以采用二分搜索的方法，但是还有一个小技巧，就是利用<code>STL</code>中的<code>lower_bound</code>函数，来表示某一个数字最早能够插入在数组中的位置，这样显然就很高效了鸭~</p>
</li>
</ul>
<p>上Code：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen2</span><span class="params">(<span class="keyword">int</span> s, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sums(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        sums[i] = sums[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>]; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> to_find = s + sums[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">auto</span> bound = lower_bound(sums.begin(), sums.end(), to_find);</span><br><span class="line">        <span class="keyword">if</span>(bound != sums.end()) &#123;</span><br><span class="line">            ans = min(ans, <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt; (bound - (sums.begin() + i - <span class="number">1</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (ans != INT_MAX) ? ans : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于<code>lower_bound &amp;&amp; upper_bound</code>的测试</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; num(a, a + <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; num.size();i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; num[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt; (lower_bound(num.begin(), num.end(), <span class="number">2</span>) - num.begin()) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt; (upper_bound(num.begin(), num.end(), <span class="number">2</span>) - num.begin()) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<h3 id="128-最长连续序列"><a href="#128-最长连续序列" class="headerlink" title="128. 最长连续序列"></a>128. 最长连续序列</h3><p>给定一个未排序的整数数组，找出最长连续序列的长度。</p>
<p>要求算法的时间复杂度为 O(n)。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [100, 4, 200, 1, 3, 2]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 最长连续序列是 [1, 2, 3, 4]。它的长度为 4。</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p><strong>哈希表 + 线性空间的构造</strong></p>
<p>我们先将所有元素放进一个<code>Hash set</code>中，然后遍历<code>num_set</code>中的每一个元素，如果它前面一个数字没有在<code>num_set</code>中，那么它一定不是一个连续数组的开始，则跳过。如果是连续数组的开始，那么就需要一种往后找连续的元素是否存在，然后记录下最长的数列长度。</p>
<p>上Code：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; num_set;</span><br><span class="line">        <span class="keyword">int</span> maxLength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            num_set.insert(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : num_set) &#123;</span><br><span class="line">            <span class="keyword">if</span>(num_set.find(num - <span class="number">1</span>) == num_set.end()) &#123;</span><br><span class="line">                <span class="keyword">int</span> currentNum = num;</span><br><span class="line">                <span class="keyword">int</span> currentLen = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(num_set.find(currentNum + <span class="number">1</span>) != num_set.end()) &#123;</span><br><span class="line">                    currentNum += <span class="number">1</span>;</span><br><span class="line">                    currentLen += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                maxLength = max(maxLength, currentLen);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里虽然看上去复杂度挺高，但实际上是$O(n)$复杂度的，因为每个数字只会遍历到一次，因为如果不是连续数字开头的，就直接跳过了，而是连续数字开头的，就一直遍历到连续数字的末尾，所以总的时间复杂度是$O(n)$的。</p>
<h3 id="126-单词接龙II"><a href="#126-单词接龙II" class="headerlink" title="126. 单词接龙II"></a>126. 单词接龙II</h3><p>给定两个单词（beginWord 和 endWord）和一个字典 wordList，找出所有从 beginWord 到 endWord 的最短转换序列。转换需遵循如下规则：</p>
<p>每次转换只能改变一个字母。<br>转换过程中的中间单词必须是字典中的单词。<br>说明:</p>
<p>如果不存在这样的转换序列，返回一个空列表。<br>所有单词具有相同的长度。<br>所有单词只由小写字母组成。<br>字典中不存在重复的单词。<br>你可以假设 beginWord 和 endWord 是非空的，且二者不相同。<br>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">beginWord = &quot;hit&quot;,</span><br><span class="line">endWord = &quot;cog&quot;,</span><br><span class="line">wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [&quot;hit&quot;,&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;cog&quot;],</span><br><span class="line">  [&quot;hit&quot;,&quot;hot&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">beginWord = &quot;hit&quot;</span><br><span class="line">endWord = &quot;cog&quot;</span><br><span class="line">wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]</span><br><span class="line"></span><br><span class="line">输出: []</span><br><span class="line">解释: endWord &quot;cog&quot; 不在字典中，所以不存在符合要求的转换序列。</span><br></pre></td></tr></table></figure>

<p>思路：<strong>双向BFS</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(<span class="built_in">string</span> beginWord, <span class="built_in">string</span> endWord, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordList)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; freqs;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;word:wordList)</span><br><span class="line">			freqs[word]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(freqs.count(endWord)==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; q1(&#123;beginWord&#125;), q2(&#123;endWord&#125;);</span><br><span class="line">		<span class="keyword">int</span> step=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(freqs[beginWord]|=<span class="number">1</span>,freqs[endWord]|=<span class="number">2</span>; q1.size() &amp;&amp; q2.size(); ++step)&#123;</span><br><span class="line">			<span class="keyword">bool</span> first=q1.size()&lt;q2.size();</span><br><span class="line">			<span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; &amp;q=first?q1:q2;</span><br><span class="line">			<span class="keyword">int</span> flag=first?<span class="number">1</span>:<span class="number">2</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> size=q.size(); size--; q.pop())&#123;</span><br><span class="line">				<span class="built_in">string</span> &amp;word=q.front();</span><br><span class="line">				<span class="keyword">if</span>(freqs[word]==<span class="number">3</span>) <span class="keyword">return</span> step;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;word.length(); ++i)&#123;</span><br><span class="line">					<span class="keyword">for</span>(<span class="keyword">char</span> ch=<span class="string">'a'</span>; ch&lt;=<span class="string">'z'</span>; ++ch)&#123;</span><br><span class="line">						<span class="built_in">string</span> s=word;</span><br><span class="line">						<span class="keyword">if</span>(s[i]==ch) <span class="keyword">continue</span>;</span><br><span class="line">						s[i]=ch;</span><br><span class="line">						<span class="keyword">if</span>(freqs.count(s)==<span class="number">0</span> || freqs[s]&amp;flag) <span class="keyword">continue</span>;</span><br><span class="line">						freqs[s]|=flag;</span><br><span class="line">						q.push(s);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://woojoo520.github.io/2019/09/23/FFT/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mariana">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Celery Fairy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/23/FFT/" itemprop="url">FFT</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-23T13:09:48+08:00">
                2019-09-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="快速傅里叶变换FFT-Fast-Fourier-Transform"><a href="#快速傅里叶变换FFT-Fast-Fourier-Transform" class="headerlink" title="快速傅里叶变换FFT(Fast Fourier Transform)"></a>快速傅里叶变换FFT(Fast Fourier Transform)</h2><h3 id="傅里叶变换"><a href="#傅里叶变换" class="headerlink" title="傅里叶变换"></a>傅里叶变换</h3><p>快速傅里叶变换是一种可以在$O(nlogn)$时间内完成的离散傅里叶变换（DFT）算法。</p>
<p>在算法竞赛中的应用主要是用来加速多项式的乘法。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://woojoo520.github.io/2019/09/22/LeetCode-Day38/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mariana">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Celery Fairy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/22/LeetCode-Day38/" itemprop="url">LeetCode-Day38</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-22T21:53:02+08:00">
                2019-09-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="189-旋转数组"><a href="#189-旋转数组" class="headerlink" title="189. 旋转数组"></a>189. 旋转数组</h3><p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,5,6,7] 和 k = 3</span><br><span class="line">输出: [5,6,7,1,2,3,4]</span><br><span class="line">解释:</span><br><span class="line">向右旋转 1 步: [7,1,2,3,4,5,6]</span><br><span class="line">向右旋转 2 步: [6,7,1,2,3,4,5]</span><br><span class="line">向右旋转 3 步: [5,6,7,1,2,3,4]</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [-1,-100,3,99] 和 k = 2</span><br><span class="line">输出: [3,99,-1,-100]</span><br><span class="line">解释: </span><br><span class="line">向右旋转 1 步: [99,-1,-100,3]</span><br><span class="line">向右旋转 2 步: [3,99,-1,-100]</span><br></pre></td></tr></table></figure>

<p>思路：这道题虽然很简单，但是却有更加快速的操作。</p>
<p>就是先翻转整个数组，然后在要求的节点前后进行两次翻转。</p>
<p>举个栗子：</p>
<p><code>[1, 2, 3, 4, 5, 6, 7] k = 3</code></p>
<p>整个数组翻转：<code>[7, 6, 5, 4, 3, 2, 1]</code></p>
<p>前半部分翻转：<code>[5, 6, 7, 4, 3, 2, 1]</code></p>
<p>后半部分翻转：<code>[5, 6, 7, 1, 2, 3, 4]</code></p>
<p>上Code：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums.size() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        k %= nums.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n / <span class="number">2</span>;i++) &#123;</span><br><span class="line">            swap(nums[i], nums[n - <span class="number">1</span> - i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k / <span class="number">2</span>;i++) &#123;</span><br><span class="line">            swap(nums[i], nums[k - i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = k;i &lt; (n + k) / <span class="number">2</span>;i++) &#123;</span><br><span class="line">            swap(nums[i], nums[n - <span class="number">1</span> - i + k]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://woojoo520.github.io/2019/09/21/LeetCode-Day37/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mariana">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Celery Fairy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/21/LeetCode-Day37/" itemprop="url">LeetCode-Day37</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-21T07:13:57+08:00">
                2019-09-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="LeetCode-Day37——还在动态规划"><a href="#LeetCode-Day37——还在动态规划" class="headerlink" title="LeetCode-Day37——还在动态规划"></a>LeetCode-Day37——还在动态规划</h2><h3 id="368-最大整除子集"><a href="#368-最大整除子集" class="headerlink" title="368. 最大整除子集"></a>368. 最大整除子集</h3><p>给出一个由无重复的正整数组成的集合，找出其中最大的整除子集，子集中任意一对 (Si，Sj) 都要满足：Si % Sj = 0 或 Sj % Si = 0。</p>
<p>如果有多个目标子集，返回其中任何一个均可。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">输出: [1,2] (当然, [1,3] 也正确)</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: [1,2,4,8]</span><br><span class="line">输出: [1,2,4,8]</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>其实也没啥思路，就是先进行排序，然后用<code>i</code>顺序遍历, 用<code>j</code> 在<code>[0, i]</code>区间内遍历，查找能否加入当前满足的最大的整除子集，记录下满足的点的下标。</p>
<p>然后逆向查找，返回<code>res</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; largestDivisibleSubset(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; index(n, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    sort(nums.begin(), nums.end());</span><br><span class="line">    <span class="keyword">int</span> maxStart = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; i;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] % nums[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[i] &lt; dp[j] + <span class="number">1</span>) &#123;</span><br><span class="line">                    dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">                    index[i] = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        maxStart = dp[maxStart] &gt; dp[i] ? maxStart : i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(maxStart &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">        res.push_back(nums[maxStart]);</span><br><span class="line">        maxStart = index[maxStart];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="375-猜数字大小II"><a href="#375-猜数字大小II" class="headerlink" title="375. 猜数字大小II"></a>375. 猜数字大小II</h3><p><strong>依然DP</strong></p>
<p>算法：</p>
<p>以<code>i</code>为第一次尝试找到最小开销的过程可以被分解为找左右区间内最小开销的子问题。对于每个区间，我们重复问题拆分的过程，得到更多子问题，这启发我们可以用DP解决这个问题。</p>
<p>我们需要使用一个<code>dp</code>数组，其中<code>dp(i, j)</code>代表在<code>(i, j)</code>中最坏情况下的最小开销。现在我们只需要考虑如何求出这个<code>dp</code>数组。如果区间只剩下一个数<code>k</code>,那么猜中的代价永远为0，因为我们区间里只剩下一个数字，也就是说，所有的<code>dp(k, k)</code>都初始化为0。然后，对于长度为2的区间，我们需要所有长度为1的区间的结果。由此我们可以看出，为了求出长度为len区间的解。因此我们按照区间长度从短到长求出<code>dp</code>数组。</p>
<p>现在，我们应该按照什么办法来求出<code>dp</code>矩阵呢？对于每个<code>dp(i, j)</code>，当前长度为<code>len = j - i + 1</code>，我们一次挑选每个数字作为第一次尝试的答案。</p>
<p><code>cost(i, j) = pivot + max(cost(i, pivot - 1), cost(pivot + 1, n))</code></p>
<p>但是在计算开销的时候，我们有一个便利之处，就是我们已经知道了小于len长度的<code>dp</code>数组的所有答案。因此dp方程变成了</p>
<p>$dp(i, j) = min_{pivots(i, j)}[pivot + max(dp[i, pivot - 1], dp[pivot + 1, n])]$</p>
<p>其中$min_{pivots(i, j)}$表示将<code>(i, j)</code>中的每个数作为第一个尝试的数字</p>
<p>上Code：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMoney</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="comment">// 遍历长度，分别枚举长度从2 - n的分段，因为长度为1的花销为0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> len = <span class="number">2</span>;len &lt;= n;len++) &#123;</span><br><span class="line">        <span class="comment">// 遍历start的位置，从start开始，取长度为len，所以start必须要小于等于(n - len + 1)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> start = <span class="number">1</span>;start &lt;= n - len + <span class="number">1</span>;start++) &#123;</span><br><span class="line">            <span class="keyword">int</span> minres = INT_MAX;</span><br><span class="line">            <span class="comment">// 遍历(start, start + len)的区间，寻找最小代价</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> piv = start; piv &lt; start + len - <span class="number">1</span>;piv++) &#123;</span><br><span class="line">                <span class="keyword">int</span> res = piv + max(dp[start][piv - <span class="number">1</span>], dp[piv + <span class="number">1</span>][start + len - <span class="number">1</span>]);</span><br><span class="line">                minres = min(res, minres);</span><br><span class="line">            &#125;</span><br><span class="line">            dp[start][start + len - <span class="number">1</span>] = minres;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">1</span>][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="403-青蛙过河"><a href="#403-青蛙过河" class="headerlink" title="403. 青蛙过河"></a>403. 青蛙过河</h3><p>一只青蛙想要过河。 假定河流被等分为 x 个单元格，并且在每一个单元格内都有可能放有一石子（也有可能没有）。 青蛙可以跳上石头，但是不可以跳入水中。</p>
<p>给定石子的位置列表（用单元格序号升序表示）， 请判定青蛙能否成功过河（即能否在最后一步跳至最后一个石子上）。 开始时， 青蛙默认已站在第一个石子上，并可以假定它第一步只能跳跃一个单位（即只能从单元格1跳至单元格2）。</p>
<p>如果青蛙上一步跳跃了 k 个单位，那么它接下来的跳跃距离只能选择为 k - 1、k 或 k + 1个单位。 另请注意，青蛙只能向前方（终点的方向）跳跃。</p>
<p>请注意：</p>
<p>石子的数量 ≥ 2 且 &lt; 1100；<br>每一个石子的位置序号都是一个非负整数，且其 &lt; 231；<br>第一个石子的位置永远是0。<br>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[0,1,3,5,6,8,12,17]</span><br><span class="line">总共有8个石子。</span><br><span class="line">第一个石子处于序号为0的单元格的位置, 第二个石子处于序号为1的单元格的位置,</span><br><span class="line">第三个石子在序号为3的单元格的位置， 以此定义整个数组...</span><br><span class="line">最后一个石子处于序号为17的单元格的位置。</span><br><span class="line"></span><br><span class="line">返回 true。即青蛙可以成功过河，按照如下方案跳跃： </span><br><span class="line">跳1个单位到第2块石子, 然后跳2个单位到第3块石子, 接着 </span><br><span class="line">跳2个单位到第4块石子, 然后跳3个单位到第6块石子, </span><br><span class="line">跳4个单位到第7块石子, 最后，跳5个单位到第8个石子（即最后一块石子）。</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[0,1,2,3,4,8,9,11]</span><br><span class="line"></span><br><span class="line">返回 false。青蛙没有办法过河。 </span><br><span class="line">这是因为第5和第6个石子之间的间距太大，没有可选的方案供青蛙跳跃过去。</span><br></pre></td></tr></table></figure>

<p>有点难… 嗯…看看代码注释吧</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canCross</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(stones[<span class="number">1</span>] != <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> len = stones.size();</span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">bool</span> dp[len+<span class="number">5</span>][<span class="number">1200</span>]; <span class="comment">//在第i个石头并且是跳j步过来的可以不?</span></span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; len;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; i;j++)&#123;   <span class="comment">//遍历前面的所有石头</span></span><br><span class="line">            <span class="keyword">int</span> dist = stones[i] - stones[j];  <span class="comment">//前面的石头一定是跳dist步过来的</span></span><br><span class="line">            <span class="keyword">if</span>(dist &gt; <span class="number">1100</span>) <span class="keyword">continue</span>;</span><br><span class="line">            dp[i][dist] |= dp[j][dist<span class="number">-1</span>]|dp[j][dist]|dp[j][dist+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(i == len<span class="number">-1</span> &amp;&amp; dp[i][dist])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="硬核的东西来辽-各种背包问题！！"><a href="#硬核的东西来辽-各种背包问题！！" class="headerlink" title="硬核的东西来辽~ 各种背包问题！！"></a>硬核的东西来辽~ 各种背包问题！！</h3><h4 id="一-01背包"><a href="#一-01背包" class="headerlink" title="一. 01背包"></a>一. 01背包</h4><h5 id="【题目描述】："><a href="#【题目描述】：" class="headerlink" title="【题目描述】："></a>【题目描述】：</h5><p><code>一个旅行者有一个最多能装M公斤的背包，现在有n件物品，他们的重量分别是W1，W2…Wn，它们的价值分别是C1，C2……Cn，求旅行者能够获得的最大总价值。</code></p>
<h5 id="【输入格式】："><a href="#【输入格式】：" class="headerlink" title="【输入格式】："></a>【输入格式】：</h5><p><code>第一行：两个整数，M，（背包容量，M&lt;=200）和N（物品数量N&lt;=30）</code></p>
<p><code>第2至N+1行，每行两个整数，Wi,Ci,表示每个物品的重量和价值。</code></p>
<h5 id="【输出格式】："><a href="#【输出格式】：" class="headerlink" title="【输出格式】："></a>【输出格式】：</h5><p><code>仅一行，一个数，表示最大总价值。</code></p>
<h5 id="【输入样例】："><a href="#【输入样例】：" class="headerlink" title="【输入样例】："></a>【输入样例】：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">10 4</span><br><span class="line">2 1</span><br><span class="line">3 3</span><br><span class="line">4 5</span><br><span class="line">7 9</span><br></pre></td></tr></table></figure>

<p>【输出样例】：12</p>
<h5 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h5><p>01背包问题可以说是最简单的背包问题，简单之处在于：它的每个物品只有一个。</p>
<p>首先定义一个<code>f[MAXN][MAXN]</code>数组，用来记录最大值，即<code>f[i][v]</code>表示的是当前<code>i</code>件物品放入一个容量为<code>v</code>的背包的时候可以获得的最大值。</p>
<p>01背包的<strong>状态转移方程</strong>为: <code>f[i][v] = max(f[i - 1][v], f[i - 1][v - w[i]] + c[i])</code></p>
<p> 解释：如果只考虑第<code>i</code>件物品的方式策略，那么就只和第<code>i - 1</code>件物品有关了，如果是放第<code>i</code>间物品，那么问题就转换为：“前<code>i - 1</code>件物品放入容量为v的背包中”，此时能够获得的最大价值就是<code>f[i - 1][v - w[i]]</code>，也就是第<code>i - 1</code>件物品放入容量为v(原来的总容量)减去<code>w[i]</code>(第<code>i</code>间物品的占容产生的价值)，再加上放通过第<code>i</code>件物品增加的价值<code>c[i]</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bag01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// m表示背包总容量，n表示有n件物品</span></span><br><span class="line">    <span class="keyword">int</span> m, n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> w[n + <span class="number">1</span>] = &#123;<span class="number">0</span>&#125;, c[n + <span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;dp(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; (m + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; w[i] &gt;&gt; c[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="comment">// 这里需要注意是逆序的，因为保证第i次循环dp[i][j]的状态是从dp[i][j - w[i]]递推而来的，也就是为了保证每件物品只选一次，保证在考虑“选入第i件物品”这件策略时，依据的绝不可能选入第i件物品的子结果f[i][v - w[i]]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = m;j &gt; <span class="number">0</span>;j--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(w[i] &lt;= j) &#123;</span><br><span class="line">                dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - w[i]] + c[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二-完全背包问题"><a href="#二-完全背包问题" class="headerlink" title="二. 完全背包问题"></a>二. 完全背包问题</h4><h5 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h5><p>设有n种物品，每种物品有一个价值，但每种物品的数量是无限的，同时有一个背包，最大承载量为m，今从n种物品中选取若干件，（同一种物品可以多次选举）使其重量的和小于等于m，而且价值的和最大。</p>
<h5 id="【输入】"><a href="#【输入】" class="headerlink" title="【输入】"></a>【输入】</h5><p>共N+1行</p>
<p>第一行：两个整数：M（背包容量M&lt;=200）和N（物品数量，N&lt;=30）；</p>
<p>第二行至第N+1行，每行两个整数，Wi，Ci，表示每个物品的重量和价值。</p>
<h5 id="【输出】"><a href="#【输出】" class="headerlink" title="【输出】"></a>【输出】</h5><p>近一行：一个数，表示最大的价值；</p>
<h5 id="【输入样例】"><a href="#【输入样例】" class="headerlink" title="【输入样例】"></a>【输入样例】</h5><p>10 4</p>
<p>2 1</p>
<p>3 3</p>
<p>4 5</p>
<p>7 9</p>
<h5 id="【输出样例】"><a href="#【输出样例】" class="headerlink" title="【输出样例】"></a>【输出样例】</h5><p>12</p>
<h5 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h5><p>这一个问题与01背包唯一不同的地方，就是<strong>每种物品的数量是无限多的</strong>。</p>
<p>既然每种物品可以取很多次，那么，与它相关的策略就不是取或者不取的问题了，而是<strong>不取和取多少</strong>的问题了。</p>
<p>这个时候，其实我们只需要多一层关于每种物品选多少次的循环就可以了。相对的，状态转移方程也会有相应的改动。</p>
<p><code>f[i][v] = max(f[i - 1][v], f[i - 1][v - k * w[i]] + k * c[i])</code></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://woojoo520.github.io/2019/09/20/LeetCode-Day36/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mariana">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Celery Fairy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/20/LeetCode-Day36/" itemprop="url">LeetCode-Day36</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-20T10:50:48+08:00">
                2019-09-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="264-丑数II"><a href="#264-丑数II" class="headerlink" title="264. 丑数II"></a>264. 丑数II</h3><p>编写一个程序，找出第 n 个丑数。</p>
<p>丑数就是只包含质因数 2, 3, 5 的正整数。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: n = 10</span><br><span class="line">输出: 12</span><br><span class="line">解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。</span><br><span class="line">说明:  </span><br><span class="line">    1 是丑数。</span><br><span class="line">    n 不超过1690。</span><br></pre></td></tr></table></figure>

<p>思路：<strong>动态规划</strong></p>
<p>每次都找已经存在的数中 * 2或 * 3 或 * 5之后较小的值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> i2 = <span class="number">0</span>, i3 = <span class="number">0</span>, i5 = <span class="number">0</span>, i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i++ &lt; n) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = min(<span class="number">2</span> * res[i2], min(<span class="number">3</span> * res[i3], <span class="number">5</span> * res[i5]));</span><br><span class="line">            res.push_back(tmp);</span><br><span class="line">            <span class="keyword">if</span>(tmp == <span class="number">2</span> * res[i2])  i2++;</span><br><span class="line">            <span class="keyword">if</span>(tmp == <span class="number">3</span> * res[i3])  i3++;</span><br><span class="line">            <span class="keyword">if</span>(tmp == <span class="number">5</span> * res[i5])  i5++;</span><br><span class="line">        &#125;     </span><br><span class="line">        <span class="keyword">return</span> res.back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://woojoo520.github.io/2019/09/19/LeetCode-Day35/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mariana">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Celery Fairy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/19/LeetCode-Day35/" itemprop="url">LeetCode-Day35</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-19T20:59:43+08:00">
                2019-09-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="354-俄罗斯套娃信封问题"><a href="#354-俄罗斯套娃信封问题" class="headerlink" title="354. 俄罗斯套娃信封问题"></a>354. 俄罗斯套娃信封问题</h3><p>给定一些标记了宽度和高度的信封，宽度和高度以整数对形式 (w, h) 出现。当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。</p>
<p>请计算最多能有多少个信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。</p>
<p>说明:<br>不允许旋转信封。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: envelopes = [[5,4],[6,4],[6,7],[2,3]]</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 最多信封的个数为 3, 组合为: [2,3] =&gt; [5,4] =&gt; [6,7]。</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>其实这个问题就是最长上升子序列的一个升级版本。</p>
<p>但是我还是使用了$O(n^2)$的方法解决了问题，在评论区看到了对二分搜索的实现，所以拿出来讲一讲。</p>
<p>但是还没有看懂这个基于<code>envelopes[0]</code>排序，然后对<code>envelopes[1]</code>进行二分的骚操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxEnvelopes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; envelopes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(envelopes.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    sort(envelopes.begin(), envelopes.end(), [](<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>] || (a[<span class="number">0</span>] == b[<span class="number">0</span>] &amp;&amp; a[<span class="number">1</span>] &gt; b[<span class="number">1</span>]);</span><br><span class="line">    &#125;);    </span><br><span class="line">    <span class="keyword">int</span> n = envelopes.size(), maxSum = <span class="number">1</span>;;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(n, INT_MAX);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> e : envelopes) &#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = envelopes.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(vec[mid] &gt;= e[<span class="number">1</span>]) &#123;</span><br><span class="line">                high = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vec[low] = e[<span class="number">1</span>];</span><br><span class="line">        res = max(res, low);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://woojoo520.github.io/2019/09/19/StyleGAN/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mariana">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Celery Fairy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/19/StyleGAN/" itemprop="url">StyleGAN</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-19T12:21:42+08:00">
                2019-09-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>原有GAN出现的问题：</strong>与多数GAN一样，proGAN控制生成图像的特定特征的能力非常有限。这些属性相互纠缠，即使略微调整输入，也会同时影响生成图像的多个属性。所以如何将ProGAN该位条件生成模型，或者增强其微调单个属性的能力，是一个可以研究的方向。</p>
<p><strong>解决的方法：</strong></p>
<p>StyleGAN是NVIDIA继ProGAN之后提出的新的生成网络，其主要通过修改每一层级的输入，在不影响其它层级的情况下，开控制该层级所表示的视觉特征。这些特征可以使粗的特征（如姿势、脸型等），也可以是一些细节特征（如瞳色、发色等）</p>
<p>本文的工作及贡献：</p>
<ul>
<li><p>借鉴风格迁移，提出基于样式的生成器（style-based generator）</p>
<ul>
<li>实现了无监督地分离高级属性（人脸姿势、身份）和随机变化（例如雀斑，头发）</li>
<li>实现对生成图像中特定尺度的属性的控制</li>
<li>生成器从一个科学系的常量输入开始，隐码在每个卷积层调整图像的“样式”，从而直接控制不同尺度下图像特征的强度。</li>
</ul>
</li>
<li><p>实现了对<strong>隐空间（latent space）</strong>较好的解耦</p>
<ul>
<li>生成器将输入的隐码z嵌入一个中间的隐空间。因为输入的隐空间Z必须服从训练数据的概率密度，这在一定程度上导致了不可避免的纠缠，而嵌入的中间的隐空间W不受这个控制，因此可以被解耦</li>
</ul>
</li>
<li><p>提出了两个新的<strong>量化隐空间解耦程度</strong>的方法</p>
<ul>
<li>感知路径长度和线性可分性。与传统的生成器相比，新的生成器允许更线性、更解耦地表示不同的变化因素</li>
</ul>
</li>
<li><p>提出了新的高质量的人脸数据集（FFHQ,7万张1024 * 1024的人脸图片）</p>
<p>![img](file:///C:\Users\12751\Documents\Tencent Files\1275121799\Image\C2C{255CC7E5-BCDA-210F-8F43-B410432DFEB2}.png)</p>
</li>
</ul>
<h3 id="2-模型和方法"><a href="#2-模型和方法" class="headerlink" title="2. 模型和方法"></a>2. 模型和方法</h3><h4 id="2-1-基于样式的生成器结构"><a href="#2-1-基于样式的生成器结构" class="headerlink" title="2.1 基于样式的生成器结构"></a>2.1 基于样式的生成器结构</h4><p><img src="https://pic2.zhimg.com/v2-452bcc62544bdd83d4eb6e108f977a45_b.jpg" alt="img"></p>
<p>总共有18层，每个分辨率有两个卷积层（4， 8， 16， …1024）</p>
<ul>
<li><p>1.移除了传统的输入</p>
</li>
<li><p>2.映射网络</p>
</li>
<li><p>3.样式模块（AdaIN，自适应实例归一化）</p>
</li>
<li><p>4.随机变化（通过加入噪声为生成器生成随机细节）</p>
</li>
</ul>
<p><strong>移除传统输入</strong></p>
<p><img src="https://pic4.zhimg.com/v2-026759c4449b86d41d7b85b62c0868bb_b.jpg" alt="img"></p>
<p>传统的生成器使用latent code（随机输入）作为生成器的初始输入；StyleGAN抛弃了这种设计，将一个可学习的常数作为生成器的初始输入。一个假设是它减少了特征纠缠——对于网络来说，只使用w而不依赖纠缠的输入向量更容易学习</p>
<p><strong>映射网络（Mapping Network）</strong></p>
<p><img src="https://pic1.zhimg.com/v2-23b95580269d527ac1be9ccdf19fb030_b.jpg" alt="img"></p>
<p>映射网络由8个全连接层组成，其输出w与输入z大小相同（512 * 1）。<strong>映射网络的目标是将输入向量编码为中间向量，中间向量W的不同元素控制不同的视觉特征。</strong></p>
<p>使用输入向量z控制视觉特征的能力是有限的，它必须遵循训练数据的概率密度。例如，如果黑色头发的人的图像在数据集中更加常见，那么更多的输入值将映射到该特性。因此该模型无法将输入向量z的一部分（向量中的元素）映射到特征，这种向量称为特征纠缠。</p>
<p>但是，通过映射网络，该模型可以生成一个不需要跟随训练数据分布的向量w，并且可以减少特征之间的相关性（解耦，特征分离）</p>
<p><strong>样式模块（AdalN）</strong></p>
<p><img src="https://pic4.zhimg.com/v2-99f307a8cde4d1b0dfde84f2893a3ff7_b.jpg" alt="img"></p>
<p>W通过每个卷积层的AdaIN输入到生成器的每一层中。</p>
<p>计算方法：</p>
<ul>
<li>计算每个特征图xi（feature map）独立进行归一化<img src="https://www.zhihu.com/equation?tex=%28x_i-%CE%BC%28x_i%29%29+%2F%CF%83%28x_i%29" alt="[å¬å¼]">特征图中的每个值减去该特征值的均值然后除以方差。</li>
<li>一个可学习的仿射变换（全连接层）将w转换为style中AdaIN的平移和缩放因子 $y = (y_s, i, y_b, i)$</li>
<li>然后对每个特征图分别使用style中学习到的平移和缩放因子进行尺度和平移变换</li>
</ul>
<p>这里的不同之处在于这里的缩放和平移是用隐码w计算得到，而不是用一个图像计算得到的。</p>
<p><strong>随机变化（通过引入噪声为生成器生成随机细节）</strong></p>
<p><img src="https://pic4.zhimg.com/v2-9fb97d3991e3ceb6f45cf177cca76fd7_b.jpg" alt="img"></p>
<p>人的连有很多可以看做是随机的，比如头发的精确位置，使特向更真实，增加了输出的多样性。将这些小特征插入GAN图像的<strong>常用方法是向输入向量添加随机噪声，然后通过输入层输入生成器</strong>。然而，在很多情况下，控制噪声效果是很棘手的，因为特征纠缠现象，略微改变噪声会导致<strong>图像的其他特征收到影响</strong>。</p>
<p>该框架通过<strong>在合成网络的每个分辨率级上增加尺度化的噪声</strong>来回避这些问题。噪声是由高斯噪声组成的单通道图像，将一个噪声图像提供给合成网络的一个特征图。在卷积之后、AdaIN之前将高斯噪声加入生成器网络中。B使用可学习的缩放参数对输入的高斯噪声进行变换，然后将噪声广播到所有的特征图中（分别加到每个特征图上，每个特征图对应一个可学习的scale参数）</p>
<h4 id="2-2-正则化-混合正则化（mixing-regularization）"><a href="#2-2-正则化-混合正则化（mixing-regularization）" class="headerlink" title="2.2 正则化-混合正则化（mixing regularization）"></a>2.2 正则化-混合正则化（mixing regularization）</h4><p>为了进一步距离styles的局部化（<strong>减少不同层之间样式的相关性</strong>），本文对生成器使用混合正则化。</p>
<p>方法：对<strong>给定的训练样本（随机选取）</strong>使用<strong>样式混合</strong>的方式生成图像。在训练过程中，使用两个随机隐码z（latent code）而不是一个，生成图像时，<strong>在合成网络中随机选择一个点（某层），从一个隐码切换到另一个隐码（称之为样式混合）</strong>。具体来说，通过映射网络运行两个潜码z1、z2，并让对应的w1、w2控制样式，使w1在交点前应用，w2在交点后应用</p>
<p>这种正则化技术<strong>防止网络假设相邻样式是相关的</strong>，随机切换确保网络不会学习和依赖级别之间的相关性。</p>
<h4 id="2-3-两种新的量化隐空间（latent-space）耦合度的方法"><a href="#2-3-两种新的量化隐空间（latent-space）耦合度的方法" class="headerlink" title="2.3 两种新的量化隐空间（latent space）耦合度的方法"></a>2.3 两种新的量化隐空间（latent space）耦合度的方法</h4><ul>
<li><p><strong>解耦的目标</strong>是使隐空间（latent space）由线性子空间组成，即每个子空间（每个维度）控制一个变异因子（特征）</p>
</li>
<li><p>但是<strong>隐空间Z</strong>中的各个因子的采样概率<strong>需要与训练数据中响应的密度匹配，就会产生纠缠</strong>。而中间隐藏空间W不需要根据任何固定分布进行采样，<strong>他的采样密度是由可学习的映射网络f(z)得到的，使变化的因素变得更加线性</strong>。</p>
</li>
<li><p>本文假设，生成器基于解耦的表示比基于纠缠的表示应该更容易产生真实的图像（若在FID变小的同时，隐空间耦合度变小，则可以得证）。因此，我们期望训练在无监督的情况下（即，当不预先知道变异的因素时）产生较少纠缠的W</p>
</li>
<li><p><strong>最近提出的用于量化解耦的指标，需要将一个输入图像映射到隐码的编码器网络。</strong>但是不适合本文，因为baseline GAN缺乏这样的编码器</p>
</li>
<li><p>所以本文提出了两种新的量化解耦的方法，他们都不需要编码器，所以对于任何数据集和生成器都是可计算的</p>
<ul>
<li>感知路径长度（Perceptual path length）</li>
<li>线性可分性（Linear separability）</li>
</ul>
</li>
</ul>
<h5 id="感知路径长度"><a href="#感知路径长度" class="headerlink" title="感知路径长度"></a>感知路径长度</h5><p>为什么这种量化纠缠的方法是可行的？</p>
<ul>
<li>对隐空间向量进行插值会在图像中产生非线性变化。比如，在所有断点中缺失的特征可能会出现在线性插值路径的中间。这表明隐空间是耦合的，变化因子没有被恰当的分开。所以通过测量当在两个隐空间之间进行插值时图像的剧烈变化程度，可以反映隐空间的纠缠程度（特征分离程度）</li>
</ul>
<p>感知路径长度计算，使用10000个样本计算</p>
<ul>
<li>将两个隐空间之间的插值路径细分为小段，感知总长度定义为每段感知差异的总和。感知路径长度的定义是这个和在无限细的细分下的极限，实际上是用一个小的细分<img src="https://www.zhihu.com/equation?tex=%5Cepsilon%3D10%5E%7B-4%7D" alt="[å¬å¼]">来近似它。隐空间Z中所有可能端点（在路径中的位置）的平均感知路径长度，计算如下：<img src="https://www.zhihu.com/equation?tex=l_%7BZ%7D%3D%5Cmathbb%7BE%7D%5B%5Cfrac%7B1%7D%7B%5Cepsilon%5E%7B2%7D%7Dd%28G%28slerp%28z_1%2Cz_2%3Bt%29%29%2CG%28slerp%28z_1%2Cz_2%3Bt%2B%5Cepsilon%29%29%29%5D" alt="[å¬å¼]"></li>
<li>其中<img src="https://www.zhihu.com/equation?tex=t%5Csim+U%280%2C1%29" alt="[å¬å¼]">。t服从0， 1分布，slerp表示球面插值操作，这是在归一化的输入隐空间中最合适的插值方式。</li>
<li>G是生成器，d计算得到生成图像之间的感知距离。因为d是二次的，所以除以<img src="https://www.zhihu.com/equation?tex=%5Cepsilon%5E%7B2%7D" alt="[å¬å¼]">而不是<img src="https://www.zhihu.com/equation?tex=%5Cepsilon" alt="[å¬å¼]">来消除对细分粒度的依赖</li>
<li>d的具体计算方式：使用基于感知的成对距离图像，测量连续图像之间的差异（两个VGG16 embeddings之间的差异，利用VGG16提取出图像的特征，在特征层面上计算距离）</li>
</ul>
<p>计算隐空间W的感知路径的长度与z的唯一不同时采用lerp线性插值，因为w向量没有进行归一化</p>
<p><img src="https://www.zhihu.com/equation?tex=l_%7BW%7D%3D%5Cmathbb%7BE%7D%5B%5Cfrac%7B1%7D%7B%5Cepsilon%5E%7B2%7D%7Dd%28g%28lerp%28f%28z_1%29%2Cf%28z_2%29%3Bt%29%29%2Cg%28lerp%28f%28z_1%29%2Cf%28z_2%29%3Bt%2B%5Cepsilon%29%29%29%5D" alt="[å¬å¼]"></p>
<p><strong>线性可分性（linear separability）</strong></p>
<p>为什么这种量化纠缠的方法是可行的？</p>
<p><strong>如果一个隐空间是充分解耦的，应该能够找到与每个变化因子对应的方向向量。</strong>我们提出了另一种度量方法来量化这种效果，<strong>测量通过线性超平面将隐空间点分割成两个不同集合的程度</strong>，使每个集合对应于图像的特定的二元属性（比如男、女）</p>
<p>计算方法：</p>
<ul>
<li>训练40个辅助分类器，分别对40个二元属性进行区分（每个分类器区分一个属性）。分类器与StyleGAN判别器结构相同，使用CelebA-HQ数据集训练得到（保留原始CelebA的40个属性，150000个训练样本),学习率10-3，批次大小8，Adam优化器。</li>
<li>使用生成器生成的200,000个图像，并使用辅助分类器进行分类，根据分类器的置信度对样本进行排序，去掉置信度最低的一般，得到100,000个一直类别的隐空间向量（latent code）</li>
<li>对于每个属性，拟合一个线性SVM来预测标签——基于传统的隐空间点或基于样式的隐空间点w—并且根据这个超平面对这些隐空间点（512维，100,0000个点）进行分类</li>
<li>用<strong>条件熵H(Y |X)度量超平面将点划分为正确类别的能力</strong>，X是SVM预测的类别，Y是预先训练好的辅助分类器确定的类（作为真实类别）；因此，根据SVM确定样本在超平面的哪一边，条件熵告诉我们需要多少额外的信息来确定样本的真实类别。直觉上，如果隐空间中的变化因子是耦合的（非线性的），那么用超平面来分离样本点将会更加困难（需要更多的额外信息），产生高的条件熵。较低的值表示易于分离（可分性好），因此解耦程度更大</li>
</ul>
<p>可分性计算公式 <img src="https://www.zhihu.com/equation?tex=%5Cexp+%5Cleft%28%5Csum_%7Bi%7D+%5Cmathrm%7BH%7D%5Cleft%28Y_%7Bi%7D+%7C+X_%7Bi%7D%5Cright%29%5Cright%29" alt="[公式]"> ，其中i列举了40个属性。取幂是为了将值从对数域变换为线性域，便于进行比较</p>
<p>截断技巧</p>
<p>考虑到训练数据的分布，低密度区域很少被表示，因此生成器很难学习该区域。通过对隐空间进行阶段可以提升生成影响的平均质量，虽然会损失一些变化。对中间隐码W进行阶段，迫使W接近平均值</p>
<p>经过试验：<strong>噪声只会影响随机方面，而保留了整体结构和身份、面部等高级特征。</strong></p>
<p>$\epsilon$</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://woojoo520.github.io/2019/09/19/self-Attention/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mariana">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Celery Fairy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/19/self-Attention/" itemprop="url">self-Attention</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-19T10:28:41+08:00">
                2019-09-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="self-Attention"><a href="#self-Attention" class="headerlink" title="self-Attention"></a>self-Attention</h2><p>参考链接：<a href="https://zhuanlan.zhihu.com/p/48508221" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/48508221</a></p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><a href="https://zhuanlan.zhihu.com/p/42724582" target="_blank" rel="noopener">注意力（Attention）机制</a>[2]由Bengio团队与2014年提出并在近年广泛的应用在深度学习中的各个领域，例如在计算机视觉方向用于捕捉图像上的感受野，或者NLP中用于定位关键token或者特征。谷歌团队近期提出的用于生成词向量的BERT[3]算法在NLP的11项任务中取得了效果的大幅提升，堪称2018年深度学习领域最振奋人心的消息。而BERT算法的最重要的部分便是本文中提出的Transformer的概念。</p>
<p>正如论文的题目所说的，Transformer中抛弃了传统的CNN和RNN，整个网络结构完全是由Attention机制组成。更准确地讲，Transformer由且仅由self-Attenion和Feed Forward Neural Network组成。一个基于Transformer的可训练的神经网络可以通过堆叠Transformer的形式进行搭建，作者的实验是通过搭建编码器和解码器各6层，总共12层的Encoder-Decoder，并在机器翻译中取得了BLEU值得新高。</p>
<p>作者采用Attention机制的原因是考虑到RNN（或者LSTM，GRU等）的计算限制为是顺序的，也就是说RNN相关算法只能从左向右依次计算或者从右向左依次计算，这种机制带来了两个问题：</p>
<ol>
<li>时间片 <img src="https://www.zhihu.com/equation?tex=t" alt="[公式]"> 的计算依赖 <img src="https://www.zhihu.com/equation?tex=t-1" alt="[公式]"> 时刻的计算结果，这样限制了模型的并行能力；</li>
<li>顺序计算的过程中信息会丢失，尽管LSTM等门机制的结构一定程度上缓解了长期依赖的问题，但是对于特别长期的依赖现象,LSTM依旧无能为力。</li>
</ol>
<p>Transformer的提出解决了上面两个问题，首先它使用了Attention机制，将<strong>序列中的任意两个位置之间的距离是缩小为一个常量</strong>；其次它<strong>不是类似RNN的顺序结构，因此具有更好的并行性</strong>，符合现有的GPU框架。论文中给出Transformer的定义是：<strong>Transformer is the first transduction model relying entirely on self-attention to compute representations of its input and output without using sequence aligned RNNs or convolution</strong>。</p>
<h3 id="1-Transformer详解"><a href="#1-Transformer详解" class="headerlink" title="1. Transformer详解"></a>1. Transformer详解</h3><h4 id="1-1-高层Transformer"><a href="#1-1-高层Transformer" class="headerlink" title="1.1 高层Transformer"></a>1.1 高层Transformer</h4><p>论文中的验证Transformer的实验室基于机器翻译的，下面我们就以机器翻译为例子详细剖析Transformer的结构，在机器翻译中，Transformer可概括为如图1：</p>
<p><img src="https://pic4.zhimg.com/80/v2-1f6085e214b62d8293b2122a52489bff_hd.jpg" alt="img"></p>
<p>Transformer的本质上是一个Encoder-Decoder的结构，那么图1可以表示为图2的结构：</p>
<p><img src="https://pic1.zhimg.com/80/v2-5a252caa82f87920eadea2a2e93dc528_hd.jpg" alt="img"></p>
<p>如论文中所设置的，编码器由6个编码block组成，同样解码器是6个解码block组成。与所有的生成模型相同的是，编码器的输出会作为解码器的输入，如图3所示：</p>
<p><img src="https://pic3.zhimg.com/80/v2-c14a98dbcb1a7f6f2d18cf9a1f591be6_hd.jpg" alt="img"></p>
<p>我们继续分析每个encoder的详细结构：在Transformer的encoder中，数据首先会经过一个叫做‘self-attention’的模块得到一个加权之后的特征向量 <img src="https://www.zhihu.com/equation?tex=Z" alt="[公式]"> ，这个 <img src="https://www.zhihu.com/equation?tex=Z" alt="[公式]"> 便是论文公式1中的 <img src="https://www.zhihu.com/equation?tex=%5Ctext%7BAttention%7D%28Q%2CK%2CV%29" alt="[公式]"> ：</p>
<p><img src="https://www.zhihu.com/equation?tex=%5Ctext%7BAttention%7D%28Q%2CK%2CV%29%3D%5Ctext%7Bsoftmax%7D%28%5Cfrac%7BQK%5ET%7D%7B%5Csqrt%7Bd_k%7D%7D%29V+%5Ctag1" alt="[å¬å¼]"></p>
<p>第一次看到这个公式你可能会一头雾水，在后面的文章中我们会揭开这个公式背后的实际含义，在这一段暂时将其叫做 <img src="https://www.zhihu.com/equation?tex=Z" alt="[公式]"> 。</p>
<p>得到 <img src="https://www.zhihu.com/equation?tex=Z" alt="[公式]"> 之后，它会被送到encoder的下一个模块，即Feed Forward Neural Network。这个全连接有两层，第一层的激活函数是ReLU，第二层是一个线性激活函数，可以表示为：</p>
<p><img src="https://www.zhihu.com/equation?tex=%5Ctext%7BFFN%7D%28Z%29+%3D+max%280%2C+ZW_1+%2Bb_1%29W_2+%2B+b_2+%5Ctag2" alt="[公式]"></p>
<p>Encoder的结构如图4所示</p>
<p><img src="https://pic3.zhimg.com/80/v2-89e5443635d7e9a74ff0b4b0a6f31802_hd.jpg" alt="img"></p>
<p>Decoder的结构如图5所示，它和encoder的不同之处在于Decoder多了一个Encoder-Decoder Attention，两个Attention分别用于计算输入和输出的权值：</p>
<ol>
<li>Self-Attention：当前翻译和已经翻译的前文之间的关系；</li>
<li>Encoder-Decnoder Attention：当前翻译和编码的特征向量之间的关系。</li>
</ol>
<p><img src="https://pic1.zhimg.com/80/v2-d5777da2a84e120846c825ff9ca95a68_hd.jpg" alt="img">图5：Transformer的解码器由self-attention，encoder-decoder attention以及FFNN组成</p>
<h4 id="1-2-输入编码"><a href="#1-2-输入编码" class="headerlink" title="1.2 输入编码"></a>1.2 输入编码</h4><p>1.1节介绍的就是Transformer的主要框架，下面我们将介绍它的输入数据。如图6所示，首先通过Word2Vec等词嵌入方法将输入语料转化成特征向量，论文中使用的词嵌入的维度为 <img src="https://www.zhihu.com/equation?tex=d_%7Bmodel%7D%3D512" alt="[公式]"> 。</p>
<p><img src="https://pic1.zhimg.com/80/v2-408fcd9ca9a65fdbf9d971cfd9227904_hd.jpg" alt="img">图6：单词的输入编码</p>
<p>在最底层的block中， <img src="https://www.zhihu.com/equation?tex=x" alt="[公式]"> 将直接作为Transformer的输入，而在其他层中，输入则是上一个block的输出。为了画图更简单，我们使用更简单的例子来表示接下来的过程，如图7所示：</p>
<p><img src="https://pic2.zhimg.com/80/v2-ff0f90ebee18dd909999bd3bee38fa45_hd.jpg" alt="img">图7：输入编码作为一个tensor输入到encoder中</p>
<h4 id="1-3-Self-Attention"><a href="#1-3-Self-Attention" class="headerlink" title="1.3 Self-Attention"></a>1.3 Self-Attention</h4><p>Self-Attention是Transformer最核心的内容，然而作者并没有详细讲解，下面我们来补充一下作者遗漏的地方。回想Bahdanau等人提出的用Attention[2]，其核心内容是为输入向量的每个单词学习一个权重，例如在下面的例子中我们判断it代指的内容，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The animal didn&apos;t cross the street because it was too tired</span><br></pre></td></tr></table></figure>

<p>通过加权之后可以得到类似图8的加权情况，在讲解self-attention的时候我们也会使用图8类似的表示方式</p>
<p><img src="https://pic2.zhimg.com/80/v2-d2129d06290744ebc12b6f220866b2a5_hd.jpg" alt="img">图8：经典Attention可视化示例图</p>
<p>在self-attention中，每个单词有3个不同的向量，它们分别是Query向量（ <img src="https://www.zhihu.com/equation?tex=Q" alt="[公式]"> ），Key向量（ <img src="https://www.zhihu.com/equation?tex=K+" alt="[公式]"> ）和Value向量（ <img src="https://www.zhihu.com/equation?tex=V" alt="[公式]"> ），长度均是64。它们是通过3个不同的权值矩阵由嵌入向量 <img src="https://www.zhihu.com/equation?tex=X" alt="[公式]"> 乘以三个不同的权值矩阵 <img src="https://www.zhihu.com/equation?tex=W%5EQ" alt="[公式]"> ， <img src="https://www.zhihu.com/equation?tex=W%5EK" alt="[公式]"> ， <img src="https://www.zhihu.com/equation?tex=W%5EV" alt="[公式]"> 得到，其中三个矩阵的尺寸也是相同的。均是 <img src="https://www.zhihu.com/equation?tex=512%5Ctimes+64" alt="[公式]"> 。</p>
<p><img src="https://pic2.zhimg.com/80/v2-159cd31e629170e0bade136b91c9de61_hd.jpg" alt="img">图9：Q，K，V的计算示例图</p>
<p>那么Query，Key，Value是什么意思呢？它们在Attention的计算中扮演着什么角色呢？我们先看一下Attention的计算方法，整个过程可以分成7步：</p>
<ol>
<li>如上文，将输入单词转化成嵌入向量；</li>
<li>根据嵌入向量得到 <img src="https://www.zhihu.com/equation?tex=q" alt="[公式]"> ， <img src="https://www.zhihu.com/equation?tex=k" alt="[公式]"> ， <img src="https://www.zhihu.com/equation?tex=v" alt="[公式]"> 三个向量；</li>
<li>为每个向量计算一个score： <img src="https://www.zhihu.com/equation?tex=%5Ctext%7Bscore%7D+%3D+q+%5Ccdot+k" alt="[公式]"> ；</li>
<li>为了梯度的稳定，Transformer使用了score归一化，即除以 <img src="https://www.zhihu.com/equation?tex=%5Csqrt%7Bd_k%7D" alt="[公式]"> ；</li>
<li>对score施以softmax激活函数；</li>
<li>softmax点乘Value值 <img src="https://www.zhihu.com/equation?tex=v" alt="[公式]"> ，得到加权的每个输入向量的评分 <img src="https://www.zhihu.com/equation?tex=v" alt="[公式]"> ；</li>
<li>相加之后得到最终的输出结果 <img src="https://www.zhihu.com/equation?tex=z" alt="[公式]"> ： <img src="https://www.zhihu.com/equation?tex=z%3D%5Csum+v" alt="[公式]"> 。</li>
</ol>
<p>上面步骤的可以表示为图10的形式。</p>
<p><img src="https://pic1.zhimg.com/80/v2-79b6b3c14439219777144668a008355c_hd.jpg" alt="img">图10：Self-Attention计算示例图</p>
<p>实际计算过程中是采用基于矩阵的计算方式，那么论文中的 <img src="https://www.zhihu.com/equation?tex=Q" alt="[公式]"> ， <img src="https://www.zhihu.com/equation?tex=V" alt="[公式]"> ， <img src="https://www.zhihu.com/equation?tex=K+" alt="[公式]"> 的计算方式如图11：</p>
<p><img src="https://pic3.zhimg.com/80/v2-bcd0d108a5b52a991d5d5b5b74d365c6_hd.jpg" alt="img">图11：Q，V，K的矩阵表示</p>
<p>图10总结为如图12所示的矩阵形式：</p>
<p><img src="https://pic1.zhimg.com/80/v2-be73ba876922cf52df8a00a55f770284_hd.jpg" alt="img">图12：Self-Attention的矩阵表示</p>
<p>这里也就是公式1的计算方式。</p>
<p>在self-attention需要强调的最后一点是其采用了<a href="https://zhuanlan.zhihu.com/p/42706477" target="_blank" rel="noopener">残差网络</a> [5]中的short-cut结构，目的当然是解决深度学习中的退化问题，得到的最终结果如图13。</p>
<p><img src="https://pic1.zhimg.com/80/v2-2f06746893477aec8af0c9c3ca1c6c14_hd.jpg" alt="img">图13：Self-Attention中的short-cut连接</p>
<h4 id="1-3-Multi-Head-Attention"><a href="#1-3-Multi-Head-Attention" class="headerlink" title="1.3 Multi-Head Attention"></a>1.3 Multi-Head Attention</h4><p>Multi-Head Attention相当于 <img src="https://www.zhihu.com/equation?tex=h" alt="[公式]"> 个不同的self-attention的集成（ensemble），在这里我们以 <img src="https://www.zhihu.com/equation?tex=h%3D8" alt="[公式]"> 举例说明。Multi-Head Attention的输出分成3步：</p>
<ol>
<li>将数据 <img src="https://www.zhihu.com/equation?tex=X+" alt="[公式]"> 分别输入到图13所示的8个self-attention中，得到8个加权后的特征矩阵 <img src="https://www.zhihu.com/equation?tex=Z_i%2C+i%5Cin%5C%7B1%2C2%2C...%2C8%5C%7D" alt="[公式]"> 。</li>
<li>将8个 <img src="https://www.zhihu.com/equation?tex=Z_i" alt="[公式]"> 按列拼成一个大的特征矩阵；</li>
<li>特征矩阵经过一层全连接后得到输出 <img src="https://www.zhihu.com/equation?tex=Z" alt="[公式]"> 。</li>
</ol>
<p>整个过程如图14所示：</p>
<p><img src="https://pic3.zhimg.com/80/v2-c2a91ac08b34e73c7f4b415ce823840e_hd.jpg" alt="img">图14：Multi-Head Attention</p>
<p>同self-attention一样，multi-head attention也加入了short-cut机制。</p>
<h4 id="1-4-Encoder-Decoder-Attention"><a href="#1-4-Encoder-Decoder-Attention" class="headerlink" title="1.4 Encoder-Decoder Attention"></a>1.4 Encoder-Decoder Attention</h4><p>在解码器中，Transformer block比编码器中多了个encoder-cecoder attention。在encoder-decoder attention中， <img src="https://www.zhihu.com/equation?tex=Q" alt="[公式]"> 来之与解码器的上一个输出， <img src="https://www.zhihu.com/equation?tex=K" alt="[公式]"> 和 <img src="https://www.zhihu.com/equation?tex=V" alt="[公式]"> 则来自于与编码器的输出。其计算方式完全和图10的过程相同。</p>
<p>由于在机器翻译中，解码过程是一个顺序操作的过程，也就是当解码第 <img src="https://www.zhihu.com/equation?tex=k" alt="[公式]"> 个特征向量时，我们只能看到第 <img src="https://www.zhihu.com/equation?tex=k-1" alt="[公式]"> 及其之前的解码结果，论文中把这种情况下的multi-head attention叫做masked multi-head attention。</p>
<h4 id="1-5-损失层"><a href="#1-5-损失层" class="headerlink" title="1.5 损失层"></a>1.5 损失层</h4><p>解码器解码之后，解码的特征向量经过一层激活函数为softmax的全连接层之后得到反映每个单词概率的输出向量。此时我们便可以通过CTC等损失函数训练模型了。</p>
<p>而一个完整可训练的网络结构便是encoder和decoder的堆叠（各 <img src="https://www.zhihu.com/equation?tex=N+" alt="[公式]"> 个， <img src="https://www.zhihu.com/equation?tex=N%3D6" alt="[公式]"> ），我们可以得到图15中的完整的Transformer的结构（即论文中的图1）：</p>
<p><img src="https://pic1.zhimg.com/80/v2-9fb280eb2a69baf5ceafcfa3581aa580_hd.jpg" alt="img">图15：Transformer的完整结构图</p>
<h3 id="2-位置编码"><a href="#2-位置编码" class="headerlink" title="2. 位置编码"></a>2. 位置编码</h3><p>截止目前为止，我们介绍的Transformer模型并没有捕捉顺序序列的能力，也就是说无论句子的结构怎么打乱，Transformer都会得到类似的结果。换句话说，Transformer只是一个功能更强大的词袋模型而已。</p>
<p>为了解决这个问题，论文中在编码词向量时引入了位置编码（Position Embedding）的特征。具体地说，位置编码会在词向量中加入了单词的位置信息，这样Transformer就能区分不同位置的单词了。</p>
<p>那么怎么编码这个位置信息呢？常见的模式有：a. 根据数据学习；b. 自己设计编码规则。在这里作者采用了第二种方式。那么这个位置编码该是什么样子呢？通常位置编码是一个长度为 <img src="https://www.zhihu.com/equation?tex=d_%7Bmodel%7D" alt="[公式]"> 的特征向量，这样便于和词向量进行单位加的操作，如图16。</p>
<p><img src="https://pic3.zhimg.com/80/v2-3e1304e3f8da6cf23cc43ab3927d700e_hd.jpg" alt="img">图16：Position Embedding</p>
<p>论文给出的编码公式如下：</p>
<p><img src="https://www.zhihu.com/equation?tex=PE%28pos%2C+2i%29+%3D+sin%28%5Cfrac%7Bpos%7D%7B10000%5E%7B%5Cfrac%7B2i%7D%7Bd_%7Bmodel%7D%7D%7D%7D%29+%5Ctag3" alt="[公式]"></p>
<p><img src="https://www.zhihu.com/equation?tex=PE%28pos%2C+2i%2B1%29+%3D+cos%28%5Cfrac%7Bpos%7D%7B10000%5E%7B%5Cfrac%7B2i%7D%7Bd_%7Bmodel%7D%7D%7D%7D%29+%5Ctag4" alt="[公式]"></p>
<p>在上式中， <img src="https://www.zhihu.com/equation?tex=pos" alt="[公式]"> 表示单词的位置， <img src="https://www.zhihu.com/equation?tex=i" alt="[公式]"> 表示单词的维度。关于位置编码的实现可在Google开源的算法中<code>get_timing_signal_1d()</code>函数找到对应的代码。</p>
<p>作者这么设计的原因是考虑到在NLP任务重，除了单词的绝对位置，单词的相对位置也非常重要。根据公式 <img src="https://www.zhihu.com/equation?tex=sin%28%5Calpha%2B%5Cbeta%29+%3D+sin+%5Calpha+cos+%5Cbeta+%2B+cos+%5Calpha+sin%5Cbeta+" alt="[公式]"> 以及<img src="https://www.zhihu.com/equation?tex=cos%28%5Calpha+%2B+%5Cbeta%29+%3D+cos+%5Calpha+cos+%5Cbeta+-+sin+%5Calpha+sin%5Cbeta" alt="[公式]"> ，这表明位置 <img src="https://www.zhihu.com/equation?tex=k%2Bp" alt="[公式]"> 的位置向量可以表示为位置 <img src="https://www.zhihu.com/equation?tex=k" alt="[公式]"> 的特征向量的线性变化，这为模型捕捉单词之间的相对位置关系提供了非常大的便利。</p>
<h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h3><p><strong>优点</strong>：（1）虽然Transformer最终也没有逃脱传统学习的套路，Transformer也只是一个全连接（或者是一维卷积）加Attention的结合体。但是其设计已经足够有创新，因为其抛弃了在NLP中最根本的RNN或者CNN并且取得了非常不错的效果，算法的设计非常精彩，值得每个深度学习的相关人员仔细研究和品位。（2）Transformer的设计最大的带来性能提升的关键是将任意两个单词的距离是1，这对解决NLP中棘手的长期依赖问题是非常有效的。（3）Transformer不仅仅可以应用在NLP的机器翻译领域，甚至可以不局限于NLP领域，是非常有科研潜力的一个方向。（4）算法的并行性非常好，符合目前的硬件（主要指GPU）环境。</p>
<p><strong>缺点</strong>：（1）粗暴的抛弃RNN和CNN虽然非常炫技，但是它也使模型丧失了捕捉局部特征的能力，RNN + CNN + Transformer的结合可能会带来更好的效果。（2）Transformer失去的位置信息其实在NLP中非常重要，而论文中在特征向量中加入Position Embedding也只是一个权宜之计，并没有改变Transformer结构上的固有缺陷。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://woojoo520.github.io/2019/09/18/LeetCode-Day34/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mariana">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Celery Fairy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/18/LeetCode-Day34/" itemprop="url">LeetCode-Day34</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-18T10:23:50+08:00">
                2019-09-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="300-最长上升子序列"><a href="#300-最长上升子序列" class="headerlink" title="300. 最长上升子序列"></a>300. 最长上升子序列</h3><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [10,9,2,5,3,7,101,18]</span><br><span class="line">输出: 4 </span><br><span class="line">解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。</span><br></pre></td></tr></table></figure>

<p>说明:</p>
<p>可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。</p>
<p><strong>方法一.</strong> $O(n^2)$</p>
<p>思路：</p>
<p>令<code>dp[i]</code>数组为以第<code>i</code>个元素结尾的最长上升子序列的长度。</p>
<p><code>dp[j]</code>可以从<code>0-j - 1</code>遍历，然后分别检验<code>nums[j]</code>可以附加到哪个子序列上面，记录maxSum</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.size() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size(), maxSum = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> dp[n];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> Max = dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; i;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                Max = max(dp[i] + <span class="number">1</span>, Max);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i] = Max;</span><br><span class="line">        maxSum = max(maxSum, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二.  动态规划+二分查找</strong> $O(nlogn)$</p>
<p>思路：</p>
<ul>
<li><p>新的状态定义：我们考虑维护一个列表<code>tails</code>，其中每个元素<code>tails[k]</code>的值代表<strong>长度为k + 1的子序列尾部元素的值</strong></p>
</li>
<li><p>状态转移设计：遍历计算每个<code>tails[k]</code>，不断更新长度为<code>[1, k]</code>的子序列尾部元素值，<strong>始终保持每个尾部元素值最小</strong>（例如 [1,5,3]， 遍历到元素 55 时，长度为 22 的子序列尾部元素值为 55；当遍历到元素 33 时，尾部元素值应更新至 33，因为 33 遇到比它大的数字的几率更大）。</p>
</li>
<li><p><code>tails</code>列表一定是严格递增的：即当尽可能使每个子序列尾部元素值最小的前提下，子序列越长，其序列尾部元素值一定更大</p>
</li>
</ul>
<p>举个例子：</p>
<p><code>nums = [10, 9, 2, 5, 3, 7, 21, 18]</code></p>
<p><code>1. tails = [10]</code></p>
<p><code>2. tails = [9]</code></p>
<p><code>3. tails = [2]</code></p>
<p><code>4. tails = [2, 5]</code></p>
<p><code>5. tails = [2, 3]</code></p>
<p><code>6. tails = [2, 3, 7]</code></p>
<p><code>7. tails = [2, 3, 7, 21]</code></p>
<p><code>8. tails = [2, 3, 7, 18]</code></p>
<p>所以最终长度为4</p>
<p>最后，上Code然后理解一下吧：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.size() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> tails[nums.size()] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = res;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (i + j) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(tails[mid] &lt; num) &#123;</span><br><span class="line">                i = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                j = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        tails[i] = num;</span><br><span class="line">        <span class="keyword">if</span>(j == res) &#123;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="股票问题整理（这里主要介绍动态转移方程，没有进行空间优化）"><a href="#股票问题整理（这里主要介绍动态转移方程，没有进行空间优化）" class="headerlink" title="股票问题整理（这里主要介绍动态转移方程，没有进行空间优化）"></a>股票问题整理（这里主要介绍动态转移方程，没有进行空间优化）</h3><h5 id="1-最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获得的最大利润。"><a href="#1-最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获得的最大利润。" class="headerlink" title="1. 最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获得的最大利润。"></a>1. 最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获得的最大利润。</h5><p>所以，动态转移方程为：</p>
<p><code>dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i]);</code></p>
<p><code>dp[i][1] = max(dp[i - 1][1], -prices[i]);</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = prices.size();</span><br><span class="line">        <span class="keyword">int</span> dp[n][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>, dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>], -prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="2-尽可能地完成更多的交易获取最大的利润（其实就是不限制交易次数）"><a href="#2-尽可能地完成更多的交易获取最大的利润（其实就是不限制交易次数）" class="headerlink" title="2. 尽可能地完成更多的交易获取最大的利润（其实就是不限制交易次数）"></a>2. 尽可能地完成更多的交易获取最大的利润（其实就是不限制交易次数）</h5><p>所以，动态转移方程为：</p>
<p><code>dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i]);</code></p>
<p><code>dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]);</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(prices.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = prices.size();</span><br><span class="line">    <span class="keyword">int</span> dp[n][<span class="number">2</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">        dp[i][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-最多只能完成两笔交易"><a href="#3-最多只能完成两笔交易" class="headerlink" title="3. 最多只能完成两笔交易"></a>3. 最多只能完成两笔交易</h5><p>这里需要注意的是枚举k</p>
<p>所以，动态转移方程为：</p>
<p><code>dp[i][k][0] = max(dp[i - 1][k][0], dp[i - 1][k][1] + prices[i])</code></p>
<p><code>dp[i][k][1] = max(dp[i - 1][k][1], dp[i - 1][k - 1][0] - prices[i])</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = prices.size(), max_k = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> dp[n][max_k + <span class="number">1</span>][<span class="number">2</span>] = &#123;&#123;&#123;<span class="number">0</span>&#125;&#125;&#125;; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = max_k; k &gt;= <span class="number">1</span>;k--) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][k][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                    dp[i][k][<span class="number">1</span>] = -prices[i];</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i][k][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][k][<span class="number">0</span>], dp[i - <span class="number">1</span>][k][<span class="number">1</span>] + prices[i]);</span><br><span class="line">                dp[i][k][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][k][<span class="number">1</span>], dp[i - <span class="number">1</span>][k - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][max_k][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="4-含冷冻期（即卖完股票的下一天不能买股票，必须过一天之后才能买股票）"><a href="#4-含冷冻期（即卖完股票的下一天不能买股票，必须过一天之后才能买股票）" class="headerlink" title="4. 含冷冻期（即卖完股票的下一天不能买股票，必须过一天之后才能买股票）"></a>4. 含冷冻期（即卖完股票的下一天不能买股票，必须过一天之后才能买股票）</h5><p>注意，这里画一个状态机会比较好解释</p>
<p>0状态表示可以买股票状态，1状态表示手上有股票，2表示刚刚卖出股票</p>
<p>所以0状态可以通过买股票到达1状态，也可以啥都不干仍停留在原状态</p>
<p>1状态可以啥也不干留在原状态，也可以卖掉股票到达2状态</p>
<p>2状态只能选择射也不做达到0状态（表示冷冻期）</p>
<p>所以，动态规划方程如下：</p>
<p><code>dp[i][0] = max(dp[i - 1][0], dp[i - 1][2]);</code></p>
<p><code>dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]);</code></p>
<p><code>dp[i][2] = dp[i - 1][1] + prices[i];</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.size();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> dp[n][<span class="number">3</span>] = &#123;&#123;<span class="number">0</span>&#125;&#125;;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>, dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>], dp[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">            dp[i][<span class="number">2</span>] = dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max(dp[n - <span class="number">1</span>][<span class="number">2</span>], dp[n - <span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="5-指定完成k笔交易"><a href="#5-指定完成k笔交易" class="headerlink" title="5. 指定完成k笔交易"></a>5. 指定完成k笔交易</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit_k</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices, <span class="keyword">int</span> max_k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = prices.size();</span><br><span class="line">    <span class="keyword">if</span>(max_k &gt; n / <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> dp[n][max_k + <span class="number">1</span>][<span class="number">2</span>] = &#123;&#123;&#123;<span class="number">0</span>&#125;&#125;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = max_k;k &gt;= <span class="number">1</span>;k--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i][k][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                dp[i][k][<span class="number">1</span>] = -prices[i];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][k][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][k][<span class="number">0</span>], dp[i - <span class="number">1</span>][k][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][k][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][k][<span class="number">1</span>], dp[i - <span class="number">1</span>][k - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>][max_k][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6-含手续费"><a href="#6-含手续费" class="headerlink" title="6. 含手续费"></a>6. 含手续费</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices, <span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.size();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> dp[n][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>, dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i] - fee);</span><br><span class="line">            dp[i][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后滚去看论文了…</p>
<p>没去实验室还被批斗了…惨兮兮.jpg</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://woojoo520.github.io/2019/09/17/LeetCode-Day33/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mariana">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Celery Fairy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/17/LeetCode-Day33/" itemprop="url">LeetCode-Day33</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-17T17:12:52+08:00">
                2019-09-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="LeetCode-Day33——继续贪心"><a href="#LeetCode-Day33——继续贪心" class="headerlink" title="LeetCode-Day33——继续贪心"></a>LeetCode-Day33——继续贪心</h2><h3 id="757-设置交集大小至少为2"><a href="#757-设置交集大小至少为2" class="headerlink" title="757. 设置交集大小至少为2"></a>757. 设置交集大小至少为2</h3><p>一个整数区间 [a, b]  ( a &lt; b ) 代表着从 a 到 b 的所有连续整数，包括 a 和 b。</p>
<p>给你一组整数区间intervals，请找到一个最小的集合 S，使得 S 里的元素与区间intervals中的每一个整数区间都至少有2个元素相交。</p>
<p>输出这个最小集合S的大小。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: intervals = [[1, 3], [1, 4], [2, 5], [3, 5]]</span><br><span class="line">输出: 3</span><br><span class="line">解释:</span><br><span class="line">考虑集合 S = &#123;2, 3, 4&#125;. S与intervals中的四个区间都有至少2个相交的元素。</span><br><span class="line">且这是S最小的情况，故我们输出3。</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: intervals = [[1, 2], [2, 3], [2, 4], [4, 5]]</span><br><span class="line">输出: 5</span><br><span class="line">解释:</span><br><span class="line">最小的集合S = &#123;1, 2, 3, 4, 5&#125;.</span><br></pre></td></tr></table></figure>

<p>注意:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">intervals 的长度范围为[1, 3000]。</span><br><span class="line">intervals[i] 长度为 2，分别代表左、右边界。</span><br><span class="line">intervals[i][j] 的值是 [0, 10^8]范围内的整数。</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>为了使集合S中的数字尽可能的少，我们希望处理区间的时候从小区间开始，如果区间b完全覆盖了区间a，那么和区间a有两个相同数字的集合一定也和区间b有两个相同的数字。同样，我们不希望一会儿处理一个前面的区间，一会儿处理后面一个区间，我们希望区间是有序的。如何排序？</p>
<p>我们按照结束位置从小往大排，当两个结束位置相同时，起始位置大的排前面处理，这也符合我们先处理小区间的原则。那么遍历区间的时候，当前区间就和我们维护的集合S有三种情况：</p>
<ul>
<li>二者完全没有交集，这时候我们就需要从当前区间中取出两个数字加入集合S，那么取哪两个数呢？为了尽可能少使用数字，我们取当前区间中的最大两个数字，因为我们区间位置不断变大，所以取大的数字有更高的概率能和后面的区间有交集。</li>
<li>二者有一个数字的交集，那么这个交集数字一定是区间的起始位置，那么我们需要再取一个数字加入集合S，根据上面的分析，我们取最大的那个数，即区间的结束位置。</li>
<li>二者有两个以及两个数字以上的交集，我们不用做任何处理。</li>
</ul>
<p>所以，Code如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">intersectionSizeTwo</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        sort(intervals.begin(), intervals.end(), [](<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>] || (a[<span class="number">1</span>] == b[<span class="number">1</span>] &amp;&amp; a[<span class="number">0</span>] &gt; b[<span class="number">0</span>]);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; intervals.size();i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = v.size();</span><br><span class="line">        <span class="keyword">if</span>(intervals[i][<span class="number">0</span>] &lt;= v[len - <span class="number">2</span>]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(intervals[i][<span class="number">0</span>] &gt; v.back()) &#123;</span><br><span class="line">            v.push_back(intervals[i][<span class="number">1</span>] - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        v.push_back(intervals[i][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v.size() - <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="763-划分字母区间"><a href="#763-划分字母区间" class="headerlink" title="763. 划分字母区间"></a>763. 划分字母区间</h3><p>字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一个字母只会出现在其中的一个片段。返回一个表示每个字符串片段的长度的列表。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: S = &quot;ababcbacadefegdehijhklij&quot;</span><br><span class="line">输出: [9,7,8]</span><br><span class="line">解释:</span><br><span class="line">划分结果为 &quot;ababcbaca&quot;, &quot;defegde&quot;, &quot;hijhklij&quot;。</span><br><span class="line">每个字母最多出现在一个片段中。</span><br><span class="line">像 &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; 的划分是错误的，因为划分的片段数较少。</span><br></pre></td></tr></table></figure>

<p>注意:</p>
<p>S的长度在[1, 500]之间。<br>S只包含小写字母’a’到’z’。</p>
<p>思路：其实这道题是map的一个应用。</p>
<p>首先遍历统计每个字母出现的最后的位置。</p>
<p>然后再遍历一遍，设置变量right用于表示分隔开的字符串的末尾在S里面的小标，变量left表示子字符串的开头在S里的下标</p>
<p>如果当前扫描的元素的最后一次出现的下标比right大，就说明字符串还需要延长，就刷新right</p>
<p>如果当前扫描的元素已经达到了right，就说明这个字符串已经完全找到了，就可以把答案添加到res中了。</p>
<p>Code如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; S.length();i++) &#123;</span><br><span class="line">        <span class="built_in">map</span>[S[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; S.size();i++) &#123;</span><br><span class="line">        end = max(end, <span class="built_in">map</span>[S[i]]);</span><br><span class="line">        <span class="keyword">if</span>(i == end) &#123;</span><br><span class="line">            result.push_back(end - start + <span class="number">1</span>);</span><br><span class="line">            start = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Mariana</p>
              <p class="site-description motion-element" itemprop="description">a study blog</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">105</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mariana</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
