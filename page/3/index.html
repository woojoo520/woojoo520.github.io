<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="a study blog">
<meta property="og:type" content="website">
<meta property="og:title" content="Celery Fairy">
<meta property="og:url" content="https://woojoo520.github.io/page/3/index.html">
<meta property="og:site_name" content="Celery Fairy">
<meta property="og:description" content="a study blog">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Celery Fairy">
<meta name="twitter:description" content="a study blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://woojoo520.github.io/page/3/">





  <title>Celery Fairy</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <a href="https://github.com/woojoo520" class="github-corner" aria-label="View source on GitHub">
      <svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/>
      </svg>
    </a>
    <style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Celery Fairy</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Celery's Blog</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://woojoo520.github.io/2019/09/25/cGAN/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mariana">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Celery Fairy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/25/cGAN/" itemprop="url">cGAN</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-25T21:17:11+08:00">
                2019-09-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="cGAN"><a href="#cGAN" class="headerlink" title="cGAN"></a>cGAN</h2><h3 id="为什么要有cGAN？"><a href="#为什么要有cGAN？" class="headerlink" title="为什么要有cGAN？"></a>为什么要有cGAN？</h3><p>首先，GAN虽然厉害，但有个问题，其生成模型生成的样本完全是随机的，也就是完全取决于输入的噪声z，根本无法预测会生成数字1还是数字2.因此偶人提出了条件GAN，其思想也很简单，就是想要生成哪个数字，你输入的时候告诉我你想要的标签即可。为了达到这个目标，在训练的时候，就要加上标签。也就是G想要伪造数字1，就要在原本的z向量后面加十维的one-hot向量，在D那里也是，要判别什么，也要在尾部加上十维的one-hot向量</p>
<p><img src="https://pic4.zhimg.com/v2-b112245a817b2e813a65cdb3fe4620eb_b.jpg" alt="img"></p>
<p>以上图为例，如果迷行的输入是文字，输出是图片，使用传统的做法会产生模糊的问题。比如输入火车，希望得到一张火车的图片，可是火车有侧面，有不同的形态，如果不加约束，则可能产生一张包含各种样式的火车的平均（模糊）图。</p>
<p>​    GAN的机制是只要识别器能分辨得出一张图是人工生成的还是原图就行，所以不能确保输入火车就回生成火车图片，比如输入火车生成一张很逼真的猫图，生成器也会被认为是一个成功的生成器（GAN容易钻空子，即如果某种特定形式可以骗过生成器，生成器会倾向于生成这种模式）</p>
<p>生成器输出一张图片，然后将同样的语句（条件）和生成的图片一起输入识别器，关键是，识别器不仅需要分辨真假，还需要分辨出语句（条件）和图片是否匹配。总的来说有三种情况：</p>
<p>原图 + 图和条件匹配   —-&gt;     高分</p>
<p>原图 + 图和条件不匹配   —-&gt;     低分</p>
<p>人工图      —-&gt;     低分</p>
<p><img src="https://pic1.zhimg.com/v2-ec6da03ab4ea2b7eb4cb7b32bb81b428_b.jpg" alt="img"></p>
<p>通过这样的操作，可以确保输出样本和条件是匹配的</p>
<p>CGAN有两种比较常用的结构：</p>
<p><img src="https://pic4.zhimg.com/v2-2e71198971ecf978048df60d6862dfef_b.jpg" alt="img"></p>
<p>这两种结构的主要区别在生成器的输出部分，下面的可能更加合理：</p>
<p>下半部分的结构中生成器的输出分为两部分：</p>
<ul>
<li>是否是真实图片</li>
<li>输出与条件是否匹配</li>
</ul>
<p>这样做的好处是，直观上说，模型能分别知道两个任务的性能，更有针对性地提高模型能力，如果输出的图像不够真实，但是能比较好地是辈出是否匹配，则主要调节生成样本的分支，而第一种结构由于是混合在一起的，就没有这种针对性调节的能力。</p>
<p>值得一提的是，论文里的识别器使用了Patch的方法，即先将输出样本划分为若干个Patch，然后对每个Patch进行评分，最后将所有patch的得分平均作为最后得分。这样做的好处是，识别器能更加关注到生成图像的细节部分，即对高频的部分更加敏感，当然，最极端是每一个像素就是一个patch，这样的话识别器会失去大局观，即失去不同部分空间部分之间的相关信息</p>
<p><img src="https://pic3.zhimg.com/v2-e99cc2059b659feab28652048fda92ba_b.jpg" alt="img"></p>
<p>一些用到的函数的详解：</p>
<p><code>torch.nn.Embedding(num_embeddings, emcedding_dim, padding_idx = None, max_norm = None, norm_type = 2, scale_grad_by_freq = False, sparse = False)</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Pytorch官网的解释是：一个保存了固定字典的带下和简单查找表。这个模块常用来保存字典嵌入和用下标检索它们。模块的输入是一个下标的列表，输出是对应的词嵌入</span></span><br><span class="line"><span class="comment"># 个人理解：这是一个矩阵类，里面初始化了一个随机矩阵，矩阵的长是字典的大小，宽是用来表示字典中每个元素的属性向量，向量的维度根据你想要的元素的复杂度而定。类实例化之后可以根据字典中元素的下标来查找元素对应的向量。例如输入下标0， 输出就是embeds矩阵中的第0行</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> torch</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>label = nn.Embedding(<span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>label(Variable(torch.LongTensor([<span class="number">4</span>])))</span><br><span class="line">tensor([[<span class="number">-0.6134</span>,  <span class="number">0.0528</span>,  <span class="number">2.4490</span>, <span class="number">-0.0294</span>,  <span class="number">1.2371</span>,  <span class="number">0.5792</span>, <span class="number">-1.2843</span>,  <span class="number">0.6881</span>,</span><br><span class="line">         <span class="number">-0.9275</span>,  <span class="number">1.2503</span>]], grad_fn=&lt;EmbeddingBackward&gt;)</span><br></pre></td></tr></table></figure>

<p><code>nn.prod()</code>        连乘函数</p>
<p><code>torch.cat()</code>    连接函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = torch.randn(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = torch.randn(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">tensor([[ <span class="number">2.2045</span>,  <span class="number">1.0283</span>,  <span class="number">0.7637</span>],</span><br><span class="line">        [ <span class="number">0.8578</span>, <span class="number">-0.8376</span>, <span class="number">-0.3780</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y</span><br><span class="line">tensor([[<span class="number">-0.5941</span>, <span class="number">-0.8588</span>,  <span class="number">0.9540</span>],</span><br><span class="line">        [<span class="number">-1.1115</span>,  <span class="number">0.3655</span>,  <span class="number">0.2471</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.cat((x, y), <span class="number">0</span>)</span><br><span class="line">tensor([[ <span class="number">2.2045</span>,  <span class="number">1.0283</span>,  <span class="number">0.7637</span>],</span><br><span class="line">        [ <span class="number">0.8578</span>, <span class="number">-0.8376</span>, <span class="number">-0.3780</span>],</span><br><span class="line">        [<span class="number">-0.5941</span>, <span class="number">-0.8588</span>,  <span class="number">0.9540</span>],</span><br><span class="line">        [<span class="number">-1.1115</span>,  <span class="number">0.3655</span>,  <span class="number">0.2471</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.cat((x, y), <span class="number">1</span>)</span><br><span class="line">tensor([[ <span class="number">2.2045</span>,  <span class="number">1.0283</span>,  <span class="number">0.7637</span>, <span class="number">-0.5941</span>, <span class="number">-0.8588</span>,  <span class="number">0.9540</span>],</span><br><span class="line">        [ <span class="number">0.8578</span>, <span class="number">-0.8376</span>, <span class="number">-0.3780</span>, <span class="number">-1.1115</span>,  <span class="number">0.3655</span>,  <span class="number">0.2471</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.cat((x, y), <span class="number">-1</span>)</span><br><span class="line">tensor([[ <span class="number">2.2045</span>,  <span class="number">1.0283</span>,  <span class="number">0.7637</span>, <span class="number">-0.5941</span>, <span class="number">-0.8588</span>,  <span class="number">0.9540</span>],</span><br><span class="line">        [ <span class="number">0.8578</span>, <span class="number">-0.8376</span>, <span class="number">-0.3780</span>, <span class="number">-1.1115</span>,  <span class="number">0.3655</span>,  <span class="number">0.2471</span>]])</span><br><span class="line"><span class="comment"># torch.cat((), 0)	竖着连接</span></span><br><span class="line"><span class="comment"># torch.cat((), 1 or -1)	横着连接</span></span><br></pre></td></tr></table></figure>

<p><code>numpy.random.randint(low, high, size)</code></p>
<p>low、high、size三个参数。默认high是None，如果只有low，那范围就是<code>[0, low)</code>。如果有high，范围就是<code>[low, high)</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.random.randint(<span class="number">5</span>, <span class="number">16</span>, <span class="number">64</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([<span class="number">13</span>, <span class="number">14</span>, <span class="number">12</span>, <span class="number">15</span>,  <span class="number">8</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">11</span>, <span class="number">11</span>, <span class="number">10</span>, <span class="number">14</span>, <span class="number">15</span>,  <span class="number">8</span>, <span class="number">15</span>,  <span class="number">5</span>, <span class="number">12</span>,  <span class="number">6</span>,</span><br><span class="line">       <span class="number">15</span>,  <span class="number">9</span>,  <span class="number">5</span>,  <span class="number">5</span>, <span class="number">13</span>, <span class="number">13</span>,  <span class="number">8</span>, <span class="number">15</span>, <span class="number">10</span>, <span class="number">11</span>,  <span class="number">6</span>,  <span class="number">8</span>, <span class="number">15</span>,  <span class="number">9</span>,  <span class="number">9</span>,  <span class="number">9</span>,  <span class="number">5</span>,</span><br><span class="line">       <span class="number">13</span>, <span class="number">12</span>, <span class="number">12</span>,  <span class="number">8</span>,  <span class="number">5</span>, <span class="number">14</span>,  <span class="number">7</span>, <span class="number">15</span>, <span class="number">11</span>,  <span class="number">6</span>,  <span class="number">7</span>, <span class="number">12</span>, <span class="number">10</span>,  <span class="number">8</span>, <span class="number">10</span>,  <span class="number">5</span>, <span class="number">13</span>,</span><br><span class="line">        <span class="number">9</span>, <span class="number">14</span>,  <span class="number">8</span>,  <span class="number">7</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">6</span>,  <span class="number">6</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">15</span>, <span class="number">14</span>, <span class="number">10</span>])</span><br></pre></td></tr></table></figure>

<p><code>np.random.normal(loc=0.0, scale=1.0, siez=None)</code></p>
<p>loc：float，此概率分布的均值（对应整个分布的重心center）</p>
<p>scale：float，此概率分布的标准差（对应于分布的宽度，scale越大越矮胖。scale越小，越瘦高）</p>
<p>size：int or tuple of ints</p>
<p>输出的shape，默认为None， 值输出一个值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.random.normal(<span class="number">5</span>, <span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line"><span class="number">4.687275350809846</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.random.normal(<span class="number">5</span>, <span class="number">1</span>, [<span class="number">2</span>, <span class="number">2</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([[<span class="number">5.18009118</span>, <span class="number">4.91448971</span>],</span><br><span class="line">       [<span class="number">6.2771917</span> , <span class="number">5.15529855</span>]])</span><br></pre></td></tr></table></figure>

<p>$IS(G) = exp(E_{x \sim p_g}D_{KL}(p(y|x)||p(y)))$</p>
<p>$D(p||q) = \sum p(x) log \frac{p(x)} {q(x)} $</p>
<p>$FID = ||u_r - u_g||^2 + T_r(\sum_r + \sum_g - 2(\sum_r - \sum_g)^{\frac{1} {2}})$</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://woojoo520.github.io/2019/09/25/交叉熵/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mariana">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Celery Fairy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/25/交叉熵/" itemprop="url">交叉熵</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-25T15:20:30+08:00">
                2019-09-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="关于交叉熵在loss函数中使用的理解"><a href="#关于交叉熵在loss函数中使用的理解" class="headerlink" title="关于交叉熵在loss函数中使用的理解"></a>关于交叉熵在loss函数中使用的理解</h2><h3 id="信息论"><a href="#信息论" class="headerlink" title="信息论"></a>信息论</h3><p>交叉熵是信息论中的一个概念，想要了解交叉熵的本质，需要从最基本的概念讲起。</p>
<h3 id="1-信息量"><a href="#1-信息量" class="headerlink" title="1. 信息量"></a>1. 信息量</h3><p>首先是信息量。假设我们听到了两件事，分别如下：<br>事件A：巴西队进入了2018世界杯决赛圈。<br>事件B：中国队进入了2018世界杯决赛圈。<br>仅凭直觉来说，显而易见事件B的信息量比事件A的信息量要大。究其原因，是因为事件A发生的概率很大，事件B发生的概率很小。所以当越不可能的事件发生了，我们获取到的信息量就越大。越可能发生的事件发生了，我们获取到的信息量就越小。那么信息量应该和事件发生的概率有关。</p>
<p>假设$X$是一个离散型随机变量，其取值集合为$χ$,概率分布函数$p(x)=Pr(X=x),x∈χ$,则定义事件$X=x_0$的信息量为：</p>
<p>$I(x_0) = -log(p(x_0))$</p>
<p>由于是概率所以$p(x_0)$的取值范围是[0, 1],绘制为图形如下：</p>
<p><img src="https://img-blog.csdn.net/20180125164333234?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdHN5Y2NuaA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="è¿éåå¾çæè¿°"></p>
<h3 id="2-熵"><a href="#2-熵" class="headerlink" title="2. 熵"></a>2. 熵</h3><p>考虑另一个问题，对于某个事件，有nn种可能性，每一种可能性都有一个概率$p(xi)$这样就可以计算出某一种可能性的信息量。举一个例子，假设你拿出了你的电脑，按下开关，会有三种可能性，下表列出了每一种可能的概率及其对应的信息量</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>事件</th>
<th>概率p</th>
<th>信息量I</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>电脑正常开机</td>
<td>0.7</td>
<td>-log(p(A))=0.36</td>
</tr>
<tr>
<td>B</td>
<td>电脑无法开机</td>
<td>0.2</td>
<td>-log(p(B))=1.61</td>
</tr>
<tr>
<td>C</td>
<td>电脑爆炸了</td>
<td>0.1</td>
<td>-log(p(C))=2.30</td>
</tr>
</tbody></table>
<p><code>注：文中的对数均为自然对数</code></p>
<p>我们现在有了信息量的定义，而熵用来表示所有信息量的期望，即：</p>
<p>$H(X) = -\sum_{i = 1}^{n}{p(x_i)log(p(x_i))}$</p>
<p>其中n代表所有的n种可能性，所以上面的问题的结果就是</p>
<p>$H(X) = -[p(A)log(p(A)) + p(B)log(p(B)) + p(C)log(p(C))] = 0.7\times0.36 + 0.2 \times 1.61 + 0.1 \times * 2.30 = 0.804$</p>
<p>然而，有一类比较太特殊的问题，比如，投掷硬币只有两种可能，字朝上或花朝上。买彩票只有两种可能，中奖或不中奖。我们称之为0-1分布（二项分布的特例），对于这类问题，熵的计算方法可以简化为如下算式：</p>
<p>$H(X) = -\sum_{i = 1}^{n} p(x_i)log(p(x_i)) = -p(x)log(p(x)) - (1 - p(x))log(1-p(x))$</p>
<h3 id="3-相对熵"><a href="#3-相对熵" class="headerlink" title="3. 相对熵"></a>3. 相对熵</h3><p>相对熵又称<strong>KL散度</strong>，如果我们对于同一个随机变量x有两个单独的概率分布P(x)或Q(x)，我们可以使用KL散度来衡量这两个分布的差异。</p>
<p>即如果用P来描述目标问题，而不是用Q来描述目标问题，得到的信息增量。</p>
<p>在机器学习中，P往往用来表示样本的真实分布，比如[1,0,0]表示当前样本属于第一类。Q用来表示模型所预测的分布，比如[0.7,0.2,0.1]<br>直观的理解就是如果用P来描述样本，那么就非常完美。而用Q来描述样本，虽然可以大致描述，但是不是那么的完美，信息量不足，需要额外的一些“信息增量”才能达到和P一样完美的描述。如果我们的Q通过反复训练，也能完美的描述样本，那么就不再需要额外的“信息增量”，Q等价于P。</p>
<p>KL散度的计算公式：</p>
<p><img src="C:%5CUsers%5C12751%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1569397275231.png" alt="1569397275231"></p>
<p>n为事件的所有可能性。</p>
<p>$D_{KL}$的值越小，表示q分布和p分布越接近</p>
<h3 id="4-交叉熵"><a href="#4-交叉熵" class="headerlink" title="4. 交叉熵"></a>4. 交叉熵</h3><p>对于KL散度的公式进行变形可以得到：</p>
<p><img src="C:%5CUsers%5C12751%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1569397402578.png" alt="1569397402578"></p>
<p>等式的前一部分恰巧就是p的熵，等式的后一部分，就是交叉熵</p>
<p>$H(p, q) = -\sum_{i = 1}^n p(x_i)log(q(x_i))$</p>
<p>在机器学习中，我们需要评估<code>label</code>和<code>predicts</code>之间的差距，使用KL散度刚刚好，即$D_{KL}(y||\hat y)$，由于KL散度中的前一部分$-H(y)$不变，故在优化过程中，只需要关注交叉熵就可以了。所以，一般在机器学习中直接使用交叉熵做loss，评估模型。</p>
<p>参考：<a href="https://blog.csdn.net/tsyccnh/article/details/79163834?tdsourcetag=s_pctim_aiomsg" target="_blank" rel="noopener">https://blog.csdn.net/tsyccnh/article/details/79163834?tdsourcetag=s_pctim_aiomsg</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://woojoo520.github.io/2019/09/25/LeetCode-Day40/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mariana">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Celery Fairy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/25/LeetCode-Day40/" itemprop="url">LeetCode-Day40</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-25T08:10:05+08:00">
                2019-09-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="464-我能赢吗"><a href="#464-我能赢吗" class="headerlink" title="464. 我能赢吗"></a>464. 我能赢吗</h3><p>在 “100 game” 这个游戏中，两名玩家轮流选择从 1 到 10 的任意整数，累计整数和，先使得累计整数和达到 100 的玩家，即为胜者。</p>
<p>如果我们将游戏规则改为 “玩家不能重复使用整数” 呢？</p>
<p>例如，两个玩家可以轮流从公共整数池中抽取从 1 到 15 的整数（不放回），直到累计整数和 &gt;= 100。</p>
<p>给定一个整数 maxChoosableInteger （整数池中可选择的最大数）和另一个整数 desiredTotal（累计和），判断先出手的玩家是否能稳赢（假设两位玩家游戏时都表现最佳）？</p>
<p>你可以假设 maxChoosableInteger 不会大于 20， desiredTotal 不会大于 300。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">maxChoosableInteger = 10</span><br><span class="line">desiredTotal = 11</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">false</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">无论第一个玩家选择哪个整数，他都会失败。</span><br><span class="line">第一个玩家可以选择从 1 到 10 的整数。</span><br><span class="line">如果第一个玩家选择 1，那么第二个玩家只能选择从 2 到 10 的整数。</span><br><span class="line">第二个玩家可以通过选择整数 10（那么累积和为 11 &gt;= desiredTotal），从而取得胜利.</span><br><span class="line">同样地，第一个玩家选择任意其他整数，第二个玩家都会赢。</span><br></pre></td></tr></table></figure>

<p>暂时还不知道什么想法…</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> bits, <span class="keyword">int</span> distance, <span class="keyword">int</span> maxChoosableInteger, <span class="keyword">int</span> dp[])</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 已经计算过。0：未计算，1：true， 2：false</span></span><br><span class="line">        <span class="keyword">if</span>(dp[bits] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> dp[bits] == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> result = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> cur = maxChoosableInteger;cur &gt; <span class="number">0</span>;cur--) &#123;</span><br><span class="line">            <span class="keyword">int</span> curBit = <span class="number">1</span> &lt;&lt; (cur - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 如果当前值没有被使用</span></span><br><span class="line">            <span class="keyword">if</span>((bits &amp; curBit) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 可以一步成功</span></span><br><span class="line">                <span class="keyword">if</span>(cur &gt;= distance || !helper(bits | curBit, distance - cur, maxChoosableInteger, dp)) &#123;</span><br><span class="line">                    result = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[bits] = result ? <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canIWin</span><span class="params">(<span class="keyword">int</span> maxChoosableInteger, <span class="keyword">int</span> desiredTotal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> canReachTotal = (<span class="number">1</span> + maxChoosableInteger) * maxChoosableInteger / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(canReachTotal &lt; desiredTotal) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(canReachTotal == desiredTotal) &#123;</span><br><span class="line">            <span class="comment">// 刚好达到的时候，maxChoosableInteger是奇数的时候赢</span></span><br><span class="line">            <span class="keyword">return</span> (maxChoosableInteger &amp; <span class="number">1</span>) == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> dp[<span class="number">1</span> &lt;&lt; maxChoosableInteger] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">0</span>, desiredTotal, maxChoosableInteger, dp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="410-分割数组的最大值"><a href="#410-分割数组的最大值" class="headerlink" title="410. 分割数组的最大值"></a>410. 分割数组的最大值</h3><p>给定一个非负整数数组和一个整数 m，你需要将这个数组分成 m 个非空的连续子数组。设计一个算法使得这 m 个子数组各自和的最大值最小。</p>
<p>注意:<br>数组长度 n 满足以下条件:</p>
<p>1 ≤ n ≤ 1000<br>1 ≤ m ≤ min(50, n)<br>示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">nums = [7,2,5,10,8]</span><br><span class="line">m = 2</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">18</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">一共有四种方法将nums分割为2个子数组。</span><br><span class="line">其中最好的方式是将其分为[7,2,5] 和 [10,8]，</span><br><span class="line">因为此时这两个子数组各自的和的最大值为18，在所有情况中最小。</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>我们能够找到这个答案的一个性质：</p>
<p><code>如果我们找到了一种分割方案，使得最大的分割子数组和不超过x，那么我们也能找到一种分割方案使得最大的分割子数组和不超过y，其中y &gt; x</code></p>
<p>对于值<code>x</code>，我们把这个性质定义为<code>F(x)</code>。如果<code>F(x)</code>为真，那就意味着我们一定可以找到一种分割方案使得最大分割的子数组和不超过<code>x</code></p>
<p>我们让<code>x</code>的区间为<code>负无穷大</code>到<code>无穷大</code>，一旦我们找到一个值<code>x0</code>，使得所有的<code>x &lt; x0</code>,<code>F(x)</code>都为假，所有的<code>x &gt; x0</code>，<code>F(x)</code>都为真。那么显然，这个<code>x0</code>就是我们要的答案了。</p>
<p>算法描述：</p>
<ul>
<li>找到一个数，把它作为分割后各个子数组的和的最大值</li>
<li>根据这个最大值，分割数组，使每个子数组的和都不超过这个最大值</li>
<li>如果不能将数组中所有数字都分割进子数组，即还没分割完，子数组数量就已经用完了。则表示这个最大值还不够大。寻找下一个数，循环步骤1-3</li>
<li>如果全部都分割进子数组，则返回这个最大值。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">splitArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> l = nums[<span class="number">0</span>], h = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : nums) &#123;</span><br><span class="line">            h += i;</span><br><span class="line">            l = max(l, <span class="keyword">long</span>(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; h) &#123;</span><br><span class="line">            <span class="keyword">long</span> mid = (l + h) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">long</span> temp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">1</span>;    <span class="comment">// 初始值必须为1</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> i : nums) &#123;</span><br><span class="line">                temp += i;</span><br><span class="line">                <span class="keyword">if</span>(temp &gt; mid) &#123;</span><br><span class="line">                    temp = i;</span><br><span class="line">                    ++cnt;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cnt &gt; m) &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 能够找到这个分组的时候，开始缩小范围</span></span><br><span class="line">                h = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="467-环绕字符串中唯一的字符串"><a href="#467-环绕字符串中唯一的字符串" class="headerlink" title="467. 环绕字符串中唯一的字符串"></a>467. 环绕字符串中唯一的字符串</h3><p>把字符串 s 看作是“abcdefghijklmnopqrstuvwxyz”的无限环绕字符串，所以 s 看起来是这样的：”…zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd….”. </p>
<p>现在我们有了另一个字符串 p 。你需要的是找出 s 中有多少个唯一的 p 的非空子串，尤其是当你的输入是字符串 p ，你需要输出字符串 s 中 p 的不同的非空子串的数目。 </p>
<p>注意: p 仅由小写的英文字母组成，p 的大小可能超过 10000。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;a&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 字符串 S 中只有一个&quot;a&quot;子字符。</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;cac&quot;</span><br><span class="line">输出: 2</span><br><span class="line">解释: 字符串 S 中的字符串“cac”只有两个子串“a”、“c”。</span><br></pre></td></tr></table></figure>

<p>示例 3:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;zab&quot;</span><br><span class="line">输出: 6</span><br><span class="line">解释: 在字符串 S 中有六个子串“z”、“a”、“b”、“za”、“ab”、“zab”。</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findSubstringInWraproundString</span><span class="params">(<span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = p.length();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录到这个字符为止的最长子序列长度</span></span><br><span class="line">        <span class="keyword">int</span> len_string[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        len_string[p[<span class="number">0</span>] - <span class="string">'a'</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// dp用于记录到目前为止的最长的子序列长度</span></span><br><span class="line">        <span class="keyword">int</span> dp = <span class="number">1</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++) &#123;</span><br><span class="line">            <span class="comment">// 更新dp</span></span><br><span class="line">            <span class="keyword">if</span>(p[i] == p[i - <span class="number">1</span>] + <span class="number">1</span> || (p[i - <span class="number">1</span>] == <span class="string">'z'</span> &amp;&amp; p[i] == <span class="string">'a'</span>)) &#123;</span><br><span class="line">                dp += <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新len_string(可以这么做的原因是某个字符前面的连续串是确定的，所以以某个字符结尾的串的长度一旦大于原先以这个字符结尾的串的长度，则说明，现在的串一定是覆盖了原来的串，不会出现重复的问题的)</span></span><br><span class="line">            len_string[p[i] - <span class="string">'a'</span>] = max(len_string[p[i] - <span class="string">'a'</span>], dp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>;i++) &#123;</span><br><span class="line">            sum += len_string[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="516-最长回文子序列"><a href="#516-最长回文子序列" class="headerlink" title="516. 最长回文子序列"></a>516. 最长回文子序列</h3><p>给定一个字符串s，找到其中最长的回文子序列。可以假设s的最大长度为1000。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">&quot;bbbab&quot;</span><br><span class="line">输出:</span><br><span class="line">4</span><br><span class="line">一个可能的最长回文子序列为 &quot;bbbb&quot;。</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">&quot;cbbd&quot;</span><br><span class="line">输出:</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>典型的动态规划。记<code>dp[i][j]</code>表示从<code>i-j</code>的最长回文子序列</p>
<p>如果<code>s[i] == s[j]</code>，则<code>dp[i][j] = dp[i + 1][j - 1] + 2</code></p>
<p>否则<code>dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])</code></p>
<p>上Code：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxLength =  <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n ,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--) &#123;</span><br><span class="line">            dp[i][i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>;j &lt; n;j++) &#123;</span><br><span class="line">                dp[i][j] = s[i] == s[j] ? dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span> : max(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                maxLength = max(maxLength, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://woojoo520.github.io/2019/09/23/LeetCode-Day39/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mariana">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Celery Fairy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/23/LeetCode-Day39/" itemprop="url">LeetCode-Day39</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-23T13:10:13+08:00">
                2019-09-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209. 长度最小的子数组"></a>209. 长度最小的子数组</h3><p>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组。如果不存在符合条件的连续子数组，返回 0。</p>
<p>示例: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = 7, nums = [2,3,1,2,4,3]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 子数组 [4,3] 是该条件下的长度最小的连续子数组。</span><br></pre></td></tr></table></figure>

<p>思路：这个问题其实很容易就能想到在$O(n^2)$的时间复杂度下解决问题，但是这里采用了一种$O(nlogn)$的做法去解决这个问题。</p>
<p>首先，我们先求解<code>sums</code>数组，表示从头加到当前位置的和。</p>
<p>然后从<code>i = 1</code>到<code>n</code>枚举</p>
<ul>
<li><p>首先<code>to_find</code>定义为当前位置的<code>sum</code>值加上<code>s</code></p>
</li>
<li><p>在<code>sums</code>中找到值<code>to_find</code>最早能插入的地方，即满足从<code>i</code>开始，往后搜索差值为<code>s</code>的需要的最短距离。</p>
<p>在这里搜索的过程中可以采用二分搜索的方法，但是还有一个小技巧，就是利用<code>STL</code>中的<code>lower_bound</code>函数，来表示某一个数字最早能够插入在数组中的位置，这样显然就很高效了鸭~</p>
</li>
</ul>
<p>上Code：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen2</span><span class="params">(<span class="keyword">int</span> s, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sums(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        sums[i] = sums[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>]; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> to_find = s + sums[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">auto</span> bound = lower_bound(sums.begin(), sums.end(), to_find);</span><br><span class="line">        <span class="keyword">if</span>(bound != sums.end()) &#123;</span><br><span class="line">            ans = min(ans, <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt; (bound - (sums.begin() + i - <span class="number">1</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (ans != INT_MAX) ? ans : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于<code>lower_bound &amp;&amp; upper_bound</code>的测试</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; num(a, a + <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; num.size();i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; num[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt; (lower_bound(num.begin(), num.end(), <span class="number">2</span>) - num.begin()) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt; (upper_bound(num.begin(), num.end(), <span class="number">2</span>) - num.begin()) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<h3 id="128-最长连续序列"><a href="#128-最长连续序列" class="headerlink" title="128. 最长连续序列"></a>128. 最长连续序列</h3><p>给定一个未排序的整数数组，找出最长连续序列的长度。</p>
<p>要求算法的时间复杂度为 O(n)。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [100, 4, 200, 1, 3, 2]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 最长连续序列是 [1, 2, 3, 4]。它的长度为 4。</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p><strong>哈希表 + 线性空间的构造</strong></p>
<p>我们先将所有元素放进一个<code>Hash set</code>中，然后遍历<code>num_set</code>中的每一个元素，如果它前面一个数字没有在<code>num_set</code>中，那么它一定不是一个连续数组的开始，则跳过。如果是连续数组的开始，那么就需要一种往后找连续的元素是否存在，然后记录下最长的数列长度。</p>
<p>上Code：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; num_set;</span><br><span class="line">        <span class="keyword">int</span> maxLength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            num_set.insert(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : num_set) &#123;</span><br><span class="line">            <span class="keyword">if</span>(num_set.find(num - <span class="number">1</span>) == num_set.end()) &#123;</span><br><span class="line">                <span class="keyword">int</span> currentNum = num;</span><br><span class="line">                <span class="keyword">int</span> currentLen = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(num_set.find(currentNum + <span class="number">1</span>) != num_set.end()) &#123;</span><br><span class="line">                    currentNum += <span class="number">1</span>;</span><br><span class="line">                    currentLen += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                maxLength = max(maxLength, currentLen);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里虽然看上去复杂度挺高，但实际上是$O(n)$复杂度的，因为每个数字只会遍历到一次，因为如果不是连续数字开头的，就直接跳过了，而是连续数字开头的，就一直遍历到连续数字的末尾，所以总的时间复杂度是$O(n)$的。</p>
<h3 id="126-单词接龙II"><a href="#126-单词接龙II" class="headerlink" title="126. 单词接龙II"></a>126. 单词接龙II</h3><p>给定两个单词（beginWord 和 endWord）和一个字典 wordList，找出所有从 beginWord 到 endWord 的最短转换序列。转换需遵循如下规则：</p>
<p>每次转换只能改变一个字母。<br>转换过程中的中间单词必须是字典中的单词。<br>说明:</p>
<p>如果不存在这样的转换序列，返回一个空列表。<br>所有单词具有相同的长度。<br>所有单词只由小写字母组成。<br>字典中不存在重复的单词。<br>你可以假设 beginWord 和 endWord 是非空的，且二者不相同。<br>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">beginWord = &quot;hit&quot;,</span><br><span class="line">endWord = &quot;cog&quot;,</span><br><span class="line">wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [&quot;hit&quot;,&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;cog&quot;],</span><br><span class="line">  [&quot;hit&quot;,&quot;hot&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">beginWord = &quot;hit&quot;</span><br><span class="line">endWord = &quot;cog&quot;</span><br><span class="line">wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]</span><br><span class="line"></span><br><span class="line">输出: []</span><br><span class="line">解释: endWord &quot;cog&quot; 不在字典中，所以不存在符合要求的转换序列。</span><br></pre></td></tr></table></figure>

<p>思路：<strong>双向BFS</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(<span class="built_in">string</span> beginWord, <span class="built_in">string</span> endWord, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordList)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; freqs;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;word:wordList)</span><br><span class="line">			freqs[word]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(freqs.count(endWord)==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; q1(&#123;beginWord&#125;), q2(&#123;endWord&#125;);</span><br><span class="line">		<span class="keyword">int</span> step=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(freqs[beginWord]|=<span class="number">1</span>,freqs[endWord]|=<span class="number">2</span>; q1.size() &amp;&amp; q2.size(); ++step)&#123;</span><br><span class="line">			<span class="keyword">bool</span> first=q1.size()&lt;q2.size();</span><br><span class="line">			<span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; &amp;q=first?q1:q2;</span><br><span class="line">			<span class="keyword">int</span> flag=first?<span class="number">1</span>:<span class="number">2</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> size=q.size(); size--; q.pop())&#123;</span><br><span class="line">				<span class="built_in">string</span> &amp;word=q.front();</span><br><span class="line">				<span class="keyword">if</span>(freqs[word]==<span class="number">3</span>) <span class="keyword">return</span> step;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;word.length(); ++i)&#123;</span><br><span class="line">					<span class="keyword">for</span>(<span class="keyword">char</span> ch=<span class="string">'a'</span>; ch&lt;=<span class="string">'z'</span>; ++ch)&#123;</span><br><span class="line">						<span class="built_in">string</span> s=word;</span><br><span class="line">						<span class="keyword">if</span>(s[i]==ch) <span class="keyword">continue</span>;</span><br><span class="line">						s[i]=ch;</span><br><span class="line">						<span class="keyword">if</span>(freqs.count(s)==<span class="number">0</span> || freqs[s]&amp;flag) <span class="keyword">continue</span>;</span><br><span class="line">						freqs[s]|=flag;</span><br><span class="line">						q.push(s);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://woojoo520.github.io/2019/09/23/FFT/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mariana">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Celery Fairy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/23/FFT/" itemprop="url">FFT</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-23T13:09:48+08:00">
                2019-09-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="快速傅里叶变换FFT-Fast-Fourier-Transform"><a href="#快速傅里叶变换FFT-Fast-Fourier-Transform" class="headerlink" title="快速傅里叶变换FFT(Fast Fourier Transform)"></a>快速傅里叶变换FFT(Fast Fourier Transform)</h2><h3 id="傅里叶变换"><a href="#傅里叶变换" class="headerlink" title="傅里叶变换"></a>傅里叶变换</h3><p>快速傅里叶变换是一种可以在$O(nlogn)$时间内完成的离散傅里叶变换（DFT）算法。</p>
<p>在算法竞赛中的应用主要是用来加速多项式的乘法。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://woojoo520.github.io/2019/09/22/LeetCode-Day38/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mariana">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Celery Fairy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/22/LeetCode-Day38/" itemprop="url">LeetCode-Day38</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-22T21:53:02+08:00">
                2019-09-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="189-旋转数组"><a href="#189-旋转数组" class="headerlink" title="189. 旋转数组"></a>189. 旋转数组</h3><p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,5,6,7] 和 k = 3</span><br><span class="line">输出: [5,6,7,1,2,3,4]</span><br><span class="line">解释:</span><br><span class="line">向右旋转 1 步: [7,1,2,3,4,5,6]</span><br><span class="line">向右旋转 2 步: [6,7,1,2,3,4,5]</span><br><span class="line">向右旋转 3 步: [5,6,7,1,2,3,4]</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [-1,-100,3,99] 和 k = 2</span><br><span class="line">输出: [3,99,-1,-100]</span><br><span class="line">解释: </span><br><span class="line">向右旋转 1 步: [99,-1,-100,3]</span><br><span class="line">向右旋转 2 步: [3,99,-1,-100]</span><br></pre></td></tr></table></figure>

<p>思路：这道题虽然很简单，但是却有更加快速的操作。</p>
<p>就是先翻转整个数组，然后在要求的节点前后进行两次翻转。</p>
<p>举个栗子：</p>
<p><code>[1, 2, 3, 4, 5, 6, 7] k = 3</code></p>
<p>整个数组翻转：<code>[7, 6, 5, 4, 3, 2, 1]</code></p>
<p>前半部分翻转：<code>[5, 6, 7, 4, 3, 2, 1]</code></p>
<p>后半部分翻转：<code>[5, 6, 7, 1, 2, 3, 4]</code></p>
<p>上Code：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums.size() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        k %= nums.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n / <span class="number">2</span>;i++) &#123;</span><br><span class="line">            swap(nums[i], nums[n - <span class="number">1</span> - i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k / <span class="number">2</span>;i++) &#123;</span><br><span class="line">            swap(nums[i], nums[k - i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = k;i &lt; (n + k) / <span class="number">2</span>;i++) &#123;</span><br><span class="line">            swap(nums[i], nums[n - <span class="number">1</span> - i + k]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://woojoo520.github.io/2019/09/21/LeetCode-Day37/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mariana">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Celery Fairy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/21/LeetCode-Day37/" itemprop="url">LeetCode-Day37</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-21T07:13:57+08:00">
                2019-09-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="LeetCode-Day37——还在动态规划"><a href="#LeetCode-Day37——还在动态规划" class="headerlink" title="LeetCode-Day37——还在动态规划"></a>LeetCode-Day37——还在动态规划</h2><h3 id="368-最大整除子集"><a href="#368-最大整除子集" class="headerlink" title="368. 最大整除子集"></a>368. 最大整除子集</h3><p>给出一个由无重复的正整数组成的集合，找出其中最大的整除子集，子集中任意一对 (Si，Sj) 都要满足：Si % Sj = 0 或 Sj % Si = 0。</p>
<p>如果有多个目标子集，返回其中任何一个均可。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">输出: [1,2] (当然, [1,3] 也正确)</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: [1,2,4,8]</span><br><span class="line">输出: [1,2,4,8]</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>其实也没啥思路，就是先进行排序，然后用<code>i</code>顺序遍历, 用<code>j</code> 在<code>[0, i]</code>区间内遍历，查找能否加入当前满足的最大的整除子集，记录下满足的点的下标。</p>
<p>然后逆向查找，返回<code>res</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; largestDivisibleSubset(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; index(n, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    sort(nums.begin(), nums.end());</span><br><span class="line">    <span class="keyword">int</span> maxStart = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; i;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] % nums[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[i] &lt; dp[j] + <span class="number">1</span>) &#123;</span><br><span class="line">                    dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">                    index[i] = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        maxStart = dp[maxStart] &gt; dp[i] ? maxStart : i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(maxStart &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">        res.push_back(nums[maxStart]);</span><br><span class="line">        maxStart = index[maxStart];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="375-猜数字大小II"><a href="#375-猜数字大小II" class="headerlink" title="375. 猜数字大小II"></a>375. 猜数字大小II</h3><p><strong>依然DP</strong></p>
<p>算法：</p>
<p>以<code>i</code>为第一次尝试找到最小开销的过程可以被分解为找左右区间内最小开销的子问题。对于每个区间，我们重复问题拆分的过程，得到更多子问题，这启发我们可以用DP解决这个问题。</p>
<p>我们需要使用一个<code>dp</code>数组，其中<code>dp(i, j)</code>代表在<code>(i, j)</code>中最坏情况下的最小开销。现在我们只需要考虑如何求出这个<code>dp</code>数组。如果区间只剩下一个数<code>k</code>,那么猜中的代价永远为0，因为我们区间里只剩下一个数字，也就是说，所有的<code>dp(k, k)</code>都初始化为0。然后，对于长度为2的区间，我们需要所有长度为1的区间的结果。由此我们可以看出，为了求出长度为len区间的解。因此我们按照区间长度从短到长求出<code>dp</code>数组。</p>
<p>现在，我们应该按照什么办法来求出<code>dp</code>矩阵呢？对于每个<code>dp(i, j)</code>，当前长度为<code>len = j - i + 1</code>，我们一次挑选每个数字作为第一次尝试的答案。</p>
<p><code>cost(i, j) = pivot + max(cost(i, pivot - 1), cost(pivot + 1, n))</code></p>
<p>但是在计算开销的时候，我们有一个便利之处，就是我们已经知道了小于len长度的<code>dp</code>数组的所有答案。因此dp方程变成了</p>
<p>$dp(i, j) = min_{pivots(i, j)}[pivot + max(dp[i, pivot - 1], dp[pivot + 1, n])]$</p>
<p>其中$min_{pivots(i, j)}$表示将<code>(i, j)</code>中的每个数作为第一个尝试的数字</p>
<p>上Code：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMoney</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="comment">// 遍历长度，分别枚举长度从2 - n的分段，因为长度为1的花销为0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> len = <span class="number">2</span>;len &lt;= n;len++) &#123;</span><br><span class="line">        <span class="comment">// 遍历start的位置，从start开始，取长度为len，所以start必须要小于等于(n - len + 1)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> start = <span class="number">1</span>;start &lt;= n - len + <span class="number">1</span>;start++) &#123;</span><br><span class="line">            <span class="keyword">int</span> minres = INT_MAX;</span><br><span class="line">            <span class="comment">// 遍历(start, start + len)的区间，寻找最小代价</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> piv = start; piv &lt; start + len - <span class="number">1</span>;piv++) &#123;</span><br><span class="line">                <span class="keyword">int</span> res = piv + max(dp[start][piv - <span class="number">1</span>], dp[piv + <span class="number">1</span>][start + len - <span class="number">1</span>]);</span><br><span class="line">                minres = min(res, minres);</span><br><span class="line">            &#125;</span><br><span class="line">            dp[start][start + len - <span class="number">1</span>] = minres;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">1</span>][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="403-青蛙过河"><a href="#403-青蛙过河" class="headerlink" title="403. 青蛙过河"></a>403. 青蛙过河</h3><p>一只青蛙想要过河。 假定河流被等分为 x 个单元格，并且在每一个单元格内都有可能放有一石子（也有可能没有）。 青蛙可以跳上石头，但是不可以跳入水中。</p>
<p>给定石子的位置列表（用单元格序号升序表示）， 请判定青蛙能否成功过河（即能否在最后一步跳至最后一个石子上）。 开始时， 青蛙默认已站在第一个石子上，并可以假定它第一步只能跳跃一个单位（即只能从单元格1跳至单元格2）。</p>
<p>如果青蛙上一步跳跃了 k 个单位，那么它接下来的跳跃距离只能选择为 k - 1、k 或 k + 1个单位。 另请注意，青蛙只能向前方（终点的方向）跳跃。</p>
<p>请注意：</p>
<p>石子的数量 ≥ 2 且 &lt; 1100；<br>每一个石子的位置序号都是一个非负整数，且其 &lt; 231；<br>第一个石子的位置永远是0。<br>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[0,1,3,5,6,8,12,17]</span><br><span class="line">总共有8个石子。</span><br><span class="line">第一个石子处于序号为0的单元格的位置, 第二个石子处于序号为1的单元格的位置,</span><br><span class="line">第三个石子在序号为3的单元格的位置， 以此定义整个数组...</span><br><span class="line">最后一个石子处于序号为17的单元格的位置。</span><br><span class="line"></span><br><span class="line">返回 true。即青蛙可以成功过河，按照如下方案跳跃： </span><br><span class="line">跳1个单位到第2块石子, 然后跳2个单位到第3块石子, 接着 </span><br><span class="line">跳2个单位到第4块石子, 然后跳3个单位到第6块石子, </span><br><span class="line">跳4个单位到第7块石子, 最后，跳5个单位到第8个石子（即最后一块石子）。</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[0,1,2,3,4,8,9,11]</span><br><span class="line"></span><br><span class="line">返回 false。青蛙没有办法过河。 </span><br><span class="line">这是因为第5和第6个石子之间的间距太大，没有可选的方案供青蛙跳跃过去。</span><br></pre></td></tr></table></figure>

<p>有点难… 嗯…看看代码注释吧</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canCross</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(stones[<span class="number">1</span>] != <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> len = stones.size();</span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">bool</span> dp[len+<span class="number">5</span>][<span class="number">1200</span>]; <span class="comment">//在第i个石头并且是跳j步过来的可以不?</span></span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; len;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; i;j++)&#123;   <span class="comment">//遍历前面的所有石头</span></span><br><span class="line">            <span class="keyword">int</span> dist = stones[i] - stones[j];  <span class="comment">//前面的石头一定是跳dist步过来的</span></span><br><span class="line">            <span class="keyword">if</span>(dist &gt; <span class="number">1100</span>) <span class="keyword">continue</span>;</span><br><span class="line">            dp[i][dist] |= dp[j][dist<span class="number">-1</span>]|dp[j][dist]|dp[j][dist+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(i == len<span class="number">-1</span> &amp;&amp; dp[i][dist])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="硬核的东西来辽-各种背包问题！！"><a href="#硬核的东西来辽-各种背包问题！！" class="headerlink" title="硬核的东西来辽~ 各种背包问题！！"></a>硬核的东西来辽~ 各种背包问题！！</h3><h4 id="一-01背包"><a href="#一-01背包" class="headerlink" title="一. 01背包"></a>一. 01背包</h4><h5 id="【题目描述】："><a href="#【题目描述】：" class="headerlink" title="【题目描述】："></a>【题目描述】：</h5><p><code>一个旅行者有一个最多能装M公斤的背包，现在有n件物品，他们的重量分别是W1，W2…Wn，它们的价值分别是C1，C2……Cn，求旅行者能够获得的最大总价值。</code></p>
<h5 id="【输入格式】："><a href="#【输入格式】：" class="headerlink" title="【输入格式】："></a>【输入格式】：</h5><p><code>第一行：两个整数，M，（背包容量，M&lt;=200）和N（物品数量N&lt;=30）</code></p>
<p><code>第2至N+1行，每行两个整数，Wi,Ci,表示每个物品的重量和价值。</code></p>
<h5 id="【输出格式】："><a href="#【输出格式】：" class="headerlink" title="【输出格式】："></a>【输出格式】：</h5><p><code>仅一行，一个数，表示最大总价值。</code></p>
<h5 id="【输入样例】："><a href="#【输入样例】：" class="headerlink" title="【输入样例】："></a>【输入样例】：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">10 4</span><br><span class="line">2 1</span><br><span class="line">3 3</span><br><span class="line">4 5</span><br><span class="line">7 9</span><br></pre></td></tr></table></figure>

<p>【输出样例】：12</p>
<h5 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h5><p>01背包问题可以说是最简单的背包问题，简单之处在于：它的每个物品只有一个。</p>
<p>首先定义一个<code>f[MAXN][MAXN]</code>数组，用来记录最大值，即<code>f[i][v]</code>表示的是当前<code>i</code>件物品放入一个容量为<code>v</code>的背包的时候可以获得的最大值。</p>
<p>01背包的<strong>状态转移方程</strong>为: <code>f[i][v] = max(f[i - 1][v], f[i - 1][v - w[i]] + c[i])</code></p>
<p> 解释：如果只考虑第<code>i</code>件物品的方式策略，那么就只和第<code>i - 1</code>件物品有关了，如果是放第<code>i</code>间物品，那么问题就转换为：“前<code>i - 1</code>件物品放入容量为v的背包中”，此时能够获得的最大价值就是<code>f[i - 1][v - w[i]]</code>，也就是第<code>i - 1</code>件物品放入容量为v(原来的总容量)减去<code>w[i]</code>(第<code>i</code>间物品的占容产生的价值)，再加上放通过第<code>i</code>件物品增加的价值<code>c[i]</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bag01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// m表示背包总容量，n表示有n件物品</span></span><br><span class="line">    <span class="keyword">int</span> m, n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> w[n + <span class="number">1</span>] = &#123;<span class="number">0</span>&#125;, c[n + <span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;dp(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; (m + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; w[i] &gt;&gt; c[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="comment">// 这里需要注意是逆序的，因为保证第i次循环dp[i][j]的状态是从dp[i][j - w[i]]递推而来的，也就是为了保证每件物品只选一次，保证在考虑“选入第i件物品”这件策略时，依据的绝不可能选入第i件物品的子结果f[i][v - w[i]]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = m;j &gt; <span class="number">0</span>;j--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(w[i] &lt;= j) &#123;</span><br><span class="line">                dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - w[i]] + c[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二-完全背包问题"><a href="#二-完全背包问题" class="headerlink" title="二. 完全背包问题"></a>二. 完全背包问题</h4><h5 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h5><p>设有n种物品，每种物品有一个价值，但每种物品的数量是无限的，同时有一个背包，最大承载量为m，今从n种物品中选取若干件，（同一种物品可以多次选举）使其重量的和小于等于m，而且价值的和最大。</p>
<h5 id="【输入】"><a href="#【输入】" class="headerlink" title="【输入】"></a>【输入】</h5><p>共N+1行</p>
<p>第一行：两个整数：M（背包容量M&lt;=200）和N（物品数量，N&lt;=30）；</p>
<p>第二行至第N+1行，每行两个整数，Wi，Ci，表示每个物品的重量和价值。</p>
<h5 id="【输出】"><a href="#【输出】" class="headerlink" title="【输出】"></a>【输出】</h5><p>近一行：一个数，表示最大的价值；</p>
<h5 id="【输入样例】"><a href="#【输入样例】" class="headerlink" title="【输入样例】"></a>【输入样例】</h5><p>10 4</p>
<p>2 1</p>
<p>3 3</p>
<p>4 5</p>
<p>7 9</p>
<h5 id="【输出样例】"><a href="#【输出样例】" class="headerlink" title="【输出样例】"></a>【输出样例】</h5><p>12</p>
<h5 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h5><p>这一个问题与01背包唯一不同的地方，就是<strong>每种物品的数量是无限多的</strong>。</p>
<p>既然每种物品可以取很多次，那么，与它相关的策略就不是取或者不取的问题了，而是<strong>不取和取多少</strong>的问题了。</p>
<p>这个时候，其实我们只需要多一层关于每种物品选多少次的循环就可以了。相对的，状态转移方程也会有相应的改动。</p>
<p><code>f[i][v] = max(f[i - 1][v], f[i - 1][v - k * w[i]] + k * c[i])</code></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://woojoo520.github.io/2019/09/20/LeetCode-Day36/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mariana">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Celery Fairy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/20/LeetCode-Day36/" itemprop="url">LeetCode-Day36</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-20T10:50:48+08:00">
                2019-09-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="264-丑数II"><a href="#264-丑数II" class="headerlink" title="264. 丑数II"></a>264. 丑数II</h3><p>编写一个程序，找出第 n 个丑数。</p>
<p>丑数就是只包含质因数 2, 3, 5 的正整数。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: n = 10</span><br><span class="line">输出: 12</span><br><span class="line">解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。</span><br><span class="line">说明:  </span><br><span class="line">    1 是丑数。</span><br><span class="line">    n 不超过1690。</span><br></pre></td></tr></table></figure>

<p>思路：<strong>动态规划</strong></p>
<p>每次都找已经存在的数中 * 2或 * 3 或 * 5之后较小的值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> i2 = <span class="number">0</span>, i3 = <span class="number">0</span>, i5 = <span class="number">0</span>, i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i++ &lt; n) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = min(<span class="number">2</span> * res[i2], min(<span class="number">3</span> * res[i3], <span class="number">5</span> * res[i5]));</span><br><span class="line">            res.push_back(tmp);</span><br><span class="line">            <span class="keyword">if</span>(tmp == <span class="number">2</span> * res[i2])  i2++;</span><br><span class="line">            <span class="keyword">if</span>(tmp == <span class="number">3</span> * res[i3])  i3++;</span><br><span class="line">            <span class="keyword">if</span>(tmp == <span class="number">5</span> * res[i5])  i5++;</span><br><span class="line">        &#125;     </span><br><span class="line">        <span class="keyword">return</span> res.back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://woojoo520.github.io/2019/09/19/LeetCode-Day35/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mariana">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Celery Fairy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/19/LeetCode-Day35/" itemprop="url">LeetCode-Day35</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-19T20:59:43+08:00">
                2019-09-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="354-俄罗斯套娃信封问题"><a href="#354-俄罗斯套娃信封问题" class="headerlink" title="354. 俄罗斯套娃信封问题"></a>354. 俄罗斯套娃信封问题</h3><p>给定一些标记了宽度和高度的信封，宽度和高度以整数对形式 (w, h) 出现。当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。</p>
<p>请计算最多能有多少个信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。</p>
<p>说明:<br>不允许旋转信封。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: envelopes = [[5,4],[6,4],[6,7],[2,3]]</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 最多信封的个数为 3, 组合为: [2,3] =&gt; [5,4] =&gt; [6,7]。</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>其实这个问题就是最长上升子序列的一个升级版本。</p>
<p>但是我还是使用了$O(n^2)$的方法解决了问题，在评论区看到了对二分搜索的实现，所以拿出来讲一讲。</p>
<p>但是还没有看懂这个基于<code>envelopes[0]</code>排序，然后对<code>envelopes[1]</code>进行二分的骚操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxEnvelopes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; envelopes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(envelopes.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    sort(envelopes.begin(), envelopes.end(), [](<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>] || (a[<span class="number">0</span>] == b[<span class="number">0</span>] &amp;&amp; a[<span class="number">1</span>] &gt; b[<span class="number">1</span>]);</span><br><span class="line">    &#125;);    </span><br><span class="line">    <span class="keyword">int</span> n = envelopes.size(), maxSum = <span class="number">1</span>;;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(n, INT_MAX);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> e : envelopes) &#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = envelopes.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(vec[mid] &gt;= e[<span class="number">1</span>]) &#123;</span><br><span class="line">                high = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vec[low] = e[<span class="number">1</span>];</span><br><span class="line">        res = max(res, low);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://woojoo520.github.io/2019/09/19/StyleGAN/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mariana">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Celery Fairy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/19/StyleGAN/" itemprop="url">StyleGAN</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-19T12:21:42+08:00">
                2019-09-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>原有GAN出现的问题：</strong>与多数GAN一样，proGAN控制生成图像的特定特征的能力非常有限。这些属性相互纠缠，即使略微调整输入，也会同时影响生成图像的多个属性。所以如何将ProGAN该位条件生成模型，或者增强其微调单个属性的能力，是一个可以研究的方向。</p>
<p><strong>解决的方法：</strong></p>
<p>StyleGAN是NVIDIA继ProGAN之后提出的新的生成网络，其主要通过修改每一层级的输入，在不影响其它层级的情况下，开控制该层级所表示的视觉特征。这些特征可以使粗的特征（如姿势、脸型等），也可以是一些细节特征（如瞳色、发色等）</p>
<p>本文的工作及贡献：</p>
<ul>
<li><p>借鉴风格迁移，提出基于样式的生成器（style-based generator）</p>
<ul>
<li>实现了无监督地分离高级属性（人脸姿势、身份）和随机变化（例如雀斑，头发）</li>
<li>实现对生成图像中特定尺度的属性的控制</li>
<li>生成器从一个科学系的常量输入开始，隐码在每个卷积层调整图像的“样式”，从而直接控制不同尺度下图像特征的强度。</li>
</ul>
</li>
<li><p>实现了对<strong>隐空间（latent space）</strong>较好的解耦</p>
<ul>
<li>生成器将输入的隐码z嵌入一个中间的隐空间。因为输入的隐空间Z必须服从训练数据的概率密度，这在一定程度上导致了不可避免的纠缠，而嵌入的中间的隐空间W不受这个控制，因此可以被解耦</li>
</ul>
</li>
<li><p>提出了两个新的<strong>量化隐空间解耦程度</strong>的方法</p>
<ul>
<li>感知路径长度和线性可分性。与传统的生成器相比，新的生成器允许更线性、更解耦地表示不同的变化因素</li>
</ul>
</li>
<li><p>提出了新的高质量的人脸数据集（FFHQ,7万张1024 * 1024的人脸图片）</p>
<p>![img](file:///C:\Users\12751\Documents\Tencent Files\1275121799\Image\C2C{255CC7E5-BCDA-210F-8F43-B410432DFEB2}.png)</p>
</li>
</ul>
<h3 id="2-模型和方法"><a href="#2-模型和方法" class="headerlink" title="2. 模型和方法"></a>2. 模型和方法</h3><h4 id="2-1-基于样式的生成器结构"><a href="#2-1-基于样式的生成器结构" class="headerlink" title="2.1 基于样式的生成器结构"></a>2.1 基于样式的生成器结构</h4><p><img src="https://pic2.zhimg.com/v2-452bcc62544bdd83d4eb6e108f977a45_b.jpg" alt="img"></p>
<p>总共有18层，每个分辨率有两个卷积层（4， 8， 16， …1024）</p>
<ul>
<li><p>1.移除了传统的输入</p>
</li>
<li><p>2.映射网络</p>
</li>
<li><p>3.样式模块（AdaIN，自适应实例归一化）</p>
</li>
<li><p>4.随机变化（通过加入噪声为生成器生成随机细节）</p>
</li>
</ul>
<p><strong>移除传统输入</strong></p>
<p><img src="https://pic4.zhimg.com/v2-026759c4449b86d41d7b85b62c0868bb_b.jpg" alt="img"></p>
<p>传统的生成器使用latent code（随机输入）作为生成器的初始输入；StyleGAN抛弃了这种设计，将一个可学习的常数作为生成器的初始输入。一个假设是它减少了特征纠缠——对于网络来说，只使用w而不依赖纠缠的输入向量更容易学习</p>
<p><strong>映射网络（Mapping Network）</strong></p>
<p><img src="https://pic1.zhimg.com/v2-23b95580269d527ac1be9ccdf19fb030_b.jpg" alt="img"></p>
<p>映射网络由8个全连接层组成，其输出w与输入z大小相同（512 * 1）。<strong>映射网络的目标是将输入向量编码为中间向量，中间向量W的不同元素控制不同的视觉特征。</strong></p>
<p>使用输入向量z控制视觉特征的能力是有限的，它必须遵循训练数据的概率密度。例如，如果黑色头发的人的图像在数据集中更加常见，那么更多的输入值将映射到该特性。因此该模型无法将输入向量z的一部分（向量中的元素）映射到特征，这种向量称为特征纠缠。</p>
<p>但是，通过映射网络，该模型可以生成一个不需要跟随训练数据分布的向量w，并且可以减少特征之间的相关性（解耦，特征分离）</p>
<p><strong>样式模块（AdalN）</strong></p>
<p><img src="https://pic4.zhimg.com/v2-99f307a8cde4d1b0dfde84f2893a3ff7_b.jpg" alt="img"></p>
<p>W通过每个卷积层的AdaIN输入到生成器的每一层中。</p>
<p>计算方法：</p>
<ul>
<li>计算每个特征图xi（feature map）独立进行归一化<img src="https://www.zhihu.com/equation?tex=%28x_i-%CE%BC%28x_i%29%29+%2F%CF%83%28x_i%29" alt="[å¬å¼]">特征图中的每个值减去该特征值的均值然后除以方差。</li>
<li>一个可学习的仿射变换（全连接层）将w转换为style中AdaIN的平移和缩放因子 $y = (y_s, i, y_b, i)$</li>
<li>然后对每个特征图分别使用style中学习到的平移和缩放因子进行尺度和平移变换</li>
</ul>
<p>这里的不同之处在于这里的缩放和平移是用隐码w计算得到，而不是用一个图像计算得到的。</p>
<p><strong>随机变化（通过引入噪声为生成器生成随机细节）</strong></p>
<p><img src="https://pic4.zhimg.com/v2-9fb97d3991e3ceb6f45cf177cca76fd7_b.jpg" alt="img"></p>
<p>人的连有很多可以看做是随机的，比如头发的精确位置，使特向更真实，增加了输出的多样性。将这些小特征插入GAN图像的<strong>常用方法是向输入向量添加随机噪声，然后通过输入层输入生成器</strong>。然而，在很多情况下，控制噪声效果是很棘手的，因为特征纠缠现象，略微改变噪声会导致<strong>图像的其他特征收到影响</strong>。</p>
<p>该框架通过<strong>在合成网络的每个分辨率级上增加尺度化的噪声</strong>来回避这些问题。噪声是由高斯噪声组成的单通道图像，将一个噪声图像提供给合成网络的一个特征图。在卷积之后、AdaIN之前将高斯噪声加入生成器网络中。B使用可学习的缩放参数对输入的高斯噪声进行变换，然后将噪声广播到所有的特征图中（分别加到每个特征图上，每个特征图对应一个可学习的scale参数）</p>
<h4 id="2-2-正则化-混合正则化（mixing-regularization）"><a href="#2-2-正则化-混合正则化（mixing-regularization）" class="headerlink" title="2.2 正则化-混合正则化（mixing regularization）"></a>2.2 正则化-混合正则化（mixing regularization）</h4><p>为了进一步距离styles的局部化（<strong>减少不同层之间样式的相关性</strong>），本文对生成器使用混合正则化。</p>
<p>方法：对<strong>给定的训练样本（随机选取）</strong>使用<strong>样式混合</strong>的方式生成图像。在训练过程中，使用两个随机隐码z（latent code）而不是一个，生成图像时，<strong>在合成网络中随机选择一个点（某层），从一个隐码切换到另一个隐码（称之为样式混合）</strong>。具体来说，通过映射网络运行两个潜码z1、z2，并让对应的w1、w2控制样式，使w1在交点前应用，w2在交点后应用</p>
<p>这种正则化技术<strong>防止网络假设相邻样式是相关的</strong>，随机切换确保网络不会学习和依赖级别之间的相关性。</p>
<h4 id="2-3-两种新的量化隐空间（latent-space）耦合度的方法"><a href="#2-3-两种新的量化隐空间（latent-space）耦合度的方法" class="headerlink" title="2.3 两种新的量化隐空间（latent space）耦合度的方法"></a>2.3 两种新的量化隐空间（latent space）耦合度的方法</h4><ul>
<li><p><strong>解耦的目标</strong>是使隐空间（latent space）由线性子空间组成，即每个子空间（每个维度）控制一个变异因子（特征）</p>
</li>
<li><p>但是<strong>隐空间Z</strong>中的各个因子的采样概率<strong>需要与训练数据中响应的密度匹配，就会产生纠缠</strong>。而中间隐藏空间W不需要根据任何固定分布进行采样，<strong>他的采样密度是由可学习的映射网络f(z)得到的，使变化的因素变得更加线性</strong>。</p>
</li>
<li><p>本文假设，生成器基于解耦的表示比基于纠缠的表示应该更容易产生真实的图像（若在FID变小的同时，隐空间耦合度变小，则可以得证）。因此，我们期望训练在无监督的情况下（即，当不预先知道变异的因素时）产生较少纠缠的W</p>
</li>
<li><p><strong>最近提出的用于量化解耦的指标，需要将一个输入图像映射到隐码的编码器网络。</strong>但是不适合本文，因为baseline GAN缺乏这样的编码器</p>
</li>
<li><p>所以本文提出了两种新的量化解耦的方法，他们都不需要编码器，所以对于任何数据集和生成器都是可计算的</p>
<ul>
<li>感知路径长度（Perceptual path length）</li>
<li>线性可分性（Linear separability）</li>
</ul>
</li>
</ul>
<h5 id="感知路径长度"><a href="#感知路径长度" class="headerlink" title="感知路径长度"></a>感知路径长度</h5><p>为什么这种量化纠缠的方法是可行的？</p>
<ul>
<li>对隐空间向量进行插值会在图像中产生非线性变化。比如，在所有断点中缺失的特征可能会出现在线性插值路径的中间。这表明隐空间是耦合的，变化因子没有被恰当的分开。所以通过测量当在两个隐空间之间进行插值时图像的剧烈变化程度，可以反映隐空间的纠缠程度（特征分离程度）</li>
</ul>
<p>感知路径长度计算，使用10000个样本计算</p>
<ul>
<li>将两个隐空间之间的插值路径细分为小段，感知总长度定义为每段感知差异的总和。感知路径长度的定义是这个和在无限细的细分下的极限，实际上是用一个小的细分<img src="https://www.zhihu.com/equation?tex=%5Cepsilon%3D10%5E%7B-4%7D" alt="[å¬å¼]">来近似它。隐空间Z中所有可能端点（在路径中的位置）的平均感知路径长度，计算如下：<img src="https://www.zhihu.com/equation?tex=l_%7BZ%7D%3D%5Cmathbb%7BE%7D%5B%5Cfrac%7B1%7D%7B%5Cepsilon%5E%7B2%7D%7Dd%28G%28slerp%28z_1%2Cz_2%3Bt%29%29%2CG%28slerp%28z_1%2Cz_2%3Bt%2B%5Cepsilon%29%29%29%5D" alt="[å¬å¼]"></li>
<li>其中<img src="https://www.zhihu.com/equation?tex=t%5Csim+U%280%2C1%29" alt="[å¬å¼]">。t服从0， 1分布，slerp表示球面插值操作，这是在归一化的输入隐空间中最合适的插值方式。</li>
<li>G是生成器，d计算得到生成图像之间的感知距离。因为d是二次的，所以除以<img src="https://www.zhihu.com/equation?tex=%5Cepsilon%5E%7B2%7D" alt="[å¬å¼]">而不是<img src="https://www.zhihu.com/equation?tex=%5Cepsilon" alt="[å¬å¼]">来消除对细分粒度的依赖</li>
<li>d的具体计算方式：使用基于感知的成对距离图像，测量连续图像之间的差异（两个VGG16 embeddings之间的差异，利用VGG16提取出图像的特征，在特征层面上计算距离）</li>
</ul>
<p>计算隐空间W的感知路径的长度与z的唯一不同时采用lerp线性插值，因为w向量没有进行归一化</p>
<p><img src="https://www.zhihu.com/equation?tex=l_%7BW%7D%3D%5Cmathbb%7BE%7D%5B%5Cfrac%7B1%7D%7B%5Cepsilon%5E%7B2%7D%7Dd%28g%28lerp%28f%28z_1%29%2Cf%28z_2%29%3Bt%29%29%2Cg%28lerp%28f%28z_1%29%2Cf%28z_2%29%3Bt%2B%5Cepsilon%29%29%29%5D" alt="[å¬å¼]"></p>
<p><strong>线性可分性（linear separability）</strong></p>
<p>为什么这种量化纠缠的方法是可行的？</p>
<p><strong>如果一个隐空间是充分解耦的，应该能够找到与每个变化因子对应的方向向量。</strong>我们提出了另一种度量方法来量化这种效果，<strong>测量通过线性超平面将隐空间点分割成两个不同集合的程度</strong>，使每个集合对应于图像的特定的二元属性（比如男、女）</p>
<p>计算方法：</p>
<ul>
<li>训练40个辅助分类器，分别对40个二元属性进行区分（每个分类器区分一个属性）。分类器与StyleGAN判别器结构相同，使用CelebA-HQ数据集训练得到（保留原始CelebA的40个属性，150000个训练样本),学习率10-3，批次大小8，Adam优化器。</li>
<li>使用生成器生成的200,000个图像，并使用辅助分类器进行分类，根据分类器的置信度对样本进行排序，去掉置信度最低的一般，得到100,000个一直类别的隐空间向量（latent code）</li>
<li>对于每个属性，拟合一个线性SVM来预测标签——基于传统的隐空间点或基于样式的隐空间点w—并且根据这个超平面对这些隐空间点（512维，100,0000个点）进行分类</li>
<li>用<strong>条件熵H(Y |X)度量超平面将点划分为正确类别的能力</strong>，X是SVM预测的类别，Y是预先训练好的辅助分类器确定的类（作为真实类别）；因此，根据SVM确定样本在超平面的哪一边，条件熵告诉我们需要多少额外的信息来确定样本的真实类别。直觉上，如果隐空间中的变化因子是耦合的（非线性的），那么用超平面来分离样本点将会更加困难（需要更多的额外信息），产生高的条件熵。较低的值表示易于分离（可分性好），因此解耦程度更大</li>
</ul>
<p>可分性计算公式 <img src="https://www.zhihu.com/equation?tex=%5Cexp+%5Cleft%28%5Csum_%7Bi%7D+%5Cmathrm%7BH%7D%5Cleft%28Y_%7Bi%7D+%7C+X_%7Bi%7D%5Cright%29%5Cright%29" alt="[公式]"> ，其中i列举了40个属性。取幂是为了将值从对数域变换为线性域，便于进行比较</p>
<p>截断技巧</p>
<p>考虑到训练数据的分布，低密度区域很少被表示，因此生成器很难学习该区域。通过对隐空间进行阶段可以提升生成影响的平均质量，虽然会损失一些变化。对中间隐码W进行阶段，迫使W接近平均值</p>
<p>经过试验：<strong>噪声只会影响随机方面，而保留了整体结构和身份、面部等高级特征。</strong></p>
<p>$\epsilon$</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Mariana</p>
              <p class="site-description motion-element" itemprop="description">a study blog</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">108</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mariana</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
